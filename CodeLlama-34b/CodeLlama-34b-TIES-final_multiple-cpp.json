[["#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if in given vector of numbers, are any two numbers closer to each other than\n// given threshold.\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})), (0.5f))\n// (false)\n// >>> has_close_elements((std::vector<float>({(float)1.0f, (float)2.8f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})), (0.3f))\n// (true)\nbool has_close_elements(std::vector<float> numbers, float threshold) {\n    std::sort(numbers.begin(), numbers.end());\n\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i] - numbers[i - 1] < threshold) {\n            return true;\n        }\n    }\n\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_paren_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_paren_count++;\n        } else if (c == ')') {\n            open_paren_count--;\n        }\n\n        current_group += c;\n\n        if (open_paren_count == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_braces = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_braces++;\n        } else if (c == ')') {\n            open_braces--;\n        }\n\n        if (open_braces == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_count++;\n        }\n        if (c == ')') {\n            open_count--;\n        }\n        if (open_count == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        }\n        if (open_count >= 0) {\n            current_group += c;\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_braces = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_braces++;\n        } else if (c == ')') {\n            open_braces--;\n        }\n\n        if (open_braces == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    assert(open_braces == 0);\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current;\n    int open_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_count++;\n        } else if (c == ')') {\n            open_count--;\n        }\n\n        current += c;\n\n        if (open_count == 0 && !current.empty()) {\n            result.push_back(current);\n            current.clear();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_paren_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_paren_count++;\n        }\n        else if (c == ')') {\n            open_paren_count--;\n        }\n\n        current_group += c;\n\n        if (open_paren_count == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_group;\n    int open_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_count++;\n        }\n        else if (c == ')') {\n            open_count--;\n        }\n\n        current_group += c;\n\n        if (open_count == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_group;\n    int open_paren_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_paren_count++;\n        } else if (c == ')') {\n            open_paren_count--;\n        }\n\n        current_group += c;\n\n        if (open_paren_count == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_braces = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_braces++;\n        } else if (c == ')') {\n            open_braces--;\n        }\n\n        if (open_braces == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    assert(open_braces == 0);\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_paren_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_paren_count++;\n        }\n        if (c == ')') {\n            open_paren_count--;\n        }\n        if (c != ' ' && (open_paren_count == 0 || c == '(')) {\n            current_group += c;\n        }\n        if (open_paren_count == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_paren_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_paren_count++;\n        } else if (c == ')') {\n            open_paren_count--;\n        }\n\n        if (open_paren_count == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_braces = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_braces++;\n        } else if (c == ')') {\n            open_braces--;\n        }\n\n        if (open_braces == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current;\n    int open_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_count++;\n        } else if (c == ')') {\n            open_count--;\n        }\n\n        current.push_back(c);\n\n        if (open_count == 0 && !current.empty()) {\n            result.push_back(current);\n            current.clear();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_group;\n    int open_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_count++;\n        } else if (c == ')') {\n            open_count--;\n        }\n\n        if (open_count == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_paren_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_paren_count++;\n        } else if (c == ')') {\n            open_paren_count--;\n        }\n\n        current_group += c;\n\n        if (open_paren_count == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current;\n    int open_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_count++;\n        } else if (c == ')') {\n            open_count--;\n        }\n\n        if (open_count == 0 && !current.empty()) {\n            result.push_back(current);\n            current.clear();\n        } else {\n            current.push_back(c);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_braces = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_braces++;\n        }\n        else if (c == ')') {\n            open_braces--;\n        }\n\n        current_group += c;\n\n        if (open_braces == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group = \"\";\n    int open_braces = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_braces++;\n        } else if (c == ')') {\n            open_braces--;\n        }\n\n        if (open_braces == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group = \"\";\n        } else {\n            current_group += c;\n        }\n    }\n\n    return groups;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> result;\n    std::string current_group;\n    int open_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_count++;\n        } else if (c == ')') {\n            open_count--;\n        }\n\n        if (open_count == 0 && !current_group.empty()) {\n            result.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"(())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string paren_string) {\n    std::vector<std::string> groups;\n    std::string current_group;\n    int open_paren_count = 0;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            open_paren_count++;\n        } else if (c == ')') {\n            open_paren_count--;\n        }\n\n        if (open_paren_count == 0 && !current_group.empty()) {\n            groups.push_back(current_group);\n            current_group.clear();\n        } else {\n            current_group += c;\n        }\n    }\n\n    return groups;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  int integer_part = (int)number;\n  float decimal_part = number - integer_part;\n  return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n  assert(number >= 0);\n  int integer_part = (int)number;\n  float decimal_part = number - integer_part;\n  return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    int integer_part = (int)number;\n    float decimal_part = number - (float)integer_part;\n    return decimal_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5f))\n// (0.5f)\nfloat truncate_number(float number) {\n    // Get the integer part of the number\n    int integer_part = (int)number;\n\n    // Subtract the integer part from the original number\n    // to get the decimal part\n    float decimal_part = number - (float)integer_part;\n\n    return decimal_part;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long op : operations) {\n    balance += op;\n    if (balance < 0)\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long op : operations) {\n    balance += op;\n    if (balance < 0)\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long op : operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long op : operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long operation : operations) {\n    balance += operation;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long op : operations) {\n    balance += op;\n    if (balance < 0)\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long op : operations) {\n    balance += op;\n    if (balance < 0)\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n  long balance = 0;\n  for (long op : operations) {\n    balance += op;\n    if (balance < 0)\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)3})))\n// (false)\n// >>> below_zero((std::vector<long>({(long)1, (long)2, (long)-4, (long)5})))\n// (true)\nbool below_zero(std::vector<long> operations) {\n    long balance = 0;\n    for (long op : operations) {\n        balance += op;\n        if (balance < 0)\n            return true;\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    std::vector<float> diff(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), diff.begin(),\n                   [mean](float x) { return std::abs(x - mean); });\n    return std::accumulate(diff.begin(), diff.end(), 0.0f) / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float sum_of_absolute_deviations = 0.0f;\n    for (float num : numbers) {\n        sum_of_absolute_deviations += std::abs(num - mean);\n    }\n    return sum_of_absolute_deviations / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float sum_of_diff = 0.0f;\n    for (float num : numbers) {\n        sum_of_diff += std::abs(num - mean);\n    }\n    return sum_of_diff / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0.0f;\n    float mean = 0.0f;\n    float mad = 0.0f;\n    int n = numbers.size();\n\n    // Calculate mean\n    for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n    }\n    mean = sum / n;\n\n    // Calculate MAD\n    for (int i = 0; i < n; i++) {\n        mad += std::abs(numbers[i] - mean);\n    }\n    mad /= n;\n\n    return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  for (auto num : numbers) {\n    sum += num;\n  }\n  mean = sum / numbers.size();\n  float mad = 0.0f;\n  for (auto num : numbers) {\n    mad += std::abs(num - mean);\n  }\n  mad /= numbers.size();\n  return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float sum_of_diff = 0.0f;\n    for (float num : numbers) {\n        sum_of_diff += std::abs(num - mean);\n    }\n    return sum_of_diff / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  float mad = 0.0f;\n  int n = numbers.size();\n  // Calculate mean\n  for (int i = 0; i < n; i++) {\n    sum += numbers[i];\n  }\n  mean = sum / n;\n  // Calculate MAD\n  for (int i = 0; i < n; i++) {\n    mad += std::abs(numbers[i] - mean);\n  }\n  mad /= n;\n  return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0;\n    float mean = 0;\n    float mad = 0;\n    for (auto num : numbers) {\n        sum += num;\n    }\n    mean = sum / numbers.size();\n    for (auto num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n    return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0.0f;\n    float mean = 0.0f;\n    float mad = 0.0f;\n    int n = numbers.size();\n\n    // Calculate the mean\n    for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n    }\n    mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    for (int i = 0; i < n; i++) {\n        mad += std::abs(numbers[i] - mean);\n    }\n    mad /= n;\n\n    return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0.0f;\n    float mean = 0.0f;\n    float mad = 0.0f;\n\n    // Calculate the mean of the dataset\n    for (float num : numbers) {\n        sum += num;\n    }\n    mean = sum / numbers.size();\n\n    // Calculate the Mean Absolute Deviation\n    for (float num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  for (float num : numbers) {\n    sum += num;\n  }\n  mean = sum / numbers.size();\n  float mad = 0.0f;\n  for (float num : numbers) {\n    mad += std::abs(num - mean);\n  }\n  mad /= numbers.size();\n  return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  for (auto num : numbers) {\n    sum += num;\n  }\n  mean = sum / numbers.size();\n  sum = 0.0f;\n  for (auto num : numbers) {\n    sum += std::abs(num - mean);\n  }\n  return sum / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0.0f;\n    float mean = 0.0f;\n    for (auto num : numbers) {\n        sum += num;\n    }\n    mean = sum / numbers.size();\n\n    float mad = 0.0f;\n    for (auto num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float sum_of_diff = 0.0f;\n    for (float num : numbers) {\n        sum_of_diff += std::abs(num - mean);\n    }\n    return sum_of_diff / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  for (auto num : numbers) {\n    sum += num;\n  }\n  mean = sum / numbers.size();\n  float mad = 0.0f;\n  for (auto num : numbers) {\n    mad += std::abs(num - mean);\n  }\n  mad /= numbers.size();\n  return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0.0f;\n    float mean = 0.0f;\n    float mad = 0.0f;\n    int n = numbers.size();\n\n    // Calculate the mean\n    for (int i = 0; i < n; i++) {\n        sum += numbers[i];\n    }\n    mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    for (int i = 0; i < n; i++) {\n        mad += std::abs(numbers[i] - mean);\n    }\n    mad /= n;\n\n    return mad;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    float sum_of_diff = 0.0f;\n    for (auto num : numbers) {\n        sum_of_diff += std::abs(num - mean);\n    }\n    return sum_of_diff / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float mean = std::accumulate(numbers.begin(), numbers.end(), 0.0f) / numbers.size();\n    std::vector<float> diff(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), diff.begin(),\n                   [mean](float x) { return std::abs(x - mean); });\n    return std::accumulate(diff.begin(), diff.end(), 0.0f) / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n  float sum = 0.0f;\n  float mean = 0.0f;\n  for (auto num : numbers) {\n    sum += num;\n  }\n  mean = sum / numbers.size();\n  float mad = 0.0f;\n  for (auto num : numbers) {\n    mad += std::abs(num - mean);\n  }\n  return mad / numbers.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> mean_absolute_deviation((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f})))\n// (1.0f)\nfloat mean_absolute_deviation(std::vector<float> numbers) {\n    float sum = 0.0f;\n    float mean = 0.0f;\n    float mad = 0.0f;\n\n    // Calculate the mean of the dataset\n    for (auto num : numbers) {\n        sum += num;\n    }\n    mean = sum / numbers.size();\n\n    // Calculate the Mean Absolute Deviation around the mean\n    for (auto num : numbers) {\n        mad += abs(num - mean);\n    }\n    mad /= numbers.size();\n\n    return mad;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (long i = 0; i < numbers.size(); i++) {\n    result.push_back(numbers[i]);\n    if (i != numbers.size() - 1) {\n      result.push_back(delimeter);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (long i = 0; i < numbers.size(); i++) {\n    result.push_back(numbers[i]);\n    if (i != numbers.size() - 1) {\n      result.push_back(delimeter);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n  std::vector<long> result;\n  for (long i = 0; i < numbers.size(); i++) {\n    result.push_back(numbers[i]);\n    if (i != numbers.size() - 1) {\n      result.push_back(delimeter);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (int i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Insert a number 'delimeter' between every two consecutive elements of input vector `numbers'\n// >>> intersperse((std::vector<long>()), (4))\n// (std::vector<long>())\n// >>> intersperse((std::vector<long>({(long)1, (long)2, (long)3})), (4))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)4, (long)3}))\nstd::vector<long> intersperse(std::vector<long> numbers, long delimeter) {\n    std::vector<long> result;\n    for (long i = 0; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    long max_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(++max_depth);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(max_depth);\n            max_depth = 0;\n        }\n    }\n    result.push_back(max_depth);\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::vector<int> stack;\n    stack.push_back(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push_back(stack.back() + 1);\n        } else if (c == ')') {\n            stack.pop_back();\n            assert(!stack.empty());\n        }\n    }\n    assert(stack.size() == 1);\n    result.push_back(stack.back());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    long max_depth = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(++max_depth);\n        } else if (c == ')') {\n            if (!stack.empty()) {\n                max_depth = stack.top();\n                stack.pop();\n            }\n        } else if (c == ' ') {\n            result.push_back(max_depth);\n            max_depth = 0;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::istringstream iss(paren_string);\n    std::string group;\n    while (iss >> group) {\n        long max_depth = 0;\n        long current_depth = 0;\n        for (char c : group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        assert(current_depth == 0);\n        result.push_back(max_depth);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string paren_group;\n    while (ss >> paren_group) {\n        long level = 0;\n        long max_level = 0;\n        for (char c : paren_group) {\n            if (c == '(') {\n                level++;\n                max_level = std::max(max_level, level);\n            } else if (c == ')') {\n                level--;\n            }\n        }\n        assert(level == 0);\n        result.push_back(max_level);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    long max_level = 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(++max_level);\n        } else if (c == ')') {\n            assert(!stack.empty());\n            max_level = stack.top() - 1;\n            stack.pop();\n        }\n        if (c == ' ' && !stack.empty()) {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string paren_group;\n    while (ss >> paren_group) {\n        long max_depth = 0;\n        long current_depth = 0;\n        for (char c : paren_group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        assert(current_depth == 0);\n        result.push_back(max_depth);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> max_depths;\n    std::vector<long> depths;\n    for (char c : paren_string) {\n        if (c == '(') {\n            depths.push_back(depths.empty() ? 1 : depths.back() + 1);\n        } else if (c == ')') {\n            assert(!depths.empty());\n            max_depths.push_back(std::max(max_depths.empty() ? 0 : max_depths.back(), depths.back());\n            depths.pop_back();\n        }\n    }\n    assert(depths.empty());\n    return max_depths;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n    std::string paren_group;\n\n    while (ss >> paren_group) {\n        long max_depth = 0;\n        long current_depth = 0;\n        for (char c : paren_group) {\n            if (c == '(') {\n                current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n            } else if (c == ')') {\n                current_depth--;\n            }\n        }\n        assert(current_depth == 0);\n        result.push_back(max_depth);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> depth_stack;\n    depth_stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            depth_stack.push(depth_stack.top() + 1);\n        } else if (c == ')') {\n            depth_stack.pop();\n        } else if (c == ' ') {\n            result.push_back(depth_stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> max_depths;\n    std::stack<long> depths;\n    depths.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            depths.push(depths.top() + 1);\n        } else if (c == ')') {\n            max_depths.push_back(depths.top());\n            depths.pop();\n        }\n    }\n    assert(depths.size() == 1);\n    return max_depths;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    stack.push(0);\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push(stack.top() + 1);\n        } else if (c == ')') {\n            stack.pop();\n        } else if (c == ' ') {\n            result.push_back(stack.top());\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::vector<long> stack;\n\n    for (char c : paren_string) {\n        if (c == '(') {\n            stack.push_back(0);\n        } else if (c == ')') {\n            long last = stack.back();\n            stack.pop_back();\n            if (stack.empty()) {\n                result.push_back(last);\n            } else {\n                stack.back() = std::max(stack.back(), last + 1);\n            }\n        }\n    }\n\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> filtered;\n  for (std::string s : strings) {\n    if (s.find(substring) != std::string::npos) {\n      filtered.push_back(s);\n    }\n  }\n  return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (auto &s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> filtered_strings;\n  for (std::string s : strings) {\n    if (s.find(substring) != std::string::npos) {\n      filtered_strings.push_back(s);\n    }\n  }\n  return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered_strings;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (auto &s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> filtered_strings;\n  for (std::string s : strings) {\n    if (s.find(substring) != std::string::npos) {\n      filtered_strings.push_back(s);\n    }\n  }\n  return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered_strings;\n    for (auto &str : strings) {\n        if (str.find(substring) != std::string::npos) {\n            filtered_strings.push_back(str);\n        }\n    }\n    return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (auto& s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered_strings;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n  std::vector<std::string> filtered;\n  for (std::string s : strings) {\n    if (s.find(substring) != std::string::npos) {\n      filtered.push_back(s);\n    }\n  }\n  return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (auto &s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (auto &s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered_strings;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered_strings;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that contain given substring\n// >>> filter_by_substring((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_substring((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"bacd\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_substring(std::vector<std::string> strings, std::string substring) {\n    std::vector<std::string> filtered_strings;\n    for (std::string s : strings) {\n        if (s.find(substring) != std::string::npos) {\n            filtered_strings.push_back(s);\n        }\n    }\n    return filtered_strings;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a vector.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> sum_product((std::vector<long>()))\n// (std::make_tuple(0, 1))\n// >>> sum_product((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::make_tuple(10, 24))\nstd::tuple<long, long> sum_product(std::vector<long> numbers) {\n    long sum = 0;\n    long product = 1;\n\n    for (long number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return std::make_tuple(sum, product);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers(numbers.size());\n    long max_number = numbers[0];\n    max_numbers[0] = max_number;\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers[i] = max_number;\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (int i = 1; i < numbers.size(); i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers;\n    long max_number = numbers[0];\n    max_numbers.push_back(max_number);\n    for (long i = 1; i < numbers.size(); i++) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers.push_back(max_number);\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers;\n    long max_number = numbers[0];\n    max_numbers.push_back(max_number);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers.push_back(max_number);\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers(numbers.size());\n    long max_number = numbers[0];\n    max_numbers[0] = max_number;\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers[i] = max_number;\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers;\n    long max_number = numbers[0];\n    max_numbers.push_back(max_number);\n    for (long i = 1; i < numbers.size(); i++) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers.push_back(max_number);\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers;\n    long max_number = numbers[0];\n    max_numbers.push_back(max_number);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers.push_back(max_number);\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers;\n    long max_number = numbers[0];\n    max_numbers.push_back(max_number);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers.push_back(max_number);\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (int i = 1; i < numbers.size(); i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (long i = 1; i < numbers.size(); i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers;\n    long max_number = numbers[0];\n    max_numbers.push_back(max_number);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers.push_back(max_number);\n    }\n    return max_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (int i = 1; i < numbers.size(); i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (long i = 1; i < numbers.size(); i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> result;\n    long max_so_far = numbers[0];\n    result.push_back(max_so_far);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result.push_back(max_so_far);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)3, (long)4, (long)2})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4}))\nstd::vector<long> rolling_max(std::vector<long> numbers) {\n    std::vector<long> max_numbers;\n    long max_number = numbers[0];\n    max_numbers.push_back(max_number);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max_number = std::max(max_number, numbers[i]);\n        max_numbers.push_back(max_number);\n    }\n    return max_numbers;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    std::string reversed_string = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\n    std::string palindrome = string;\n    for (int i = string.size() - 1; i >= 0; --i) {\n        if (string[i] == reversed_string[i]) {\n            palindrome = string.substr(0, i) + reversed_string.substr(i);\n        }\n    }\n\n    return palindrome;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<std::vector<bool>> dp(n, std::vector<bool>(n, false));\n    int max_len = 0;\n    int end_idx = 0;\n\n    // Fill the dp matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (string[i] == string[j] && (i - j <= 2 || dp[j + 1][i - 1])) {\n                dp[j][i] = true;\n                if (i - j + 1 > max_len) {\n                    max_len = i - j + 1;\n                    end_idx = i;\n                }\n            }\n        }\n    }\n\n    // Extract the longest palindromic suffix\n    std::string suffix = string.substr(end_idx - max_len + 1, max_len);\n\n    // Reverse the prefix before the palindromic suffix\n    std::string prefix = string.substr(0, end_idx - max_len + 1);\n    std::reverse(prefix.begin(), prefix.end());\n\n    // Append the reversed prefix to the end of the string\n    string += prefix;\n\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<std::vector<bool>> palindrome(n, std::vector<bool>(n, false));\n\n    // All substrings of length 1 are palindromes\n    for (int i = 0; i < n; ++i) {\n        palindrome[i][i] = true;\n    }\n\n    // Check for substrings of length 2\n    for (int i = 0; i < n - 1; ++i) {\n        palindrome[i][i + 1] = (string[i] == string[i + 1]);\n    }\n\n    // Check for substrings of length 3 and more\n    for (int length = 3; length <= n; ++length) {\n        for (int i = 0; i < n - length + 1; ++i) {\n            int j = i + length - 1;\n            palindrome[i][j] = (string[i] == string[j] && palindrome[i + 1][j - 1]);\n        }\n    }\n\n    // Find the longest palindromic suffix\n    int max_length = 0;\n    for (int i = 0; i < n; ++i) {\n        if palindrome[0][i] && i + 1 > max_length {\n            max_length = i + 1;\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    std::string suffix = string.substr(0, max_length);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<std::vector<bool>> dp(n, std::vector<bool>(n, false));\n\n    // Initialize the diagonal elements of the matrix to true\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = true;\n    }\n\n    // Fill the rest of the matrix\n    for (int i = n - 2; i >= 0; i--) {\n        for (int j = i + 1; j < n; j++) {\n            dp[i][j] = (string[i] == string[j] && dp[i + 1][j - 1]);\n        }\n    }\n\n    // Find the longest palindromic suffix\n    int max_length = 0;\n    for (int i = 0; i < n; i++) {\n        if dp[0][i] {\n            max_length = i + 1;\n        }\n    }\n\n    // Append the reverse of the prefix to the end of the string\n    std::string suffix = string.substr(0, max_length);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    std::string reversed_string = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\n    int n = string.size();\n    int i = 0;\n    while (i < n && string[i] == reversed_string[i]) {\n        i++;\n    }\n\n    return string + reversed_string.substr(i);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<std::vector<bool>> dp(n, std::vector<bool>(n, false));\n\n    // Initialize the diagonal values of the 2D array to true\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = true;\n    }\n\n    // Fill the 2D array in bottom-up manner\n    for (int i = 0; i < n - 1; i++) {\n        dp[i][i + 1] = (string[i] == string[i + 1]);\n    }\n\n    for (int i = 2; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            dp[j][j + i] = (dp[j + 1][j + i - 1] && string[j] == string[j + i]);\n        }\n    }\n\n    // Find the longest palindromic suffix\n    int max_len = 0;\n    for (int i = 0; i < n; i++) {\n        if dp[0][i] && i + 1 > max_len {\n            max_len = i + 1;\n        }\n    }\n\n    // Append the reverse of the prefix before the palindromic suffix\n    std::string suffix = string.substr(0, max_len);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    std::string reversed_string = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\n    int len = string.size();\n    int palindrome_len = 0;\n    for (int i = 0; i < len; i++) {\n        if (string[i] == reversed_string[i]) {\n            palindrome_len = i + 1;\n        } else {\n            break;\n        }\n    }\n\n    std::string suffix = string.substr(palindrome_len);\n    std::reverse(suffix.begin(), suffix.end());\n\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<int> p(n, 0);\n\n    // Find the longest palindromic suffix.\n    int center = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i < center + p[center - i]) {\n            p[i] = std::min(center + p[center - i] - i, p[i - 1]);\n        }\n        while (string[i + p[i]] == string[p[i]]) {\n            ++p[i];\n        }\n        if (i + p[i] > center) {\n            center = i;\n        }\n    }\n\n    // Append the reverse of the prefix before the palindromic suffix.\n    std::string suffix = string.substr(center - p[center]);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<std::vector<bool>> palindrome(n, std::vector<bool>(n, false));\n\n    // All substrings of length 1 are palindromes\n    for (int i = 0; i < n; i++)\n        palindrome[i][i] = true;\n\n    // Check for substrings of length 2\n    for (int i = 0; i < n - 1; i++)\n        palindrome[i][i + 1] = (string[i] == string[i + 1]);\n\n    // Check for substrings of length > 2\n    for (int length = 3; length <= n; length++) {\n        for (int i = 0; i < n - length + 1; i++) {\n            int j = i + length - 1;\n            palindrome[i][j] = (string[i] == string[j] && palindrome[i + 1][j - 1]);\n        }\n    }\n\n    // Find the longest palindromic suffix\n    int max_length = 0;\n    for (int i = 0; i < n; i++) {\n        if palindrome[0][i] {\n            max_length = i + 1;\n        }\n    }\n\n    // Append the reverse of the prefix to the end of the string\n    std::string suffix = string.substr(0, max_length);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<int> p(n, 0);\n    for (int i = 1; i < n; ++i) {\n        int j = p[i - 1];\n        while (j > 0 && string[i] != string[j])\n            j = p[j - 1];\n        if (string[i] == string[j])\n            ++j;\n        p[i] = j;\n    }\n    std::string suffix = string.substr(p[n - 1]);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  int n = string.size();\n  // Find the longest palindromic suffix.\n  int i = 0;\n  while (i < n && string[i] == string[n - 1 - i]) {\n    ++i;\n  }\n  // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  return string + string.substr(0, i).reverse();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<std::vector<bool>> palindrome(n, std::vector<bool>(n, false));\n\n    for (int i = 0; i < n; i++) {\n        palindrome[i][i] = true;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        palindrome[i][i + 1] = (string[i] == string[i + 1]);\n    }\n\n    for (int length = 3; length <= n; length++) {\n        for (int i = 0; i < n - length + 1; i++) {\n            int j = i + length - 1;\n            palindrome[i][j] = (palindrome[i + 1][j - 1] && string[i] == string[j]);\n        }\n    }\n\n    int longest_palindrome_length = 0;\n    int longest_palindrome_index = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (palindrome[0][i] && longest_palindrome_length < i + 1) {\n            longest_palindrome_length = i + 1;\n            longest_palindrome_index = i;\n        }\n    }\n\n    std::string suffix = string.substr(0, longest_palindrome_length);\n    std::string prefix = string.substr(longest_palindrome_length);\n\n    std::reverse(prefix.begin(), prefix.end());\n\n    return suffix + prefix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    std::string reversed_string = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\n    std::string suffix = \"\";\n    for (int i = string.size() - 1; i >= 0; --i) {\n        if (string.substr(0, i + 1) == reversed_string.substr(0, i + 1)) {\n            suffix = string.substr(0, i + 1);\n            break;\n        }\n    }\n\n    std::string prefix = string.substr(suffix.size());\n    std::reverse(prefix.begin(), prefix.end());\n\n    return string + prefix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<int> prefix(n, 0);\n    int i = 0, j = 1;\n    while (j < n) {\n        if (string[i] == string[j]) {\n            prefix[j] = i + 1;\n            i++;\n            j++;\n        } else {\n            if (i > 0) {\n                i = prefix[i - 1];\n            } else {\n                j++;\n            }\n        }\n    }\n    std::string suffix = string.substr(0, prefix[n - 1]);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<int> p(n);\n\n    // Find the longest palindromic suffix.\n    int center = 0;\n    for (int i = 1; i < n; ++i) {\n        if (i < center + p[center - i]) {\n            p[i] = std::min(center + p[center - i] - i, i);\n        }\n        while (string[i - p[i] - 1] == string[i + p[i]]) {\n            ++p[i];\n        }\n        if (i + p[i] > center) {\n            center = i;\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    std::string suffix = string.substr(center - p[center]);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<int> prefix_function(n);\n\n    // prefix function for string\n    for (int i = 1; i < n; ++i) {\n        int j = prefix_function[i - 1];\n        while (j > 0 && string[i] != string[j])\n            j = prefix_function[j - 1];\n        if (string[i] == string[j])\n            ++j;\n        prefix_function[i] = j;\n    }\n\n    // find longest palindrome\n    int longest_palindrome = 0;\n    for (int i = 1; i < n; ++i)\n        longest_palindrome = std::max(longest_palindrome, prefix_function[i]);\n\n    // append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    std::string suffix = string.substr(longest_palindrome);\n    std::reverse(suffix.begin(), suffix.end());\n    string += suffix;\n\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<std::vector<bool>> palindrome(n, std::vector<bool>(n, false));\n\n    for (int i = 0; i < n; i++) {\n        palindrome[i][i] = true;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        palindrome[i][i + 1] = (string[i] == string[i + 1]);\n    }\n\n    for (int length = 3; length <= n; length++) {\n        for (int i = 0; i < n - length + 1; i++) {\n            int j = i + length - 1;\n            palindrome[i][j] = (string[i] == string[j] && palindrome[i + 1][j - 1]);\n        }\n    }\n\n    int longest_palindrome_end = 0;\n    for (int i = 0; i < n; i++) {\n        if palindrome[0][i]:\n            longest_palindrome_end = i;\n\n    int palindrome_length = longest_palindrome_end + 1;\n    std::string suffix = string.substr(0, palindrome_length);\n    std::string prefix = string.substr(palindrome_length);\n    std::reverse(prefix.begin(), prefix.end());\n    return suffix + prefix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  int n = string.size();\n  std::vector<int> p(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    int j = p[i - 1];\n    while (j > 0 && string[i - 1] != string[j - 1])\n      j = p[j - 1];\n    p[i] = j + (string[i - 1] == string[j]);\n  }\n  std::string suffix = string.substr(p[n] - 1);\n  std::reverse(suffix.begin(), suffix.end());\n  return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n    int n = string.size();\n    std::vector<bool> palindrome(n * 2 + 1, false);\n    int center = 0;\n    int right_limit = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i < right_limit) {\n            palindrome[i] = palindrome[(center << 1) - i];\n        }\n        while (string[i] == string[right_limit]) {\n            palindrome[i + right_limit + 1] = true;\n            ++right_limit;\n        }\n        if (right_limit > i) {\n            center = i;\n        }\n    }\n    std::string suffix = string.substr(center + 1);\n    std::reverse(suffix.begin(), suffix.end());\n    return string + suffix;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n// (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string string) {\n  // Find the longest postfix that is a palindrome.\n  int i = 0;\n  while (i < string.size() && string[i] == string[string.size() - 1 - i]) {\n    i++;\n  }\n  // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  return string + string.substr(0, i).reverse();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i] ? '0' : '1');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result.push_back(a[i] ^ b[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result += (a[i] == b[i] ? '0' : '1');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result(a.size(), '0');\n    for (size_t i = 0; i < a.size(); ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.length() == b.length());\n\n    std::string result;\n    for (int i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result += (a[i] == b[i] ? '0' : '1');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    assert(a.size() == b.size());\n    for (int i = 0; i < a.size(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i] ? '0' : '1');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i] ? '0' : '1');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result.push_back(a[i] ^ b[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result(a.size(), '0');\n    for (size_t i = 0; i < a.size(); ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result += (a[i] == b[i] ? '0' : '1');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    assert(a.size() == b.size());\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] == '1' && b[i] == '1') {\n            result += '0';\n        } else if (a[i] == '0' && b[i] == '0') {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    assert(a.size() == b.size());\n    for (int i = 0; i < a.size(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result.push_back(a[i] ^ b[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\")\nstd::string string_xor(std::string a, std::string b) {\n    assert(a.size() == b.size());\n    std::string result;\n    for (int i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i] ? '0' : '1');\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.length() > longest_string.length()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string str : strings) {\n    if (str.length() > longest_string.length()) {\n      longest_string = str;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.length() > longest_string.length()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.length() > longest_string.length()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty())\n        return std::nullopt;\n\n    std::string longest_string = strings[0];\n    for (const std::string& s : strings) {\n        if (s.size() > longest_string.size())\n            longest_string = s;\n    }\n    return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    std::string longest_string = strings[0];\n    for (const std::string& s : strings) {\n        if (s.size() > longest_string.size()) {\n            longest_string = s;\n        }\n    }\n\n    return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty())\n    return std::nullopt;\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.length() > longest_string.length())\n      longest_string = s;\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.length() > longest_string.length()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.size() > longest_string.size()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    std::string longest_string = strings[0];\n    for (std::string s : strings) {\n        if (s.length() > longest_string.length()) {\n            longest_string = s;\n        }\n    }\n\n    return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string str : strings) {\n    if (str.size() > longest_string.size()) {\n      longest_string = str;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty())\n    return std::nullopt;\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.size() > longest_string.size())\n      longest_string = s;\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string str : strings) {\n    if (str.length() > longest_string.length()) {\n      longest_string = str;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.size() > longest_string.size()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.size() > longest_string.size()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    std::string longest_string = strings[0];\n    for (std::string s : strings) {\n        if (s.size() > longest_string.size()) {\n            longest_string = s;\n        }\n    }\n\n    return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    std::string longest_string = strings[0];\n    for (std::string str : strings) {\n        if (str.size() > longest_string.size()) {\n            longest_string = str;\n        }\n    }\n\n    return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.length() > longest_string.length()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.size() > longest_string.size()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Out of vector of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input vector is empty.\n// >>> longest((std::vector<std::string>()))\n// std::nullopt\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// \"a\"\n// >>> longest((std::vector<std::string>({(std::string)\"a\", (std::string)\"bb\", (std::string)\"ccc\"})))\n// \"ccc\"\nstd::optional<std::string> longest(std::vector<std::string> strings) {\n  if (strings.empty()) {\n    return std::nullopt;\n  }\n  std::string longest_string = strings[0];\n  for (std::string s : strings) {\n    if (s.length() > longest_string.length()) {\n      longest_string = s;\n    }\n  }\n  return longest_string;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  assert(a >= 0 && b >= 0);\n  while (b != 0) {\n    long t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    if (b == 0)\n        return a;\n    else\n        return greatest_common_divisor(b, a % b);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n  assert(a >= 0 && b >= 0);\n  while (b != 0) {\n    long t = b;\n    b = a % b;\n    a = t;\n  }\n  return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    if (b == 0)\n        return a;\n    else\n        return greatest_common_divisor(b, a % b);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n    while (b != 0) {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a greatest common divisor of two integers a and b\n// >>> greatest_common_divisor((3), (5))\n// (1)\n// >>> greatest_common_divisor((25), (15))\n// (5)\nlong greatest_common_divisor(long a, long b) {\n    assert(a >= 0 && b >= 0);\n    while (b != 0) {\n        long t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.length(); ++i) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); ++i) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of all prefixes from shortest to longest of the input string\n// >>> all_prefixes((\"abc\"))\n// (std::vector<std::string>({(std::string)\"a\", (std::string)\"ab\", (std::string)\"abc\"}))\nstd::vector<std::string> all_prefixes(std::string string) {\n    std::vector<std::string> prefixes;\n    for (int i = 0; i < string.size(); i++) {\n        prefixes.push_back(string.substr(0, i + 1));\n    }\n    return prefixes;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::stringstream ss;\n    for (long i = 0; i <= n; ++i) {\n        ss << i << \" \";\n    }\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::stringstream ss;\n    for (long i = 0; i <= n; ++i) {\n        ss << i << \" \";\n    }\n    std::string s = ss.str();\n    return s.substr(0, s.length() - 1);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        oss << i << \" \";\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        oss << i << \" \";\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        oss << i << \" \";\n    }\n    std::string result = oss.str();\n    result.pop_back(); // Remove trailing space.\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        oss << i << \" \";\n    }\n    std::string result = oss.str();\n    result.pop_back(); // Remove trailing space.\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::stringstream ss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) ss << ' ';\n        ss << i;\n    }\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; i++) {\n        oss << i << \" \";\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::stringstream ss;\n    for (long i = 0; i <= n; ++i) {\n        ss << i << \" \";\n    }\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; i++) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i != 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        oss << i;\n        if (i != n)\n            oss << ' ';\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        oss << i << \" \";\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::ostringstream oss;\n    for (long i = 0; i <= n; ++i) {\n        if (i > 0) {\n            oss << \" \";\n        }\n        oss << i;\n    }\n    return oss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n// >>> string_sequence((0))\n// (\"0\")\n// >>> string_sequence((5))\n// (\"0 1 2 3 4 5\")\nstd::string string_sequence(long n) {\n    std::stringstream ss;\n    for (long i = 0; i <= n; ++i) {\n        ss << i << \" \";\n    }\n    std::string s = ss.str();\n    s.pop_back(); // Remove trailing space.\n    return s;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n\n    for(char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for(char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_chars;\n\n    for (char c : string) {\n        distinct_chars.insert(std::tolower(c));\n    }\n\n    return distinct_chars.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_characters;\n\n    for (char c : string) {\n        distinct_characters.insert(std::tolower(c));\n    }\n\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for(char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for(char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::unordered_set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(std::tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(tolower(c));\n    }\n    return distinct_characters.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong count_distinct_characters(std::string string) {\n    std::set<char> distinct_characters;\n    for (char c : string) {\n        distinct_characters.insert(std::tolower(c));\n    }\n    return distinct_characters.size();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::istringstream iss(music_string);\n    std::string note;\n    while (iss >> note) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    return beats;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> beats;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            beats.push_back(4);\n        } else if (note == \"o|\") {\n            beats.push_back(2);\n        } else if (note == \".|\") {\n            beats.push_back(1);\n        }\n    }\n    return beats;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::istringstream iss(music_string);\n    std::string note;\n    while (iss >> note) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::istringstream iss(music_string);\n    std::string note;\n    while (iss >> note) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music((\"o o| .| o| o| .| .| .| .| o o\"))\n// (std::vector<long>({(long)4, (long)2, (long)1, (long)2, (long)2, (long)1, (long)1, (long)1, (long)1, (long)4, (long)4}))\nstd::vector<long> parse_music(std::string music_string) {\n    std::vector<long> result;\n    std::stringstream ss(music_string);\n    std::string note;\n    while (std::getline(ss, note, ' ')) {\n        if (note == \"o\") {\n            result.push_back(4);\n        } else if (note == \"o|\") {\n            result.push_back(2);\n        } else if (note == \".|\") {\n            result.push_back(1);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    ++count;\n    pos += substring.length();\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos += substring.length();\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        count++;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n    long count = 0;\n    size_t pos = 0;\n    while ((pos = string.find(substring, pos)) != std::string::npos) {\n        ++count;\n        pos += substring.length();\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given substring can be found in the original string. Count overlaping cases.\n// >>> how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string string, std::string substring) {\n  long count = 0;\n  size_t pos = 0;\n  while ((pos = string.find(substring, pos)) != std::string::npos) {\n    count++;\n    pos += substring.length();\n  }\n  return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (int i = 0; i < nums.size(); ++i) {\n        result << nums[i];\n        if (i != nums.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    std::vector<std::string> sorted_nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        sorted_nums.push_back(num);\n    }\n    std::sort(sorted_nums.begin(), sorted_nums.end(), [&](const std::string& a, const std::string& b) {\n        return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);\n    });\n    std::stringstream result;\n    for (const auto& num : sorted_nums) {\n        result << num << \" \";\n    }\n    std::string result_str = result.str();\n    result_str.pop_back();\n    return result_str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (auto &num : nums) {\n        result << num << \" \";\n    }\n\n    std::string sorted_numbers = result.str();\n    sorted_numbers.pop_back(); // remove trailing space\n    return sorted_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    std::vector<std::string> sorted_nums;\n\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        sorted_nums.push_back(num);\n    }\n\n    std::sort(sorted_nums.begin(), sorted_nums.end(), [&](std::string a, std::string b) {\n        return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);\n    });\n\n    std::stringstream result;\n    for (auto &num : sorted_nums) {\n        result << num << \" \";\n    }\n\n    std::string result_str = result.str();\n    result_str.pop_back();\n    return result_str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (int i = 0; i < nums.size(); i++) {\n        result << nums[i];\n        if (i != nums.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (const auto& num : nums) {\n        result << num << \" \";\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (auto &num : nums) {\n        result << num << \" \";\n    }\n\n    std::string res = result.str();\n    res.pop_back();\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (auto& num : nums) {\n        result << num << \" \";\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    std::vector<std::string> sorted_nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        sorted_nums.push_back(num);\n    }\n    std::sort(sorted_nums.begin(), sorted_nums.end(), [&](const std::string &a, const std::string &b) {\n        return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);\n    });\n    std::stringstream result;\n    for (const auto &num : sorted_nums) {\n        result << num << \" \";\n    }\n    std::string result_str = result.str();\n    result_str.pop_back();\n    return result_str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream sorted_numbers;\n    for (int i = 0; i < nums.size(); i++) {\n        sorted_numbers << nums[i];\n        if (i != nums.size() - 1) {\n            sorted_numbers << \" \";\n        }\n    }\n\n    return sorted_numbers.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (const auto& num : nums) {\n        result << num << \" \";\n    }\n\n    std::string sorted_numbers = result.str();\n    sorted_numbers.pop_back(); // Remove trailing space\n    return sorted_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    std::vector<std::string> sorted_nums;\n\n    std::istringstream iss(numbers);\n    std::string num;\n    while (iss >> num) {\n        sorted_nums.push_back(num);\n    }\n\n    std::sort(sorted_nums.begin(), sorted_nums.end(), [&](const std::string& a, const std::string& b) {\n        return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);\n    });\n\n    std::ostringstream oss;\n    for (const auto& num : sorted_nums) {\n        oss << num << \" \";\n    }\n\n    std::string result = oss.str();\n    result.pop_back();\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (const auto& num : nums) {\n        result << num << \" \";\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    std::vector<std::string> sorted_nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        sorted_nums.push_back(num);\n    }\n    std::sort(sorted_nums.begin(), sorted_nums.end(), [&](std::string a, std::string b) {\n        return std::find(nums.begin(), nums.end(), a) < std::find(nums.begin(), nums.end(), b);\n    });\n    std::stringstream result;\n    for (int i = 0; i < sorted_nums.size(); i++) {\n        result << sorted_nums[i];\n        if (i != sorted_nums.size() - 1) {\n            result << \" \";\n        }\n    }\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream sorted_numbers;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        sorted_numbers << nums[i];\n        if (i != nums.size() - 1) {\n            sorted_numbers << \" \";\n        }\n    }\n\n    return sorted_numbers.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (int i = 0; i < nums.size(); i++) {\n        result << nums[i];\n        if (i != nums.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (i != 0) {\n            result << \" \";\n        }\n        result << nums[i];\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (i != 0) {\n            result << \" \";\n        }\n        result << nums[i];\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream result;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        result << nums[i];\n        if (i != nums.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// >>> sort_numbers((\"three one five\"))\n// (\"one three five\")\nstd::string sort_numbers(std::string numbers) {\n    std::vector<std::string> nums;\n    std::stringstream ss(numbers);\n    std::string num;\n    while (ss >> num) {\n        nums.push_back(num);\n    }\n\n    std::sort(nums.begin(), nums.end());\n\n    std::stringstream sorted_numbers;\n    for (const auto& num : nums) {\n        sorted_numbers << num << \" \";\n    }\n\n    std::string result = sorted_numbers.str();\n    result.pop_back();\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float smaller_num = 0.0f;\n    float larger_num = 0.0f;\n\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            smaller_num = numbers[i];\n            larger_num = numbers[i + 1];\n        }\n    }\n\n    return std::make_tuple(smaller_num, larger_num);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float first = 0, second = 0;\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i];\n            second = numbers[i + 1];\n        }\n    }\n    return std::make_tuple(first, second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_diff_first = numbers[i];\n            min_diff_second = numbers[i + 1];\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = std::min(numbers[i], numbers[j]);\n                min_diff_second = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_diff_first = numbers[i];\n            min_diff_second = numbers[i + 1];\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_diff_first = numbers[i];\n            min_diff_second = numbers[i + 1];\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0.0f;\n    float min_diff_second = 0.0f;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(std::min(min_diff_first, min_diff_second),\n                           std::max(min_diff_first, min_diff_second));", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float smaller = 0.0f;\n    float larger = 0.0f;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            smaller = numbers[i];\n            larger = numbers[i + 1];\n        }\n    }\n\n    return std::make_tuple(smaller, larger);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        for (int j = i + 1; j < numbers.size(); j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i];\n            second = numbers[i + 1];\n        }\n    }\n\n    return std::make_tuple(first, second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_diff_first = numbers[i];\n            min_diff_second = numbers[i + 1];\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float smaller = 0.0f;\n    float larger = 0.0f;\n\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                smaller = std::min(numbers[i], numbers[j]);\n                larger = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return std::make_tuple(smaller, larger);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0.0f;\n    float min_diff_second = 0.0f;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(std::min(min_diff_first, min_diff_second), std::max(min_diff_first, min_diff_second));", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0.0f;\n    float min_diff_second = 0.0f;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0.0f;\n    float min_diff_second = 0.0f;\n    for (int i = 0; i < numbers.size() - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_diff_first = numbers[i];\n            min_diff_second = numbers[i + 1];\n        }\n    }\n    return std::make_tuple(min_diff_first, min_diff_second);", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n// other and return them in order (smaller number, larger number).\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.2f})))\n// (std::make_tuple(2.0f, 2.2f))\n// >>> find_closest_elements((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f, (float)2.0f})))\n// (std::make_tuple(2.0f, 2.0f))\nstd::tuple<float, float> find_closest_elements(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_diff_first = 0;\n    float min_diff_second = 0;\n\n    for (int i = 0; i < numbers.size() - 1; ++i) {\n        for (int j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                min_diff_first = numbers[i];\n                min_diff_second = numbers[j];\n            }\n        }\n    }\n\n    return std::make_tuple(min_diff_first, min_diff_second);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [&](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    for (float num : numbers) {\n        rescaled_numbers.push_back((num - min_val) / range);\n    }\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) { return (x - min_val) / range; });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers), [min_val, range](float x) {\n        return (x - min_val) / range;\n    });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [&](float x) { return (x - min_val) / range; });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [&](float x) { return (x - min_val) / range; });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [&](float x) { return (x - min_val) / range; });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) { return (x - min_val) / range; });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    for (float num : numbers) {\n        rescaled_numbers.push_back((num - min_val) / range);\n    }\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n  assert(numbers.size() >= 2);\n  float min_val = *std::min_element(numbers.begin(), numbers.end());\n  float max_val = *std::max_element(numbers.begin(), numbers.end());\n  float range = max_val - min_val;\n  std::vector<float> rescaled_numbers;\n  for (float num : numbers) {\n    rescaled_numbers.push_back((num - min_val) / range);\n  }\n  return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of at least two elements), apply a linear transform to that vector,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f, (float)4.0f, (float)5.0f})))\n// (std::vector<float>({(float)0.0f, (float)0.25f, (float)0.5f, (float)0.75f, (float)1.0f}))\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    assert(numbers.size() >= 2);\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    std::transform(numbers.begin(), numbers.end(), std::back_inserter(rescaled_numbers),\n                   [min_val, range](float x) {\n                       return (x - min_val) / range;\n                   });\n    return rescaled_numbers;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto& value : values) {\n        try {\n            long number = std::any_cast<long>(value);\n            result.push_back(number);\n        } catch (const std::bad_any_cast& e) {\n            // ignore non-integer values\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto &value : values) {\n        try {\n            long integer = std::any_cast<long>(value);\n            integers.push_back(integer);\n        } catch (const std::bad_any_cast &) {\n            // ignore non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto &value : values) {\n        try {\n            long integer = std::any_cast<long>(value);\n            result.push_back(integer);\n        } catch (const std::bad_any_cast &e) {\n            continue;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto value : values) {\n        try {\n            long integer = std::any_cast<long>(value);\n            integers.push_back(integer);\n        } catch (std::bad_any_cast &e) {\n            // Ignore non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto &value : values) {\n        try {\n            long number = std::any_cast<long>(value);\n            result.push_back(number);\n        } catch (const std::bad_any_cast &e) {\n            // ignore non-integer values\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto& value : values) {\n        try {\n            long num = std::any_cast<long>(value);\n            result.push_back(num);\n        } catch (const std::bad_any_cast& e) {\n            continue;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto& value : values) {\n        try {\n            long number = std::any_cast<long>(value);\n            result.push_back(number);\n        } catch (const std::bad_any_cast& e) {\n            // skip non-integer values\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto& value : values) {\n        if (value.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(value));\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto &value : values) {\n        try {\n            integers.push_back(std::any_cast<long>(value));\n        } catch (const std::bad_any_cast &) {\n            // ignore non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto& value : values) {\n        try {\n            long integer = std::any_cast<long>(value);\n            integers.push_back(integer);\n        } catch (const std::bad_any_cast& e) {\n            // ignore non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto &value : values) {\n        try {\n            result.push_back(std::any_cast<long>(value));\n        } catch (const std::bad_any_cast &) {\n            // ignore non-integer values\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto& value : values) {\n        try {\n            integers.push_back(std::any_cast<long>(value));\n        } catch (const std::bad_any_cast& e) {\n            // skip non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto& value : values) {\n        if (value.type() == typeid(long)) {\n            result.push_back(std::any_cast<long>(value));\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto& value : values) {\n        try {\n            long long_value = std::any_cast<long>(value);\n            result.push_back(long_value);\n        } catch (const std::bad_any_cast& e) {\n            // ignore non-integer values\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto& value : values) {\n        try {\n            long number = std::any_cast<long>(value);\n            result.push_back(number);\n        } catch (const std::bad_any_cast& e) {\n            // ignore non-integer values\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto &value : values) {\n        try {\n            long integer = std::any_cast<long>(value);\n            integers.push_back(integer);\n        } catch (const std::bad_any_cast &e) {\n            // ignore non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> result;\n    for (auto &value : values) {\n        try {\n            long number = std::any_cast<long>(value);\n            result.push_back(number);\n        } catch (const std::bad_any_cast &e) {\n            // ignore non-integer values\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto value : values) {\n        try {\n            integers.push_back(std::any_cast<long>(value));\n        } catch (const std::bad_any_cast& e) {\n            // skip non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto &value : values) {\n        try {\n            long integer = std::any_cast<long>(value);\n            integers.push_back(integer);\n        } catch (const std::bad_any_cast &e) {\n            // ignore non-integer values\n        }\n    }\n    return integers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter given vector of any cppthon values only for integers\n// >>> filter_integers((std::vector<std::any>({(std::string)\"a\", (std::string)3.14f, (std::string)5})))\n// (std::vector<long>({(long)5}))\n// >>> filter_integers((std::vector<std::any>({1, 2, 3, \"abc\", std::map<long,long>(), std::vector<long>()})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\nstd::vector<long> filter_integers(std::vector<std::any> values) {\n    std::vector<long> integers;\n    for (auto value : values) {\n        try {\n            integers.push_back(std::any_cast<long>(value));\n        } catch (const std::bad_any_cast& e) {\n            // ignore non-integer values\n        }\n    }\n    return integers;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n    return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return length of given string\n// >>> string_length((\"\"))\n// (0)\n// >>> string_length((\"abc\"))\n// (3)\nlong string_length(std::string string) {\n  return string.length();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    long largest_divisor = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest_divisor = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest_divisor = 1;\n    for (long i = 2; i <= n/2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    long largest_divisor = 1;\n    for (long i = 2; i <= n/2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest_divisor = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    long largest_divisor = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    long largest_divisor = 1;\n    for (long i = 2; i <= n/2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    long largest_divisor = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest_divisor = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest_divisor = 1;\n    for (long i = 2; i <= n/2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    long largest_divisor = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n    return largest_divisor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; i++) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given number n, find the largest number that divides n evenly, smaller than n\n// >>> largest_divisor((15))\n// (5)\nlong largest_divisor(long n) {\n    assert(n > 0);\n    long largest = 1;\n    for (long i = 2; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            largest = i;\n        }\n    }\n    return largest;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long factor = 2;\n    while (n > 1) {\n        while (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        }\n        factor++;\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    // Start from 2 and go up to sqrt(n)\n    for (long i = 2; i * i <= n; i++) {\n        // If n is divisible by i, then divide n by i and add i to factors\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is still greater than 1, then it is a prime number\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    // Start with the smallest prime number\n    long i = 2;\n    while (n > 1) {\n        // Check if i divides n\n        if (n % i == 0) {\n            // If it does, divide n by i and add i to factors\n            n /= i;\n            factors.push_back(i);\n        } else {\n            // If it doesn't, increment i\n            i++;\n        }\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long i = 2;\n    while (n > 1) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long d = 2;\n    while (n > 1) {\n        if (n % d == 0) {\n            factors.push_back(d);\n            n /= d;\n        } else {\n            d += 1;\n        }\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long d = 2;\n    while (n > 1) {\n        while (n % d == 0) {\n            factors.push_back(d);\n            n /= d;\n        }\n        d++;\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long factor = 2;\n    while (n > 1) {\n        while (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        }\n        factor++;\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long i = 2;\n    while (n > 1) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    // Start from smallest prime number\n    long i = 2;\n    while (n > 1) {\n        // If n is divisible by i\n        if (n % i == 0) {\n            // Divide n by i\n            n /= i;\n            // Add i to factors\n            factors.push_back(i);\n        } else {\n            // Increment i\n            i++;\n        }\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long i = 2;\n    while (n > 1) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    // Start from 2 and go up to sqrt(n)\n    for (long i = 2; i * i <= n; i++) {\n        // While i divides n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    long factor = 2;\n    while (n > 1) {\n        while (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        }\n        factor++;\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    for (long i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>> factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n// (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long n) {\n    std::vector<long> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_map<long, int> counts;\n  for (long num : numbers) {\n    if (counts[num] == 0) {\n      result.push_back(num);\n    }\n    counts[num]++;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::unordered_map<long, int> count;\n    std::vector<long> result;\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::unordered_map<long, int> counts;\n  std::vector<long> result;\n  for (long n : numbers) {\n    if (counts[n] == 0) {\n      result.push_back(n);\n    }\n    counts[n]++;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_map<long, int> count;\n  for (long number : numbers) {\n    count[number]++;\n    if (count[number] == 1) {\n      result.push_back(number);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long number : numbers) {\n        if (count[number] == 0) {\n            result.push_back(number);\n        }\n        count[number]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::unordered_map<long, int> count;\n  std::vector<long> result;\n  for (long num : numbers) {\n    count[num]++;\n  }\n  for (long num : numbers) {\n    if (count[num] == 1) {\n      result.push_back(num);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n    for (long num : numbers) {\n        count[num]++;\n        if (count[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::unordered_map<long, int> count;\n  std::vector<long> result;\n  for (long num : numbers) {\n    if (count[num] == 0) {\n      result.push_back(num);\n    }\n    count[num]++;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::unordered_map<long, int> counts;\n  std::vector<long> result;\n  for (long num : numbers) {\n    counts[num]++;\n  }\n  for (long num : numbers) {\n    if (counts[num] == 1) {\n      result.push_back(num);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> freq;\n\n    for (long num : numbers) {\n        freq[num]++;\n    }\n\n    for (long num : numbers) {\n        if (freq[num] == 1) {\n            result.push_back(num);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n  std::vector<long> result;\n  std::unordered_map<long, int> count;\n  for (long num : numbers) {\n    if (count[num] == 0) {\n      result.push_back(num);\n    }\n    count[num]++;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\n// >>> remove_duplicates((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)4})))\n// (std::vector<long>({(long)1, (long)3, (long)4}))\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n    std::vector<long> result;\n    std::unordered_map<long, int> count;\n\n    for (long num : numbers) {\n        if (count[num] == 0) {\n            result.push_back(num);\n        }\n        count[num]++;\n    }\n\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::string result;\n    for (char c : string) {\n        if (std::islower(c)) {\n            result += std::toupper(c);\n        } else if (std::isupper(c)) {\n            result += std::tolower(c);\n        } else {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::string result;\n    for (char c : string) {\n        if (std::islower(c)) {\n            result += std::toupper(c);\n        } else if (std::isupper(c)) {\n            result += std::tolower(c);\n        } else {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n        return std::islower(c) ? std::toupper(c) : std::tolower(c);\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c){\n        if(std::islower(c))\n            return std::toupper(c);\n        else if(std::isupper(c))\n            return std::tolower(c);\n        return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::string result;\n    for (char c : string) {\n        if (std::islower(c)) {\n            result += std::toupper(c);\n        } else if (std::isupper(c)) {\n            result += std::tolower(c);\n        } else {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c){\n        if (std::islower(c))\n            return std::toupper(c);\n        else if (std::isupper(c))\n            return std::tolower(c);\n        else\n            return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c){\n        if(std::islower(c))\n            return std::toupper(c);\n        else if(std::isupper(c))\n            return std::tolower(c);\n        else\n            return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c){ return std::tolower(c) ^ 32; });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c){\n        if(std::islower(c))\n            return std::toupper(c);\n        else if(std::isupper(c))\n            return std::tolower(c);\n        else\n            return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n        if (std::islower(c)) {\n            return std::toupper(c);\n        } else if (std::isupper(c)) {\n            return std::tolower(c);\n        }\n        return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n    if (std::islower(c))\n      return std::toupper(c);\n    else if (std::isupper(c))\n      return std::tolower(c);\n    else\n      return c;\n  });\n  return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c){\n        if (std::islower(c))\n            return std::toupper(c);\n        else if (std::isupper(c))\n            return std::tolower(c);\n        else\n            return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n        return std::islower(c) ? std::toupper(c) : std::tolower(c);\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c){\n        if(std::islower(c))\n            return std::toupper(c);\n        else if(std::isupper(c))\n            return std::tolower(c);\n        else\n            return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n        return std::islower(c) ? std::toupper(c) : std::tolower(c);\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n        return std::islower(c) ? std::toupper(c) : std::tolower(c);\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n  std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n    if (std::islower(c))\n      return std::toupper(c);\n    else if (std::isupper(c))\n      return std::tolower(c);\n    else\n      return c;\n  });\n  return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n        if (std::islower(c))\n            return std::toupper(c);\n        else if (std::isupper(c))\n            return std::tolower(c);\n        else\n            return c;\n    });\n    return string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::string result;\n    for (char c : string) {\n        if (std::islower(c)) {\n            result += std::toupper(c);\n        } else if (std::isupper(c)) {\n            result += std::tolower(c);\n        } else {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n// >>> flip_case((\"Hello\"))\n// (\"hELLO\")\nstd::string flip_case(std::string string) {\n    std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) {\n        if (std::islower(c)) {\n            return std::toupper(c);\n        } else if (std::isupper(c)) {\n            return std::tolower(c);\n        }\n        return c;\n    });\n    return string;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (auto& s : strings) {\n        result += s;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (auto &s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (auto& s : strings) {\n        result += s;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (std::string s : strings) {\n        result += s;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (auto &s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (std::string s : strings) {\n        result += s;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (auto &s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (auto &s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n  std::string result;\n  for (std::string s : strings) {\n    result += s;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Concatenate vector of strings into a single string\n// >>> concatenate((std::vector<std::string>()))\n// (\"\")\n// >>> concatenate((std::vector<std::string>({(std::string)\"a\", (std::string)\"b\", (std::string)\"c\"})))\n// (\"abc\")\nstd::string concatenate(std::vector<std::string> strings) {\n    std::string result;\n    for (std::string s : strings) {\n        result += s;\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto& str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      result.push_back(str);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> filtered;\n  for (std::string s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      filtered.push_back(s);\n    }\n  }\n  return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (auto& s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> result;\n  for (auto& s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      result.push_back(s);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered_strings;\n    for (auto& string : strings) {\n        if (string.substr(0, prefix.size()) == prefix) {\n            filtered_strings.push_back(string);\n        }\n    }\n    return filtered_strings;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (auto &str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            result.push_back(str);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> result;\n    for (std::string s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            result.push_back(s);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> filtered;\n  for (auto &str : strings) {\n    if (str.substr(0, prefix.size()) == prefix) {\n      filtered.push_back(str);\n    }\n  }\n  return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (auto &s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n  std::vector<std::string> filtered;\n  for (auto& s : strings) {\n    if (s.substr(0, prefix.size()) == prefix) {\n      filtered.push_back(s);\n    }\n  }\n  return filtered;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Filter an input vector of strings only for ones that start with a given prefix.\n// >>> filter_by_prefix((std::vector<std::string>()), (\"a\"))\n// (std::vector<std::string>())\n// >>> filter_by_prefix((std::vector<std::string>({(std::string)\"abc\", (std::string)\"bcd\", (std::string)\"cde\", (std::string)\"array\"})), (\"a\"))\n// (std::vector<std::string>({(std::string)\"abc\", (std::string)\"array\"}))\nstd::vector<std::string> filter_by_prefix(std::vector<std::string> strings, std::string prefix) {\n    std::vector<std::string> filtered;\n    for (auto& s : strings) {\n        if (s.substr(0, prefix.size()) == prefix) {\n            filtered.push_back(s);\n        }\n    }\n    return filtered;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> positive_numbers;\n    for (long num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> positive_numbers;\n  for (long i : l) {\n    if (i > 0) {\n      positive_numbers.push_back(i);\n    }\n  }\n  return positive_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n  std::vector<long> result;\n  for (long i : l) {\n    if (i > 0) {\n      result.push_back(i);\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> positive_numbers;\n    for (long num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        if (i > 0) {\n            result.push_back(i);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return only positive numbers in the vector.\n// >>> get_positive((std::vector<long>({(long)-1, (long)2, (long)-4, (long)5, (long)6})))\n// (std::vector<long>({(long)2, (long)5, (long)6}))\n// >>> get_positive((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (std::vector<long>({(long)5, (long)3, (long)2, (long)3, (long)9, (long)123, (long)1}))\nstd::vector<long> get_positive(std::vector<long> l) {\n    std::vector<long> positive_numbers;\n    for (long i : l) {\n        if (i > 0) {\n            positive_numbers.push_back(i);\n        }\n    }\n    return positive_numbers;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if a given number is prime, and false otherwise.\n// >>> is_prime((6))\n// (false)\n// >>> is_prime((101))\n// (true)\n// >>> is_prime((11))\n// (true)\n// >>> is_prime((13441))\n// (true)\n// >>> is_prime((61))\n// (true)\n// >>> is_prime((4))\n// (false)\n// >>> is_prime((1))\n// (false)\nbool is_prime(long n) {\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n\n    for (long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> sorted;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted.push_back(l[i]);\n        }\n    }\n    std::sort(sorted.begin(), sorted.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted[j];\n            j++;\n        }\n    }\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime(l);\n    std::vector<long> third_indicies;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_indicies.push_back(l[i]);\n        }\n    }\n    std::sort(third_indicies.begin(), third_indicies.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_indicies[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_indices;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_indices.push_back(i);\n        }\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    for (int i = 0; i < third_indices.size(); i++) {\n        l_prime[third_indices[i]] = l[third_indices[i]];\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime(l);\n    std::vector<long> third_indicies;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_indicies.push_back(i);\n        }\n    }\n    std::sort(third_indicies.begin(), third_indicies.end());\n    for (int i = 0; i < third_indicies.size(); i++) {\n        l_prime[third_indicies[i]] = l[third_indicies[i]];\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime(l);\n    std::vector<long> third_indicies;\n    for (long i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_indicies.push_back(i);\n        }\n    }\n    std::sort(third_indicies.begin(), third_indicies.end());\n    for (long i = 0; i < third_indicies.size(); i++) {\n        l_prime[third_indicies[i]] = l[third_indicies[i]];\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_indices;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_indices.push_back(i);\n        }\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    for (int i = 0; i < third_indices.size(); i++) {\n        l_prime[third_indices[i]] = l[third_indices[i]];\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> sorted;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted.push_back(l[i]);\n        }\n    }\n    std::sort(sorted.begin(), sorted.end());\n    for (int i = 0, j = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted[j++];\n        }\n    }\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> sorted;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            sorted.push_back(l[i]);\n        }\n    }\n    std::sort(sorted.begin(), sorted.end());\n    for (int i = 0, j = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = sorted[j++];\n        }\n    }\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime(l);\n    std::vector<long> third_indices;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_indices.push_back(i);\n        }\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    for (int i = 0; i < third_indices.size(); i++) {\n        l_prime[third_indices[i]] = l[third_indices[i]];\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime(l);\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime(l);\n    std::vector<long> third;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third.push_back(l[i]);\n        }\n    }\n    std::sort(third.begin(), third.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_third((std::vector<long>({(long)5, (long)6, (long)3, (long)4, (long)8, (long)9, (long)2})))\n// (std::vector<long>({(long)2, (long)6, (long)3, (long)4, (long)8, (long)9, (long)5}))\nstd::vector<long> sort_third(std::vector<long> l) {\n    std::vector<long> l_prime = l;\n    std::vector<long> third_elements;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    std::sort(third_elements.begin(), third_elements.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l_prime[i] = third_elements[j];\n            j++;\n        }\n    }\n    return l_prime;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  l.erase(std::unique(l.begin(), l.end()), l.end());\n  return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique elements in a vector\n// >>> unique((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)0, (long)2, (long)3, (long)5, (long)9, (long)123}))\nstd::vector<long> unique(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(), l.end()), l.end());\n    return l;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  assert(l.size() > 0);\n  long max = l[0];\n  for (long i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n  assert(l.size() > 0);\n  long max = l[0];\n  for (long i = 1; i < l.size(); i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max_val = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max_val = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    assert(l.size() > 0);\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n// (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\nlong max_element(std::vector<long> l) {\n    long max = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7') != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7') != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7', 0) != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7') != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7', 0) != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7') != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7', 0) != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7') != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7', 0) != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7', 0) != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7') != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).find('7') != std::string::npos;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n// >>> fizz_buzz((50))\n// (0)\n// >>> fizz_buzz((78))\n// (2)\n// >>> fizz_buzz((79))\n// (3)\nlong fizz_buzz(long n) {\n    long count = 0;\n    for (long i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            count += std::to_string(i).count('7');\n        }\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> result;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result.push_back(even_indices[j]);\n            j++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> result;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result.push_back(even_indices[j]);\n            j++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even;\n    for (int i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    std::sort(even.begin(), even.end());\n    std::vector<long> sorted;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted.push_back(even[j]);\n            j++;\n        } else {\n            sorted.push_back(l[i]);\n        }\n    }\n    return sorted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even;\n    for (int i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    std::sort(even.begin(), even.end());\n    std::vector<long> sorted;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted.push_back(even[j++]);\n        } else {\n            sorted.push_back(l[i]);\n        }\n    }\n    return sorted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indicies;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indicies.push_back(l[i]);\n    }\n    std::sort(even_indicies.begin(), even_indicies.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indicies[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even;\n    for (int i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    std::sort(even.begin(), even.end());\n    std::vector<long> sorted;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted.push_back(even[j]);\n            j++;\n        } else {\n            sorted.push_back(l[i]);\n        }\n    }\n    return sorted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indicies;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indicies.push_back(l[i]);\n    }\n    std::sort(even_indicies.begin(), even_indicies.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indicies[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even;\n    for (int i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    std::sort(even.begin(), even.end());\n    std::vector<long> result;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            result.push_back(even[j]);\n            j++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes a vector l and returns a vector l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\n// >>> sort_even((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)1, (long)2, (long)3}))\n// >>> sort_even((std::vector<long>({(long)5, (long)6, (long)3, (long)4})))\n// (std::vector<long>({(long)3, (long)6, (long)5, (long)4}))\nstd::vector<long> sort_even(std::vector<long> l) {\n    std::vector<long> even_indices;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    std::vector<long> sorted_l;\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            sorted_l.push_back(even_indices[j]);\n            j++;\n        } else {\n            sorted_l.push_back(l[i]);\n        }\n    }\n    return sorted_l;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib_prev = 0;\n    long fib_curr = 1;\n    long fib_next = fib_prev + fib_curr;\n    long count = 0;\n    while (count < n) {\n        fib_prev = fib_curr;\n        fib_curr = fib_next;\n        fib_next = fib_prev + fib_curr;\n        if (is_prime(fib_curr)) {\n            count += 1;\n        }\n    }\n    return fib_curr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 1;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long i = 2;\n    while (n > 0) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            n -= 1;\n        }\n        i += 1;\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 2;\n    long fib_prev = 1;\n    long count = 1;\n    while (count < n) {\n        fib_prev, fib = fib, fib_prev + fib;\n        if (is_prime(fib))\n            count++;\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 1;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0, fib_prev = 1, fib_next = 1;\n    long count = 0;\n    while (count < n) {\n        fib = fib_prev + fib_next;\n        fib_prev = fib_next;\n        fib_next = fib;\n        if (is_prime(fib)) {\n            count++;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 2;\n    long prev_fib = 1;\n    long count = 1;\n    while (count < n) {\n        long temp = fib;\n        fib += prev_fib;\n        prev_fib = temp;\n        if (is_prime(fib)) {\n            count++;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n    while(count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if(is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_next = 1;\n    long count = 0;\n    while (count < n) {\n        fib_next = fib_prev + fib;\n        fib_prev = fib;\n        fib = fib_next;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 1;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count++;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 1;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count++;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n    while (count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n        if (is_prime(fib)) {\n            count += 1;\n        }\n    }\n    return fib;", "#include<assert.h>\n#include<bits/stdc++.h>\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n// >>> prime_fib((1))\n// (2)\n// >>> prime_fib((2))\n// (3)\n// >>> prime_fib((3))\n// (5)\n// >>> prime_fib((4))\n// (13)\n// >>> prime_fib((5))\n// (89)\nlong prime_fib(long n) {\n    long fib = 0;\n    long fib_prev = 1;\n    long fib_prev_prev = 1;\n    long count = 0;\n\n    while(count < n) {\n        fib = fib_prev + fib_prev_prev;\n        fib_prev_prev = fib_prev;\n        fib_prev = fib;\n\n        if(is_prime(fib)) {\n            count += 1;\n        }\n    }\n\n    return fib;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            }\n            if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  for (size_t i = 0; i < l.size() - 2; i++) {\n    if (l[i] > 0) {\n      return false;\n    }\n    long target = -l[i];\n    size_t left = i + 1;\n    size_t right = l.size() - 1;\n    while (left < right) {\n      if (l[left] + l[right] == target) {\n        return true;\n      } else if (l[left] + l[right] < target) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            } else if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0)\n                return true;\n            else if (l[i] + l[j] + l[k] < 0)\n                j++;\n            else\n                k--;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            } else if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            } else if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  for (int i = 0; i < l.size() - 2; i++) {\n    int j = i + 1;\n    int k = l.size() - 1;\n    while (j < k) {\n      if (l[i] + l[j] + l[k] == 0) {\n        return true;\n      }\n      if (l[i] + l[j] + l[k] < 0) {\n        j++;\n      } else {\n        k--;\n      }\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  for (int i = 0; i < l.size() - 2; i++) {\n    int j = i + 1;\n    int k = l.size() - 1;\n    while (j < k) {\n      if (l[i] + l[j] + l[k] == 0)\n        return true;\n      else if (l[i] + l[j] + l[k] < 0)\n        j++;\n      else\n        k--;\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0)\n                return true;\n            else if (l[i] + l[j] + l[k] < 0)\n                j++;\n            else\n                k--;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            }\n            else if (l[i] + l[left] + l[right] < 0) {\n                left++;\n            }\n            else {\n                right--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            }\n            if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            }\n            if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            } else if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            }\n            if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n  std::sort(l.begin(), l.end());\n  for (int i = 0; i < l.size() - 2; i++) {\n    int j = i + 1;\n    int k = l.size() - 1;\n    while (j < k) {\n      if (l[i] + l[j] + l[k] == 0) {\n        return true;\n      } else if (l[i] + l[j] + l[k] < 0) {\n        j++;\n      } else {\n        k--;\n      }\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            } else if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            long sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            }\n            if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            } else if (l[i] + l[left] + l[right] < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; i++) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            if (l[i] + l[left] + l[right] == 0) {\n                return true;\n            } else if (l[i] + l[left] + l[right] < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are three distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> triples_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)9, (long)7})))\n// (true)\n// >>> triples_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool triples_sum_to_zero(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size(); i++) {\n        int j = i + 1;\n        int k = l.size() - 1;\n        while (j < k) {\n            if (l[i] + l[j] + l[k] == 0) {\n                return true;\n            } else if (l[i] + l[j] + l[k] < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i != j) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i != j) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i == j) {\n                continue;\n            }\n            long dist = abs(i - j);\n            if (dist == 0) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collision = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            collision += 1;\n        }\n    }\n    return collision;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    // The number of collisions is equal to the number of pairs of cars that\n    // are moving in opposite directions.  There are n cars moving left to right,\n    // and n cars moving right to left.  So there are n * n pairs of cars that\n    // are moving in opposite directions.\n    return n * n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i == j) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    // The number of collisions is equal to the number of pairs of cars\n    // that are moving in opposite directions and are at the same position.\n    // Since there are n cars moving left to right and n cars moving right to left,\n    // there are n*(n-1)/2 pairs of cars moving in opposite directions.\n    // Since there are an infinite number of positions, the probability of any\n    // two cars being at the same position is 1.  Therefore, the number of collisions\n    // is n*(n-1)/2.\n    return n*(n-1)/2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long count = 0;\n    for (long i = 1; i <= n; i++) {\n        count += i;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i != j) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    // The number of collisions is equal to the number of pairs of cars that\n    // are moving in opposite directions.  There are n cars moving left to right,\n    // and n cars moving right to left.  So there are n*n pairs of cars.\n    return n*n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long count = 0;\n    for (long i = 1; i <= n; i++) {\n        count += i;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i == j)\n                continue;\n            if (i + j == n - 1)\n                count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i == j) {\n                continue;\n            }\n            long dist = abs(i - j);\n            if (dist == 0) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i == j) {\n                continue;\n            }\n            long dist = abs(i - j);\n            if (dist == 0) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    // The number of collisions is equal to the number of cars that are moving\n    // left to right, multiplied by the number of cars that are moving right to left.\n    return n * n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    // The number of collisions is equal to the number of pairs of cars that\n    // are moving in opposite directions.  This is equal to n*(n-1)/2.\n    return n*(n-1)/2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    // The cars are infinitely far away from each other initially.\n    // We can simulate the cars moving by having two pointers,\n    // one moving from 0 to n, and the other moving from n to 0.\n    // When the pointers meet, we have a collision.\n    for (long left = 0, right = n; left < right; ++left, --right) {\n        // left and right meet at the midpoint\n        collisions += 1;\n    }\n    return collisions;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i == j) continue;\n            long distance = abs(i - j);\n            if (distance == 0) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i != j) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n// This function outputs the number of such collisions.\nlong car_race_collision(long n) {\n    long collisions = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            if (i != j) {\n                collisions++;\n            }\n        }\n    }\n    return collisions;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    for (long &i : l) {\n        i += 1;\n    }\n    return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> res;\n    for (long i : l) {\n        res.push_back(i + 1);\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  for (long &i : l) {\n    i++;\n  }\n  return l;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n    std::vector<long> result;\n    for (long i : l) {\n        result.push_back(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector with elements incremented by 1.\n// >>> incr_list((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)3, (long)4}))\n// >>> incr_list((std::vector<long>({(long)5, (long)3, (long)5, (long)2, (long)3, (long)3, (long)9, (long)0, (long)123})))\n// (std::vector<long>({(long)6, (long)4, (long)6, (long)3, (long)4, (long)4, (long)10, (long)1, (long)124}))\nstd::vector<long> incr_list(std::vector<long> l) {\n  std::vector<long> result;\n  for (long i : l) {\n    result.push_back(i + 1);\n  }\n  return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.count(-i))\n            return true;\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long x : l) {\n        if (s.find(-x) != s.end()) {\n            return true;\n        }\n        s.insert(x);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.count(-i)) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.count(-i)) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (auto i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.count(-i)) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.count(-i)) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long x : l) {\n        if (s.find(-x) != s.end()) {\n            return true;\n        }\n        s.insert(x);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long x : l) {\n        if (s.find(-x) != s.end()) {\n            return true;\n        }\n        s.insert(x);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.count(-i)) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (auto i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns true if there are two distinct elements in the vector that\n// sum to zero, and false otherwise.\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)5, (long)0})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)3, (long)-2, (long)1})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1, (long)2, (long)3, (long)7})))\n// (false)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)2, (long)4, (long)-5, (long)3, (long)5, (long)7})))\n// (true)\n// >>> pairs_sum_to_zero((std::vector<long>({(long)1})))\n// (false)\nbool pairs_sum_to_zero(std::vector<long> l) {\n    std::unordered_set<long> s;\n    for (long i : l) {\n        if (s.find(-i) != s.end()) {\n            return true;\n        }\n        s.insert(i);\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result;\n  while (x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string res;\n    while (x > 0) {\n        res = std::to_string(x % base) + res;\n        x /= base;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string res;\n    while (x > 0) {\n        res = std::to_string(x % base) + res;\n        x /= base;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string result;\n  while (x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string res;\n    while (x) {\n        res = std::to_string(x % base) + res;\n        x /= base;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  assert(base < 10);\n  std::string result;\n  while (x > 0) {\n    result = std::to_string(x % base) + result;\n    x /= base;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string res;\n    while (x > 0) {\n        res = std::to_string(x % base) + res;\n        x /= base;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n  std::string res;\n  while (x > 0) {\n    res = std::to_string(x % base) + res;\n    x /= base;\n  }\n  return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string res;\n    while (x > 0) {\n        res = std::to_string(x % base) + res;\n        x /= base;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\n// >>> change_base((8), (3))\n// (\"22\")\n// >>> change_base((8), (2))\n// (\"1000\")\n// >>> change_base((7), (2))\n// (\"111\")\nstd::string change_base(long x, long base) {\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return 0.5f * a * h;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return 0.5f * a * h;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return 0.5 * a * h;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return 0.5f * a * h;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return 0.5f * a * h;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return (float) (0.5 * a * h);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given length of a side and high return area for a triangle.\n// >>> triangle_area((5), (3))\n// (7.5f)\nfloat triangle_area(long a, long h) {\n    return 0.5f * a * h;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_1 = 0, fib4_2 = 0, fib4_3 = 2, fib4_4 = 0;\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_1 + fib4_2 + fib4_3 + fib4_4;\n        fib4_1 = fib4_2;\n        fib4_2 = fib4_3;\n        fib4_3 = fib4_4;\n        fib4_4 = fib4_n;\n    }\n\n    return fib4_4;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_minus_1 = 0;\n    long fib4_n_minus_2 = 0;\n    long fib4_n_minus_3 = 2;\n    long fib4_n_minus_4 = 0;\n\n    long fib4_n = 0;\n\n    for (long i = 4; i <= n; i++) {\n        fib4_n = fib4_n_minus_1 + fib4_n_minus_2 + fib4_n_minus_3 + fib4_n_minus_4;\n\n        fib4_n_minus_4 = fib4_n_minus_3;\n        fib4_n_minus_3 = fib4_n_minus_2;\n        fib4_n_minus_2 = fib4_n_minus_1;\n        fib4_n_minus_1 = fib4_n;\n    }\n\n    return fib4_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0, fib4_n_2 = 0, fib4_n_3 = 2, fib4_n_4 = 0;\n    long fib4_n = 0;\n\n    for (long i = 4; i <= n; i++) {\n        fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_1 = 0, fib4_2 = 0, fib4_3 = 2, fib4_4 = 0;\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_1 + fib4_2 + fib4_3 + fib4_4;\n        fib4_1 = fib4_2;\n        fib4_2 = fib4_3;\n        fib4_3 = fib4_4;\n        fib4_4 = fib4_n;\n    }\n\n    return fib4_4;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 2;\n    }\n    if (n == 3) {\n        return 0;\n    }\n\n    long a = 0, b = 0, c = 2, d = 0;\n    for (long i = 4; i <= n; i++) {\n        long sum = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = sum;\n    }\n\n    return d;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_minus_1 = 0;\n    long fib4_n_minus_2 = 0;\n    long fib4_n_minus_3 = 2;\n    long fib4_n_minus_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_minus_1 + fib4_n_minus_2 + fib4_n_minus_3 + fib4_n_minus_4;\n        fib4_n_minus_4 = fib4_n_minus_3;\n        fib4_n_minus_3 = fib4_n_minus_2;\n        fib4_n_minus_2 = fib4_n_minus_1;\n        fib4_n_minus_1 = fib4_n;\n    }\n\n    return fib4_n_minus_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long a = 0, b = 0, c = 2, d = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long sum = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = sum;\n    }\n\n    return d;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_minus_1 = 0;\n    long fib4_n_minus_2 = 0;\n    long fib4_n_minus_3 = 2;\n    long fib4_n_minus_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_minus_1 + fib4_n_minus_2 + fib4_n_minus_3 + fib4_n_minus_4;\n        fib4_n_minus_4 = fib4_n_minus_3;\n        fib4_n_minus_3 = fib4_n_minus_2;\n        fib4_n_minus_2 = fib4_n_minus_1;\n        fib4_n_minus_1 = fib4_n;\n    }\n\n    return fib4_n_minus_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long a = 0, b = 0, c = 2, d = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long sum = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = sum;\n    }\n\n    return d;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long a = 0, b = 0, c = 2, d = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long sum = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = sum;\n    }\n\n    return d;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_minus_1 = 0;\n    long fib4_n_minus_2 = 0;\n    long fib4_n_minus_3 = 2;\n    long fib4_n_minus_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_minus_1 + fib4_n_minus_2 + fib4_n_minus_3 + fib4_n_minus_4;\n        fib4_n_minus_4 = fib4_n_minus_3;\n        fib4_n_minus_3 = fib4_n_minus_2;\n        fib4_n_minus_2 = fib4_n_minus_1;\n        fib4_n_minus_1 = fib4_n;\n    }\n\n    return fib4_n_minus_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long fib4_n_1 = 0;\n    long fib4_n_2 = 0;\n    long fib4_n_3 = 2;\n    long fib4_n_4 = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long fib4_n = fib4_n_1 + fib4_n_2 + fib4_n_3 + fib4_n_4;\n        fib4_n_4 = fib4_n_3;\n        fib4_n_3 = fib4_n_2;\n        fib4_n_2 = fib4_n_1;\n        fib4_n_1 = fib4_n;\n    }\n\n    return fib4_n_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n// >>> fib4((5))\n// (4)\n// >>> fib4((6))\n// (8)\n// >>> fib4((7))\n// (14)\nlong fib4(long n) {\n    if (n <= 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 0;\n\n    long a = 0, b = 0, c = 2, d = 0;\n\n    for (long i = 4; i <= n; i++) {\n        long sum = a + b + c + d;\n        a = b;\n        b = c;\n        c = d;\n        d = sum;\n    }\n\n    return d;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n    return l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    } else {\n        return l[n / 2];\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n    return l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    } else {\n        return l[n / 2];\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n    return l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    }\n    return (float)l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    } else {\n        return (float)l[n / 2];\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n    return l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    }\n    return (float)l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n    return l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2] + l[n / 2 - 1]) / 2;\n    }\n    return (float)l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    }\n    return (float)l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0)\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    else\n        return l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0)\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    else\n        return (float)l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    } else {\n        return l[n / 2];\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    }\n    return (float)l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    } else {\n        return (float)l[n / 2];\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    }\n    return (float)l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    }\n    return l[n / 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0f)\nfloat median(std::vector<long> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2.0f;\n    } else {\n        return l[n / 2];\n    }"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int n = text.size();\n  for (int i = 0; i < n / 2; i++) {\n    if (text[i] != text[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int left = 0;\n  int right = text.length() - 1;\n  while (left < right) {\n    if (text[left] != text[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int left = 0;\n  int right = text.length() - 1;\n  while (left < right) {\n    if (text[left] != text[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int n = text.length();\n  for (int i = 0; i < n / 2; i++) {\n    if (text[i] != text[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int n = text.length();\n  for (int i = 0; i < n / 2; i++) {\n    if (text[i] != text[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int left = 0;\n  int right = text.length() - 1;\n  while (left < right) {\n    if (text[left] != text[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int left = 0;\n  int right = text.size() - 1;\n  while (left < right) {\n    if (text[left] != text[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int n = text.length();\n  for (int i = 0; i < n / 2; i++) {\n    if (text[i] != text[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  std::string reversed_text = text;\n  std::reverse(reversed_text.begin(), reversed_text.end());\n  return text == reversed_text;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int left = 0;\n  int right = text.length() - 1;\n  while (left < right) {\n    if (text[left] != text[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int left = 0;\n  int right = text.size() - 1;\n  while (left < right) {\n    if (text[left] != text[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int n = text.size();\n  for (int i = 0; i < n / 2; i++) {\n    if (text[i] != text[n - 1 - i]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n / 2; i++) {\n        if (text[i] != text[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int n = text.size();\n  for (int i = 0; i < n / 2; i++) {\n    if (text[i] != text[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Checks if given string is a palindrome\n// >>> is_palindrome((\"\"))\n// (true)\n// >>> is_palindrome((\"aba\"))\n// (true)\n// >>> is_palindrome((\"aaaaa\"))\n// (true)\n// >>> is_palindrome((\"zbcd\"))\n// (false)\nbool is_palindrome(std::string text) {\n  int n = text.length();\n  for (int i = 0; i < n / 2; i++) {\n    if (text[i] != text[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n = n / 2;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n = n / 2;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    long res = 1;\n    while (n) {\n        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 1;\n    long curr = 2;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            res = (res * curr) % p;\n        }\n        curr = (curr * curr) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 1;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    long res = 1;\n    while (n > 0) {\n        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    long res = 1;\n    while (n) {\n        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    long result = 1;\n    while (n > 0) {\n        if (n % 2 == 1) {\n            result = (result * 2) % p;\n        }\n        n = n / 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n & 1)\n            res = (res * 2) % p;\n        n >>= 1;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n// >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100), (101))\n// (1)\nlong modp(long n, long p) {\n    if (n == 0)\n        return 1;\n    long res = 2;\n    while (n > 0) {\n        if (n % 2 == 1)\n            res = (res * 2) % p;\n        n /= 2;\n        res = res % p;\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string result;\n  for (char c : text) {\n    if (vowels.find(c) == std::string::npos) {\n      result += c;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string result;\n  for (char c : text) {\n    if (vowels.find(c) == std::string::npos) {\n      result += c;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string result;\n  for (char c : text) {\n    if (vowels.find(c) == std::string::npos) {\n      result += c;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : text) {\n        if (vowels.find(c) == std::string::npos) {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string result;\n  for (char c : text) {\n    if (vowels.find(c) == std::string::npos) {\n      result += c;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string result;\n  for (char c : text) {\n    if (vowels.find(c) == std::string::npos) {\n      result += c;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// remove_vowels is a function that takes string and returns string without vowels.\n// >>> remove_vowels((\"\"))\n// (\"\")\n// >>> remove_vowels((\"abcdef\"))\n// (\"bcdf\")\n// >>> remove_vowels((\"aaaaa\"))\n// (\"\")\n// >>> remove_vowels((\"aaBAA\"))\n// (\"B\")\n// >>> remove_vowels((\"zbcd\"))\n// (\"zbcd\")\nstd::string remove_vowels(std::string text) {\n  std::string vowels = \"aeiouAEIOU\";\n  std::string result;\n  for (char c : text) {\n    if (vowels.find(c) == std::string::npos) {\n      result += c;\n    }\n  }\n  return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long i : l) {\n    if (i >= t) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long x : l) {\n    if (x >= t) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long x : l) {\n        if (x >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long i : l) {\n    if (i >= t) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i > t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n  for (long i : l) {\n    if (i >= t) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long n : l) {\n        if (n >= t) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true if all numbers in the vector l are below threshold t.\n// >>> below_threshold((std::vector<long>({(long)1, (long)2, (long)4, (long)10})), (100))\n// (true)\n// >>> below_threshold((std::vector<long>({(long)1, (long)20, (long)4, (long)10})), (5))\n// (false)\nbool below_threshold(std::vector<long> l, long t) {\n    for (long i : l) {\n        if (i >= t) {\n            return false;\n        }\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Add two numbers x and y\n// >>> add((2), (3))\n// (5)\n// >>> add((5), (7))\n// (12)\nlong add(long x, long y) {\n    return x + y;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n  std::sort(s0.begin(), s0.end());\n  std::sort(s1.begin(), s1.end());\n  return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Check if two words have the same characters.\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddeddabc\"))\n// (true)\n// >>> same_chars((\"abcd\"), (\"dddddddabc\"))\n// (true)\n// >>> same_chars((\"dddddddabc\"), (\"abcd\"))\n// (true)\n// >>> same_chars((\"eabcd\"), (\"dddddddabc\"))\n// (false)\n// >>> same_chars((\"abcd\"), (\"dddddddabce\"))\n// (false)\n// >>> same_chars((\"eabcdzzzz\"), (\"dddzzzzzzzddddabc\"))\n// (false)\nbool same_chars(std::string s0, std::string s1) {\n    std::sort(s0.begin(), s0.end());\n    std::sort(s1.begin(), s1.end());\n    return s0 == s1;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    else\n        return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return n-th Fibonacci number.\n// >>> fib((10))\n// (55)\n// >>> fib((1))\n// (1)\n// >>> fib((8))\n// (21)\nlong fib(long n) {\n    if (n <= 1)\n        return n;\n    long a = 0, b = 1;\n    for (long i = 2; i <= n; i++) {\n        long c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '<') {\n      stack.push(bracket);\n    } else {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '<') {\n      stack.push(bracket);\n    } else {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '<') {\n      stack.push(bracket);\n    } else {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '<') {\n      stack.push(bracket);\n    } else {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (char c : brackets) {\n        if (c == '<') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '<') {\n      stack.push(bracket);\n    } else {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"<\"))\n// (false)\n// >>> correct_bracketing((\"<>\"))\n// (true)\n// >>> correct_bracketing((\"<<><>>\"))\n// (true)\n// >>> correct_bracketing((\"><<>\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '<') {\n      stack.push(bracket);\n    } else {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (size_t i = 1; i < l.size() - 1; ++i) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (int i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = (l[0] <= l[1]);\n\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = (l[0] <= l[1]);\n\n    for (int i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = (l[0] <= l[1]);\n    for (size_t i = 1; i < l.size() - 1; ++i) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n\n    for (int i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n\n    for (size_t i = 1; i < l.size() - 1; ++i) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (int i = 0; i < l.size() - 1; i++) {\n        if (l[i] > l[i + 1]) {\n            increasing = false;\n        }\n        if (l[i] < l[i + 1]) {\n            decreasing = false;\n        }\n    }\n\n    return increasing || decreasing;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (size_t i = 1; i < l.size() - 1; ++i) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (int i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n    for (int i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = (l[0] <= l[1]);\n\n    for (size_t i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1)\n        return true;\n\n    bool increasing = l[0] <= l[1];\n\n    for (int i = 1; i < l.size() - 1; i++) {\n        if (increasing && l[i] > l[i + 1])\n            return false;\n        if (!increasing && l[i] < l[i + 1])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1, (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1, (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4, (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l) {\n    if (l.size() <= 1) {\n        return true;\n    }\n\n    bool increasing = l[0] <= l[1];\n    for (size_t i = 1; i < l.size() - 1; ++i) {\n        if (increasing && l[i] > l[i + 1]) {\n            return false;\n        }\n        if (!increasing && l[i] < l[i + 1]) {\n            return false;\n        }\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::vector<long> result;\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> result;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n  std::vector<long> result;\n  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common elements for two vectors.\n// >>> common((std::vector<long>({(long)1, (long)4, (long)3, (long)34, (long)653, (long)2, (long)5})), (std::vector<long>({(long)5, (long)7, (long)1, (long)5, (long)9, (long)653, (long)121})))\n// (std::vector<long>({(long)1, (long)5, (long)653}))\n// >>> common((std::vector<long>({(long)5, (long)3, (long)2, (long)8})), (std::vector<long>({(long)3, (long)2})))\n// (std::vector<long>({(long)2, (long)3}))\nstd::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n    std::vector<long> result;\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0)\n        n /= 2;\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0)\n            n /= i;\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0)\n        n /= 2;\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0)\n            n /= i;\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    long largest = 2;\n    while (n % 2 == 0) {\n        largest = 2;\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    if (n > 2)\n        largest = n;\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long largest = 0;\n    while (n % 2 == 0) {\n        largest = 2;\n        n >>= 1;\n    }\n\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    if (n > 2)\n        largest = n;\n\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long largest = 0;\n    while (n % 2 == 0) {\n        largest = 2;\n        n >>= 1;\n    }\n\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    if (n > 2)\n        largest = n;\n\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long largest_factor = 0;\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n /= 2;\n    }\n    for (long i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n    if (n > 2)\n        largest_factor = n;\n    return largest_factor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long largest = 0;\n    while (n % 2 == 0) {\n        largest = 2;\n        n >>= 1;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n    if (n > 2)\n        largest = n;\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long largest = 0;\n    while (n % 2 == 0) {\n        largest = 2;\n        n >>= 1;\n    }\n\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest = i;\n            n /= i;\n        }\n    }\n\n    if (n > 2)\n        largest = n;\n\n    return largest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0)\n        n /= 2;\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0)\n            n /= i;\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n  assert(n > 1);\n  while (n % 2 == 0)\n    n /= 2;\n  for (long i = 3; i * i <= n; i += 2) {\n    while (n % i == 0)\n      n /= i;\n  }\n  return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0)\n        n /= 2;\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0)\n            n /= i;\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    long largest_factor = 1;\n    while (n % 2 == 0) {\n        largest_factor = 2;\n        n >>= 1;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            largest_factor = i;\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        largest_factor = n;\n    }\n    return largest_factor;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n// (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long n) {\n    assert(n > 1);\n    while (n % 2 == 0) {\n        n /= 2;\n    }\n    for (long i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            n /= i;\n        }\n    }\n    return n;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n*(n+1))/2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n  return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    long sum = 0;\n    for (long i = 1; i <= n; i++) {\n        sum += i;\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// sum_to_n is a function that sums numbers from 1 to n.\n// >>> sum_to_n((30))\n// (465)\n// >>> sum_to_n((100))\n// (5050)\n// >>> sum_to_n((5))\n// (15)\n// >>> sum_to_n((10))\n// (55)\n// >>> sum_to_n((1))\n// (1)\nlong sum_to_n(long n) {\n    return (n * (n + 1)) / 2;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '(') {\n      stack.push(bracket);\n    } else if (bracket == ')') {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '(') {\n      stack.push(bracket);\n    } else if (bracket == ')') {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n  std::stack<char> stack;\n  for (char bracket : brackets) {\n    if (bracket == '(') {\n      stack.push(bracket);\n    } else if (bracket == ')') {\n      if (stack.empty()) {\n        return false;\n      }\n      stack.pop();\n    }\n  }\n  return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else if (c == ')') {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of \"(\" and \")\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing((\"(\"))\n// (false)\n// >>> correct_bracketing((\"()\"))\n// (true)\n// >>> correct_bracketing((\"(()())\"))\n// (true)\n// >>> correct_bracketing((\")(()\"))\n// (false)\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            stack.push(bracket);\n        } else if (bracket == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); ++i) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> derivative;\n    for (int i = 1; i < xs.size(); i++) {\n        derivative.push_back(xs[i] * i);\n    }\n    return derivative;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> dxs;\n    for (int i = 1; i < xs.size(); i++) {\n        dxs.push_back(xs[i] * i);\n    }\n    return dxs;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); ++i) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> result;\n  for (size_t i = 1; i < xs.size(); ++i) {\n    result.push_back(xs[i] * i);\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); i++) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n  std::vector<long> ret;\n  for (int i = 1; i < xs.size(); i++) {\n    ret.push_back(xs[i] * i);\n  }\n  return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); i++) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); i++) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> derivative;\n    for (int i = 1; i < xs.size(); i++) {\n        derivative.push_back(xs[i] * i);\n    }\n    return derivative;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (size_t i = 1; i < xs.size(); i++) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> result;\n    for (int i = 1; i < xs.size(); i++) {\n        result.push_back(xs[i] * i);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); i++) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); i++) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;", "#include<assert.h>\n#include<bits/stdc++.h>\n// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>> derivative((std::vector<long>({(long)3, (long)1, (long)2, (long)4, (long)5})))\n// (std::vector<long>({(long)1, (long)4, (long)12, (long)20}))\n// >>> derivative((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)6}))\nstd::vector<long> derivative(std::vector<long> xs) {\n    std::vector<long> ret;\n    for (int i = 1; i < xs.size(); i++) {\n        ret.push_back(xs[i] * i);\n    }\n    return ret;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_2 = 0;\n    long fibfib_n_1 = 1;\n    long fibfib_n = 0;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_1;\n        fibfib_n_2 = fibfib_n_1;\n        fibfib_n_1 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_minus_1 = 0;\n    long fibfib_n_minus_2 = 0;\n    long fibfib_n_minus_3 = 1;\n\n    for (long i = 3; i <= n; i++) {\n        long fibfib_n = fibfib_n_minus_1 + fibfib_n_minus_2 + fibfib_n_minus_3;\n        fibfib_n_minus_3 = fibfib_n_minus_2;\n        fibfib_n_minus_2 = fibfib_n_minus_1;\n        fibfib_n_minus_1 = fibfib_n;\n    }\n\n    return fibfib_n_minus_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n\n    long fibfib_n_1 = 0;\n    long fibfib_n_2 = 0;\n    long fibfib_n_3 = 1;\n    long fibfib_n = 0;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_3;\n        fibfib_n_1 = fibfib_n_2;\n        fibfib_n_2 = fibfib_n_3;\n        fibfib_n_3 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_minus_1 = 0;\n    long fibfib_n_minus_2 = 0;\n    long fibfib_n_minus_3 = 1;\n\n    for (long i = 3; i <= n; i++) {\n        long fibfib_n = fibfib_n_minus_1 + fibfib_n_minus_2 + fibfib_n_minus_3;\n        fibfib_n_minus_3 = fibfib_n_minus_2;\n        fibfib_n_minus_2 = fibfib_n_minus_1;\n        fibfib_n_minus_1 = fibfib_n;\n    }\n\n    return fibfib_n_minus_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n\n    long fibfib_n_minus_1 = 0;\n    long fibfib_n_minus_2 = 0;\n    long fibfib_n_minus_3 = 1;\n    long fibfib_n = 0;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_minus_1 + fibfib_n_minus_2 + fibfib_n_minus_3;\n        fibfib_n_minus_3 = fibfib_n_minus_2;\n        fibfib_n_minus_2 = fibfib_n_minus_1;\n        fibfib_n_minus_1 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long a = 0, b = 0, c = 1;\n\n    for (long i = 3; i <= n; i++) {\n        long d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n\n    return c;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_minus_1 = 0;\n    long fibfib_n_minus_2 = 0;\n    long fibfib_n_minus_3 = 1;\n    long fibfib_n = 0;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_minus_1 + fibfib_n_minus_2 + fibfib_n_minus_3;\n        fibfib_n_minus_3 = fibfib_n_minus_2;\n        fibfib_n_minus_2 = fibfib_n_minus_1;\n        fibfib_n_minus_1 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n\n    long fibfib_n_minus_1 = 0;\n    long fibfib_n_minus_2 = 0;\n    long fibfib_n_minus_3 = 1;\n\n    for (long i = 3; i <= n; i++) {\n        long fibfib_n = fibfib_n_minus_1 + fibfib_n_minus_2 + fibfib_n_minus_3;\n        fibfib_n_minus_3 = fibfib_n_minus_2;\n        fibfib_n_minus_2 = fibfib_n_minus_1;\n        fibfib_n_minus_1 = fibfib_n;\n    }\n\n    return fibfib_n_minus_1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_2 = 0;\n    long fibfib_n_1 = 1;\n    long fibfib_n = 1;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_1;\n        fibfib_n_2 = fibfib_n_1;\n        fibfib_n_1 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2) {\n        return n == 2 ? 1 : 0;\n    }\n\n    long fibfib_n_1 = 0;\n    long fibfib_n_2 = 0;\n    long fibfib_n_3 = 1;\n\n    for (long i = 3; i <= n; ++i) {\n        long fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_3;\n        fibfib_n_1 = fibfib_n_2;\n        fibfib_n_2 = fibfib_n_3;\n        fibfib_n_3 = fibfib_n;\n    }\n\n    return fibfib_n_3;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_1 = 0;\n    long fibfib_n_2 = 0;\n    long fibfib_n_3 = 1;\n\n    for (long i = 3; i <= n; ++i) {\n        long fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_3;\n        fibfib_n_1 = fibfib_n_2;\n        fibfib_n_2 = fibfib_n_3;\n        fibfib_n_3 = fibfib_n;\n    }\n\n    return fibfib_n_3;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 2;\n\n    long fibfib_2 = 0;\n    long fibfib_1 = 0;\n    long fibfib_0 = 1;\n\n    for (long i = 3; i <= n; i++) {\n        long fibfib_i = fibfib_0 + fibfib_1 + fibfib_2;\n        fibfib_2 = fibfib_1;\n        fibfib_1 = fibfib_0;\n        fibfib_0 = fibfib_i;\n    }\n\n    return fibfib_0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n\n    long fibfib_n_1 = 0;\n    long fibfib_n_2 = 0;\n    long fibfib_n_3 = 1;\n    long fibfib_n = 0;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_3;\n        fibfib_n_1 = fibfib_n_2;\n        fibfib_n_2 = fibfib_n_3;\n        fibfib_n_3 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long a = 0, b = 0, c = 1;\n    for (long i = 3; i <= n; i++) {\n        long d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n    return c;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2) {\n        return n == 2 ? 1 : 0;\n    }\n\n    long fibfib_0 = 0;\n    long fibfib_1 = 0;\n    long fibfib_2 = 1;\n\n    for (long i = 3; i <= n; i++) {\n        long fibfib_n = fibfib_0 + fibfib_1 + fibfib_2;\n        fibfib_0 = fibfib_1;\n        fibfib_1 = fibfib_2;\n        fibfib_2 = fibfib_n;\n    }\n\n    return fibfib_2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_2 = 0;\n    long fibfib_n_1 = 1;\n    long fibfib_n = 1;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_1;\n        fibfib_n_2 = fibfib_n_1;\n        fibfib_n_1 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 0 ? 0 : 1;\n\n    long fibfib_n_2 = 0;\n    long fibfib_n_1 = 1;\n    long fibfib_n = 1;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_1;\n        fibfib_n_2 = fibfib_n_1;\n        fibfib_n_1 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n <= 2)\n        return n == 2;\n\n    long a = 0, b = 0, c = 1;\n\n    for (long i = 3; i <= n; i++) {\n        long d = a + b + c;\n        a = b;\n        b = c;\n        c = d;\n    }\n\n    return c;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n\n    long fibfib_n_minus_1 = 0;\n    long fibfib_n_minus_2 = 0;\n    long fibfib_n_minus_3 = 1;\n    long fibfib_n = 0;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_minus_1 + fibfib_n_minus_2 + fibfib_n_minus_3;\n        fibfib_n_minus_3 = fibfib_n_minus_2;\n        fibfib_n_minus_2 = fibfib_n_minus_1;\n        fibfib_n_minus_1 = fibfib_n;\n    }\n\n    return fibfib_n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fibfib(0) == 0\n// fibfib(1) == 0\n// fibfib(2) == 1\n// fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n// Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n// >>> fibfib((1))\n// (0)\n// >>> fibfib((5))\n// (4)\n// >>> fibfib((8))\n// (24)\nlong fibfib(long n) {\n    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 1;\n\n    long fibfib_n_1 = 0;\n    long fibfib_n_2 = 0;\n    long fibfib_n_3 = 1;\n    long fibfib_n = 0;\n\n    for (long i = 3; i <= n; i++) {\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_3;\n        fibfib_n_1 = fibfib_n_2;\n        fibfib_n_2 = fibfib_n_3;\n        fibfib_n_3 = fibfib_n;\n    }\n\n    return fibfib_n;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    if (s[s.size() - 1] == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    if (s[s.size() - 1] == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n\n    if (s[s.length() - 1] == 'y') {\n        count++;\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n\n    if (s[s.length() - 1] == 'y') {\n        count++;\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n\n    if (s[s.length() - 1] == 'y') {\n        count++;\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    if (s[s.length() - 1] == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n    if (s[s.size() - 1] == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n  std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n  long count = 0;\n  for (char c : s) {\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      count++;\n    }\n  }\n  if (s.back() == 'y') {\n    count++;\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n\n    for (char c : s) {\n        if (vowels.find(tolower(c)) != vowels.end()) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\n// Example:\n// >>> vowels_count((\"abcde\"))\n// (2)\n// >>> vowels_count((\"ACEDY\"))\n// (3)\nlong vowels_count(std::string s) {\n    long count = 0;\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    if (s.back() == 'y') {\n        count++;\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string str = std::to_string(x);\n    long n = str.size();\n    if (shift > n) {\n        std::reverse(str.begin(), str.end());\n        return str;\n    }\n    std::rotate(str.begin(), str.begin() + n - shift, str.end());\n    return str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string str = std::to_string(x);\n    long n = str.size();\n    if (shift > n) {\n        std::reverse(str.begin(), str.end());\n        return str;\n    }\n    std::rotate(str.begin(), str.begin() + (n - shift), str.end());\n    return str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.length()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + (s.length() - shift), s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string str = std::to_string(x);\n    long n = str.length();\n    if (shift > n) {\n        std::reverse(str.begin(), str.end());\n        return str;\n    }\n    std::rotate(str.begin(), str.begin() + n - shift, str.end());\n    return str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    long n = s.length();\n    if (shift > n) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + (n - shift), s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    long n = s.length();\n    if (shift > n) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + n - shift, s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.length()) {\n        return std::string(s.rbegin(), s.rend());\n    }\n    return s.substr(s.length() - shift) + s.substr(0, s.length() - shift);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    long n = s.size();\n    if (shift > n) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + n - shift, s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.size()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    return s.substr(s.size() - shift) + s.substr(0, s.size() - shift);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.size()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + s.size() - shift, s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    long n = s.size();\n    if (shift > n) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + n - shift, s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    long n = s.length();\n    if (shift > n) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + (n - shift), s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.length()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + s.length() - shift, s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string str = std::to_string(x);\n    long n = str.length();\n    if (shift > n) {\n        std::reverse(str.begin(), str.end());\n        return str;\n    }\n    std::rotate(str.begin(), str.begin() + n - shift, str.end());\n    return str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.size()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + (s.size() - shift), s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.size()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + s.size() - shift, s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.size()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + s.size() - shift, s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.size()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + (s.size() - shift), s.end());\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string str = std::to_string(x);\n    long n = str.length();\n\n    if (shift > n) {\n        std::reverse(str.begin(), str.end());\n        return str;\n    }\n\n    std::rotate(str.begin(), str.begin() + (n - shift), str.end());\n    return str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12), (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string circular_shift(long x, long shift) {\n    std::string s = std::to_string(x);\n    if (shift > s.length()) {\n        std::reverse(s.begin(), s.end());\n        return s;\n    }\n    std::rotate(s.begin(), s.begin() + (s.length() - shift), s.end());\n    return s;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += c;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += c;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n  long sum = 0;\n  for (char c : s) {\n    if (isupper(c)) {\n      sum += c;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\n// Examples:\n// >>> digitSum((\"\"))\n// (0)\n// >>> digitSum((\"abAB\"))\n// (131)\n// >>> digitSum((\"abcCd\"))\n// (67)\n// >>> digitSum((\"helloE\"))\n// (69)\n// >>> digitSum((\"woArBld\"))\n// (131)\n// >>> digitSum((\"aAaaaXa\"))\n// (153)\nlong digitSum(std::string s) {\n    long sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(5);\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n    long mangoes = 0;\n\n    std::stringstream ss(s);\n\n    ss >> apples;\n    ss >> std::string();\n    ss >> oranges;\n\n    mangoes = n - apples - oranges;\n\n    return mangoes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n\n    std::stringstream ss(s);\n    std::string temp;\n\n    while (ss >> temp) {\n        if (temp == \"apples\") {\n            ss >> apples;\n        }\n        if (temp == \"oranges\") {\n            ss >> oranges;\n        }\n    }\n\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(4);\n    ss >> oranges;\n\n    assert(apples + oranges <= n);\n\n    return n - (apples + oranges);", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n    long mangoes = 0;\n\n    // extract apples and oranges from string\n    std::stringstream ss(s);\n    std::string temp;\n    while (ss >> temp) {\n        if (temp == \"apples\") {\n            ss >> apples;\n        }\n        if (temp == \"oranges\") {\n            ss >> oranges;\n        }\n    }\n\n    // calculate mangoes\n    mangoes = n - apples - oranges;\n\n    return mangoes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    // your code here\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples, oranges;\n    std::stringstream ss(s);\n    ss >> apples >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(10, ' ');\n    ss >> oranges;\n\n    assert(apples + oranges <= n);\n\n    return n - (apples + oranges);", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(4);\n    ss >> oranges;\n\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss >> oranges;\n\n    assert(apples + oranges <= n);\n\n    return n - (apples + oranges);", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0;\n    long oranges = 0;\n\n    std::stringstream ss(s);\n    std::string temp;\n\n    while (std::getline(ss, temp, ' ')) {\n        if (temp == \"apples\") {\n            std::getline(ss, temp, ' ');\n            apples = std::stol(temp);\n        }\n        if (temp == \"oranges\") {\n            std::getline(ss, temp, ' ');\n            oranges = std::stol(temp);\n        }\n    }\n\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(5);\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples, oranges;\n    std::stringstream ss(s);\n    ss >> apples >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    // your code here\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(10, ' ');\n    ss >> oranges;\n    return n - apples - oranges;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this task, you will be given a string that represents a number of apples and oranges \n// that are distributed in a basket of fruit this basket contains \n// apples, oranges, and mango fruits. Given the string that represents the total number of \n// the oranges and apples and an integer that represent the total number of the fruits \n// in the basket return the number of the mango fruits in the basket.\n// for examble:\n// >>> fruit_distribution((\"5 apples and 6 oranges\"), (19))\n// (8)\n// >>> fruit_distribution((\"0 apples and 1 oranges\"), (3))\n// (2)\n// >>> fruit_distribution((\"2 apples and 3 oranges\"), (100))\n// (95)\n// >>> fruit_distribution((\"100 apples and 1 oranges\"), (120))\n// (19)\nlong fruit_distribution(std::string s, long n) {\n    long apples = 0, oranges = 0;\n    std::stringstream ss(s);\n    ss >> apples;\n    ss.ignore(5);\n    ss >> oranges;\n\n    assert(apples + oranges <= n);\n\n    return n - apples - oranges;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    if (arr.empty())\n        return {};\n\n    long smallest_even = std::numeric_limits<long>::max();\n    long smallest_even_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n\n    if (smallest_even_index == -1)\n        return {};\n\n    return {smallest_even, smallest_even_index};", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    if(arr.empty())\n        return {};\n    long min_val = INT_MAX;\n    long min_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n            min_index = i;\n        }\n    }\n    if(min_index == -1)\n        return {};\n    return {min_val, min_index};", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> res;\n    long min_val = LONG_MAX;\n    long min_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n            min_index = i;\n        }\n    }\n    if(min_index != -1) {\n        res.push_back(min_val);\n        res.push_back(min_index);\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> res;\n    long min_val = INT_MAX;\n    long min_index = -1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n            min_index = i;\n        }\n    }\n    if (min_index != -1) {\n        res.push_back(min_val);\n        res.push_back(min_index);\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long min_even = LONG_MAX;\n    long min_even_index = -1;\n\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_even_index = i;\n        }\n    }\n\n    if(min_even_index != -1) {\n        result.push_back(min_even);\n        result.push_back(min_even_index);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long min_even = LONG_MAX;\n    long min_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index != -1) {\n        result.push_back(min_even);\n        result.push_back(min_index);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    if (arr.empty())\n        return {};\n\n    long smallest_even = std::numeric_limits<long>::max();\n    int smallest_even_index = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n\n    if (smallest_even_index == -1)\n        return {};\n\n    return {smallest_even, smallest_even_index};", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long smallest_even = LONG_MAX;\n    long smallest_even_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n\n    if (smallest_even_index != -1) {\n        result.push_back(smallest_even);\n        result.push_back(smallest_even_index);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    if(arr.empty())\n        return result;\n    long min_even = INT_MAX;\n    long min_even_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_even_index = i;\n        }\n    }\n    if(min_even_index == -1)\n        return result;\n    result.push_back(min_even);\n    result.push_back(min_even_index);\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long smallest_even = LONG_MAX;\n    long smallest_even_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n\n    if (smallest_even_index != -1) {\n        result.push_back(smallest_even);\n        result.push_back(smallest_even_index);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long smallest_even = 10001;\n    long smallest_even_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n    if(smallest_even_index != -1) {\n        result.push_back(smallest_even);\n        result.push_back(smallest_even_index);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    if (arr.empty())\n        return {};\n\n    long smallest_even = std::numeric_limits<long>::max();\n    long smallest_even_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n\n    if (smallest_even_index == -1)\n        return {};\n\n    return {smallest_even, smallest_even_index};", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long min_even = LONG_MAX;\n    long min_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n    if(min_index != -1) {\n        result.push_back(min_even);\n        result.push_back(min_index);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> res;\n    long min_val = INT_MAX;\n    long min_index = -1;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n            min_index = i;\n        }\n    }\n    if (min_index != -1) {\n        res.push_back(min_val);\n        res.push_back(min_index);\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    long smallest = LONG_MAX;\n    long smallest_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < smallest) {\n            smallest = arr[i];\n            smallest_index = i;\n        }\n    }\n    if(smallest_index == -1)\n        return {};\n    return {smallest, smallest_index};", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    if (arr.empty())\n        return {};\n\n    long smallest_even = std::numeric_limits<long>::max();\n    long smallest_even_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n\n    if (smallest_even_index == -1)\n        return {};\n\n    return {smallest_even, smallest_even_index};", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long min_even = LONG_MAX;\n    long min_even_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_even_index = i;\n        }\n    }\n\n    if (min_even_index != -1) {\n        result.push_back(min_even);\n        result.push_back(min_even_index);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long min_even = LONG_MAX;\n    long min_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n    if(min_index != -1) {\n        result.push_back(min_even);\n        result.push_back(min_index);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> res;\n    long min_val = LONG_MAX;\n    long min_index = -1;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n            min_index = i;\n        }\n    }\n    if(min_index != -1) {\n        res.push_back(min_val);\n        res.push_back(min_index);\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given a vector representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a vector, [ smalest_value, its index ],\n// If there are no even values or the given vector is empty, return [].\n// Example 1:\n// >>> pluck((std::vector<long>({(long)4, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck((std::vector<long>({(long)1, (long)2, (long)3})))\n// (std::vector<long>({(long)2, (long)1}))\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck((std::vector<long>()))\n// (std::vector<long>())\n// Example 4:\n// >>> pluck((std::vector<long>({(long)5, (long)0, (long)3, (long)0, (long)4, (long)2})))\n// (std::vector<long>({(long)0, (long)1}))\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long> arr) {\n    std::vector<long> result;\n    long smallest_even = LONG_MAX;\n    long smallest_even_index = -1;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_even_index = i;\n        }\n    }\n\n    if (smallest_even_index != -1) {\n        result.push_back(smallest_even);\n        result.push_back(smallest_even_index);\n    }\n\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long num : lst) {\n        freq[num]++;\n    }\n\n    for (long num : lst) {\n        if (freq[num] >= num && num > 0) {\n            return num;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    long max_val = -1;\n    for (long i : lst) {\n        if (freq[i] >= i && i > max_val) {\n            max_val = i;\n        }\n    }\n\n    return max_val;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    long max_freq = 0;\n    long max_val = -1;\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > max_freq) {\n            max_freq = freq[i];\n            max_val = i;\n        }\n    }\n\n    return max_val;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    long ans = -1;\n    for (long i : lst) {\n        if (freq[i] >= i && i > ans) {\n            ans = i;\n        }\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long num : lst) {\n        freq[num]++;\n    }\n\n    for (long num : lst) {\n        if (freq[num] >= num && num > 0) {\n            return num;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    long result = -1;\n    for (auto& p : freq) {\n        if (p.first > 0 && p.second >= p.first && p.first > result) {\n            result = p.first;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n    long max_freq = 0;\n    long max_val = -1;\n    for (auto i : freq) {\n        if (i.first > 0 && i.second >= i.first && i.second > max_freq) {\n            max_freq = i.second;\n            max_val = i.first;\n        }\n    }\n    return max_val;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::unordered_map<long, long> freq;\n    for (long i : lst) {\n        freq[i]++;\n    }\n\n    for (long i : lst) {\n        if (freq[i] >= i && i > 0) {\n            return i;\n        }\n    }\n\n    return -1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than \n// zero, and has a frequency greater than or equal to the value of the integer itself. \n// The frequency of an integer is the number of times it appears in the vector.\n// If no such a value exist, return -1.\n// Examples:\n// >>> search((std::vector<long>({(long)4, (long)1, (long)2, (long)2, (long)3, (long)1})))\n// (2)\n// >>> search((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)3, (long)4, (long)4, (long)4})))\n// (3)\n// >>> search((std::vector<long>({(long)5, (long)5, (long)4, (long)4, (long)4})))\n// (-1)\nlong search(std::vector<long> lst) {\n    std::map<long, long> freq;\n    for (auto i : lst) {\n        freq[i]++;\n    }\n\n    for (auto i : lst) {\n        if (freq[i] >= i && i > 0)\n            return i;\n    }\n\n    return -1;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.size() == 0)\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n\n    while (lst.size() > 0) {\n        result.push_back(lst[0]);\n        lst.erase(lst.begin());\n\n        if (lst.size() > 0) {\n            result.push_back(lst[lst.size() - 1]);\n            lst.pop_back();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.size() == 0) {\n        return result;\n    }\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.size() == 0)\n        return result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> res;\n    if (lst.size() == 0)\n        return res;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        res.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            res.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  if (lst.size() == 0)\n    return result;\n  std::sort(lst.begin(), lst.end());\n  while (lst.size() > 0) {\n    result.push_back(lst[0]);\n    lst.erase(lst.begin());\n    if (lst.size() > 0) {\n      result.push_back(lst[lst.size() - 1]);\n      lst.pop_back();\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty()) {\n        return result;\n    }\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  if (lst.empty())\n    return result;\n  std::sort(lst.begin(), lst.end());\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.size() == 0)\n        return result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst[0]);\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst[lst.size() - 1]);\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n\n    std::sort(lst.begin(), lst.end());\n\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.size() == 0)\n        return result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n    std::vector<long> result;\n    if (lst.empty())\n        return result;\n    std::sort(lst.begin(), lst.end());\n    while (!lst.empty()) {\n        result.push_back(lst.front());\n        lst.erase(lst.begin());\n        if (!lst.empty()) {\n            result.push_back(lst.back());\n            lst.pop_back();\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of integers, return vector in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// >>> strange_sort_list((std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)4, (long)2, (long)3}))\n// >>> strange_sort_list((std::vector<long>({(long)5, (long)5, (long)5, (long)5})))\n// (std::vector<long>({(long)5, (long)5, (long)5, (long)5}))\n// >>> strange_sort_list((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> strange_sort_list(std::vector<long> lst) {\n  std::vector<long> result;\n  if (lst.empty())\n    return result;\n  std::sort(lst.begin(), lst.end());\n  while (!lst.empty()) {\n    result.push_back(lst.front());\n    lst.erase(lst.begin());\n    if (!lst.empty()) {\n      result.push_back(lst.back());\n      lst.pop_back();\n    }\n  }\n  return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2.0f;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2.0f;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2.0f;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2.0f;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    return roundf(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if(a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return round(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if(a + b <= c || a + c <= b || b + c <= a)\n        return -1;\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// >>> triangle_area((3), (4), (5))\n// (6.0f)\n// >>> triangle_area((1), (2), (10))\n// (float(-1))\nfloat triangle_area(long a, long b, long c) {\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        return -1;\n    }\n\n    float s = (a + b + c) / 2;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n    return roundf(area * 100) / 100;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum > w) {\n        return false;\n    }\n    long n = q.size();\n    for (long i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto i : q) {\n        sum += i;\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (int i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum <= w) {\n        for (long i = 0; i < q.size() / 2; i++) {\n            if (q[i] != q[q.size() - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); ++i) {\n        sum += q[i];\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (long i = 0; i < q.size(); i++) {\n    sum += q[i];\n  }\n  if (sum > w) {\n    return false;\n  }\n  for (long i = 0; i < q.size() / 2; i++) {\n    if (q[i] != q[q.size() - 1 - i]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if(sum > w) {\n        return false;\n    }\n    for(long i = 0; i < q.size()/2; i++) {\n        if(q[i] != q[q.size()-i-1]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    return (sum <= w && q == std::vector<long>(q.rbegin(), q.rend()));", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (auto i : q) {\n    sum += i;\n  }\n  if (sum > w) {\n    return false;\n  }\n  long n = q.size();\n  for (long i = 0; i < n / 2; i++) {\n    if (q[i] != q[n - i - 1]) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(auto i: q){\n        sum += i;\n    }\n    if(sum > w)\n        return false;\n    for(int i = 0; i < q.size()/2; i++){\n        if(q[i] != q[q.size()-i-1])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(auto i: q)\n        sum += i;\n    if(sum > w)\n        return false;\n    for(int i = 0; i < q.size()/2; i++)\n        if(q[i] != q[q.size()-i-1])\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum <= w) {\n        for (long i = 0; i < q.size() / 2; i++) {\n            if (q[i] != q[q.size() - 1 - i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(long i = 0; i < q.size(); i++)\n        sum += q[i];\n\n    if(sum > w)\n        return false;\n\n    for(long i = 0; i < q.size()/2; i++)\n        if(q[i] != q[q.size()-i-1])\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for(auto i: q)\n        sum += i;\n    if(sum > w)\n        return false;\n    for(long i = 0; i < q.size()/2; i++)\n        if(q[i] != q[q.size()-i-1])\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); ++i) {\n        sum += q[i];\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; ++i) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum <= w) {\n        for (long i = 0; i < q.size() / 2; i++) {\n            if (q[i] != q[q.size() - 1 - i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (long i : q) {\n    sum += i;\n  }\n  return (sum <= w && q == std::vector<long>(q.rbegin(), q.rend()));", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the object q will fly, and false otherwise.\n// The object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1, (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight, but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2, (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n// (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\nbool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long i : q) {\n        sum += i;\n    }\n    if (sum > w) {\n        return false;\n    }\n    for (long i = 0; i < q.size() / 2; i++) {\n        if (q[i] != q[q.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long changes = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long changes = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long count = 0;\n  for (long i = 0; i < n / 2; i++) {\n    if (arr[i] != arr[n - i - 1]) {\n      count++;\n    }\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n  long n = arr.size();\n  long count = 0;\n  for (long i = 0; i < n / 2; i++) {\n    if (arr[i] != arr[n - 1 - i]) {\n      count++;\n    }\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long changes = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long changes = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long changes = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long changes = 0;\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    return changes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n// For example:\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)5, (long)4, (long)7, (long)9, (long)6})))\n// (4)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)3, (long)2, (long)2})))\n// (1)\n// >>> smallest_change((std::vector<long>({(long)1, (long)2, (long)3, (long)2, (long)1})))\n// (0)\nlong smallest_change(std::vector<long> arr) {\n    long n = arr.size();\n    long changes = 0;\n    for (long i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    return changes;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    for(auto str : lst1)\n        total_chars_lst1 += str.length();\n\n    for(auto str : lst2)\n        total_chars_lst2 += str.length();\n\n    if(total_chars_lst1 <= total_chars_lst2)\n        return lst1;\n    else\n        return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    for (auto str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (auto str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    }\n\n    return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int sum1 = 0;\n  int sum2 = 0;\n  for(auto i : lst1)\n    sum1 += i.size();\n  for(auto i : lst2)\n    sum2 += i.size();\n  if(sum1 <= sum2)\n    return lst1;\n  else\n    return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    for (auto i : lst1) {\n        sum1 += i.size();\n    }\n\n    int sum2 = 0;\n    for (auto i : lst2) {\n        sum2 += i.size();\n    }\n\n    if (sum1 <= sum2)\n        return lst1;\n    else\n        return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int lst1_total = 0;\n    int lst2_total = 0;\n    for(auto i : lst1) lst1_total += i.size();\n    for(auto i : lst2) lst2_total += i.size();\n\n    if(lst1_total <= lst2_total)\n        return lst1;\n    else\n        return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for(auto i : lst1)\n        sum1 += i.length();\n    for(auto i : lst2)\n        sum2 += i.length();\n    return (sum1 < sum2) ? lst1 : lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    for (auto str : lst1) {\n        sum1 += str.size();\n    }\n\n    int sum2 = 0;\n    for (auto str : lst2) {\n        sum2 += str.size();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    }\n    else {\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int lst1_total = 0;\n    int lst2_total = 0;\n\n    for (auto str : lst1) {\n        lst1_total += str.length();\n    }\n\n    for (auto str : lst2) {\n        lst2_total += str.length();\n    }\n\n    if (lst1_total <= lst2_total) {\n        return lst1;\n    }\n\n    return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for(auto i: lst1)\n        sum1 += i.length();\n    for(auto i: lst2)\n        sum2 += i.length();\n    if(sum1 <= sum2)\n        return lst1;\n    else\n        return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    for (auto str : lst1) {\n        sum1 += str.size();\n    }\n\n    int sum2 = 0;\n    for (auto str : lst2) {\n        sum2 += str.size();\n    }\n\n    if (sum1 <= sum2)\n        return lst1;\n    else\n        return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    for (std::string str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (std::string str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    }\n    else {\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int lst1_total = 0;\n    int lst2_total = 0;\n\n    for(int i = 0; i < lst1.size(); i++) {\n        lst1_total += lst1[i].length();\n    }\n\n    for(int i = 0; i < lst2.size(); i++) {\n        lst2_total += lst2[i].length();\n    }\n\n    if(lst1_total < lst2_total) {\n        return lst1;\n    }\n    else {\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int lst1_total = 0;\n    int lst2_total = 0;\n\n    for(std::string str : lst1) {\n        lst1_total += str.length();\n    }\n\n    for(std::string str : lst2) {\n        lst2_total += str.length();\n    }\n\n    if(lst1_total < lst2_total) {\n        return lst1;\n    }\n    else {\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    for(auto str : lst1) {\n        total_chars_lst1 += str.length();\n    }\n\n    for(auto str : lst2) {\n        total_chars_lst2 += str.length();\n    }\n\n    if(total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    }\n    else {\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int lst1_total = 0;\n    int lst2_total = 0;\n    for(auto str : lst1) {\n        lst1_total += str.size();\n    }\n    for(auto str : lst2) {\n        lst2_total += str.size();\n    }\n    if(lst1_total <= lst2_total) {\n        return lst1;\n    }\n    else {\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    for(auto s : lst1) {\n        sum1 += s.size();\n    }\n\n    int sum2 = 0;\n    for(auto s : lst2) {\n        sum2 += s.size();\n    }\n\n    if(sum1 <= sum2) {\n        return lst1;\n    }\n    else {\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for(auto str : lst1){\n        sum1 += str.length();\n    }\n    for(auto str : lst2){\n        sum2 += str.length();\n    }\n    if(sum1 <= sum2){\n        return lst1;\n    }\n    else{\n        return lst2;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n  int sum1 = 0;\n  int sum2 = 0;\n  for (auto &s : lst1) {\n    sum1 += s.size();\n  }\n  for (auto &s : lst2) {\n    sum2 += s.size();\n  }\n  return sum1 <= sum2 ? lst1 : lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    for(auto str : lst1)\n        total_chars_lst1 += str.length();\n\n    for(auto str : lst2)\n        total_chars_lst2 += str.length();\n\n    if(total_chars_lst1 <= total_chars_lst2)\n        return lst1;\n    else\n        return lst2;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts two vectors of strings and returns the vector that has \n// total number of chars in the all strings of the vector less than the other vector.\n// if the two vectors have the same number of chars, return the first vector.\n// Examples\n// >>> total_match((std::vector<std::string>()), (std::vector<std::string>()))\n// (std::vector<std::string>())\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"Hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hi\", (std::string)\"hi\", (std::string)\"admin\", (std::string)\"project\"})))\n// (std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"hi\", (std::string)\"admin\"})), (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"})))\n// (std::vector<std::string>({(std::string)\"hI\", (std::string)\"hi\", (std::string)\"hi\"}))\n// >>> total_match((std::vector<std::string>({(std::string)\"4\"})), (std::vector<std::string>({(std::string)\"1\", (std::string)\"2\", (std::string)\"3\", (std::string)\"4\", (std::string)\"5\"})))\n// (std::vector<std::string>({(std::string)\"4\"}))\nstd::vector<std::string> total_match(std::vector<std::string> lst1, std::vector<std::string> lst2) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for(auto i : lst1)\n        sum1 += i.size();\n    for(auto i : lst2)\n        sum2 += i.size();\n    if(sum1 <= sum2)\n        return lst1;\n    else\n        return lst2;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    // Write your code here\n    if(a <= 1)\n        return false;\n    long primes[3] = {2, 3, 5};\n    long prod = 1;\n    for(int i = 0; i < 3; i++)\n    {\n        while(a % primes[i] == 0)\n        {\n            prod *= primes[i];\n            a /= primes[i];\n        }\n    }\n    return prod == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n\n    for (int i = 0; i < 3; i++) {\n        while (a % primes[i] == 0)\n            a /= primes[i];\n    }\n\n    return a == 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n    long count = 0;\n\n    for (long i = 0; i < 3; i++) {\n        while (a % primes[i] == 0) {\n            count++;\n            a /= primes[i];\n        }\n    }\n\n    return count == 3 && a == 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 2)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n    long prod = 1;\n\n    for (int i = 0; i < 3; i++) {\n        while (a % primes[i] == 0) {\n            prod *= primes[i];\n            a /= primes[i];\n        }\n    }\n\n    return prod == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n    long prod = 1;\n\n    for (int i = 0; i < 3; i++) {\n        while (a % primes[i] == 0) {\n            prod *= primes[i];\n            a /= primes[i];\n        }\n    }\n\n    return prod == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 2)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n    long prod = 1;\n\n    for (int i = 0; i < 3; i++) {\n        while (a % primes[i] == 0) {\n            prod *= primes[i];\n            a /= primes[i];\n        }\n    }\n\n    return prod == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n    long prod = 1;\n\n    for (int i = 0; i < 3; i++) {\n        while (a % primes[i] == 0) {\n            prod *= primes[i];\n            a /= primes[i];\n        }\n    }\n\n    return prod == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n\n    for (int i = 0; i < 10; i++) {\n        if (a % primes[i] == 0) {\n            long temp = a / primes[i];\n            for (int j = i + 1; j < 10; j++) {\n                if (temp % primes[j] == 0) {\n                    long temp2 = temp / primes[j];\n                    if (temp2 % primes[i] == 0)\n                        return true;\n                }\n            }\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long prime_product = 1;\n    long prime_count = 0;\n\n    for (long i = 2; i <= a; i++) {\n        if (a % i == 0) {\n            while (a % i == 0) {\n                a /= i;\n                prime_product *= i;\n                prime_count++;\n            }\n        }\n    }\n\n    return prime_count == 3 && prime_product == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 6) {\n        return false;\n    }\n    long prime[3] = {2, 3, 5};\n    long prod = 1;\n    for (int i = 0; i < 3; i++) {\n        prod *= prime[i];\n    }\n    if (prod == a) {\n        return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 2) {\n        return false;\n    }\n\n    long primes[3] = {2, 3, 5};\n    long prod = 1;\n    for (int i = 0; i < 3; i++) {\n        prod *= primes[i];\n    }\n\n    if (prod == a) {\n        return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 2) {\n        return false;\n    }\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            for (int k = 0; k < 10; k++) {\n                if (primes[i] * primes[j] * primes[k] == a) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    long count = 0;\n\n    for (long i = 0; i < 10; i++) {\n        while (a % primes[i] == 0) {\n            count++;\n            a /= primes[i];\n        }\n    }\n\n    return count == 3 && a == 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 6)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n\n    for (int i = 0; i < 3; i++) {\n        long prime = primes[i];\n        while (a % prime == 0) {\n            a /= prime;\n        }\n    }\n\n    return a == 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    long count = 0;\n    long temp = a;\n\n    for (long i = 0; i < 10; i++) {\n        while (temp % primes[i] == 0) {\n            count++;\n            temp /= primes[i];\n        }\n    }\n\n    if (temp != 1)\n        return false;\n\n    return count == 3;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 6)\n        return false;\n\n    long primes[3] = {2, 3, 5};\n\n    for (int i = 0; i < 3; i++) {\n        while (a % primes[i] == 0) {\n            a /= primes[i];\n        }\n    }\n\n    return a == 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if(a < 2)\n        return false;\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n\n    for(int i = 0; i < 10; i++) {\n        for(int j = i + 1; j < 10; j++) {\n            for(int k = j + 1; k < 10; k++) {\n                if(primes[i] * primes[j] * primes[k] == a)\n                    return true;\n            }\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    long count = 0;\n\n    for (long i = 0; i < 10; i++) {\n        while (a % primes[i] == 0) {\n            count++;\n            a /= primes[i];\n        }\n    }\n\n    return count == 3;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a <= 1)\n        return false;\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    long count = 0;\n\n    for (int i = 0; i < 10; i++) {\n        while (a % primes[i] == 0) {\n            count++;\n            a /= primes[i];\n        }\n    }\n\n    return count == 3;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that (a) is less then 100. \n// Example:\n// >>> is_multiply_prime((30))\n// (true)\n// 30 = 2 * 3 * 5\nbool is_multiply_prime(long a) {\n    if (a < 2)\n        return false;\n\n    long primes[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n\n    for (int i = 0; i < 10; i++) {\n        if (a % primes[i] == 0) {\n            long temp = a / primes[i];\n            for (int j = i + 1; j < 10; j++) {\n                if (temp % primes[j] == 0) {\n                    long temp2 = temp / primes[j];\n                    if (temp2 % primes[i] == 0)\n                        return true;\n                }\n            }\n        }\n    }\n\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    return temp==x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    if(temp==x)\n        return true;\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    if(temp==x)\n        return true;\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    if(x==1)\n        return false;\n    long temp=x;\n    while(temp!=1){\n        if(temp%n!=0)\n            return false;\n        temp/=n;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    if(temp==x)\n        return true;\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    if(x==1)\n        return false;\n    long temp=sqrt(x);\n    while(temp>=1){\n        if(pow(n,temp)==x)\n            return true;\n        temp--;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if (x == 1)\n        return true;\n    if (x == n)\n        return true;\n    if (x % n != 0)\n        return false;\n    return is_simple_power(x / n, n);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    if(temp==x)\n        return true;\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if (n == 1)\n        return true;\n\n    long temp = n;\n    while (temp < x)\n        temp *= n;\n\n    return temp == x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    return temp==x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    return temp==x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n  if (x == 1)\n    return true;\n  if (x == 0)\n    return false;\n  if (n == 1)\n    return false;\n  if (n == 0)\n    return false;\n  long temp = x;\n  while (temp != 1) {\n    if (temp % n != 0)\n      return false;\n    temp /= n;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    if(x==1)\n        return false;\n    long temp=x;\n    while(temp!=1){\n        if(temp%n!=0)\n            return false;\n        temp/=n;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if (n == 1)\n        return true;\n\n    long temp = n;\n    while (temp < x) {\n        temp *= n;\n    }\n\n    return temp == x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    return temp==x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    if(temp==x)\n        return true;\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    return temp==x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    return temp==x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(n==1)\n        return true;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    if(temp==x)\n        return true;\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\n// For example:\n// >>> is_simple_power((1), (4))\n// (true)\n// >>> is_simple_power((2), (2))\n// (true)\n// >>> is_simple_power((8), (2))\n// (true)\n// >>> is_simple_power((3), (2))\n// (false)\n// >>> is_simple_power((3), (1))\n// (false)\n// >>> is_simple_power((5), (3))\n// (false)\nbool is_simple_power(long x, long n) {\n    if(x==1)\n        return true;\n    if(n==1)\n        return false;\n    long temp=n;\n    while(temp<x){\n        temp*=n;\n    }\n    if(temp==x)\n        return true;\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long b = cbrt(a);\n    return (b*b*b == a);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long b = std::cbrt(a);\n    return a == b * b * b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long b = std::cbrt(a);\n    return a == b * b * b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return (c*c*c == a);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long b = cbrt(a);\n    return a == b * b * b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long b = cbrt(a);\n    return (b*b*b == a);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = cbrt(a);\n    return (c*c*c == a);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long c = std::cbrt(a);\n    return c*c*c == a;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes an integer a and returns true \n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\n// Examples:\n// >>> iscube((1))\n// (true)\n// >>> iscube((2))\n// (false)\n// >>> iscube((-1))\n// (true)\n// >>> iscube((64))\n// (true)\n// >>> iscube((0))\n// (true)\n// >>> iscube((180))\n// (false)\nbool iscube(long a) {\n    long b = std::cbrt(a);\n    return a == b * b * b;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    long count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.count(c)) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<int> primes = {2, 3, 5, 7, 11, 13};\n    long count = 0;\n    for (char c : num) {\n        int digit = std::isdigit(c) ? c - '0' : c - 'A' + 10;\n        if (primes.count(digit)) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<int> primes = {2, 3, 5, 7, 11, 13};\n    int count = 0;\n    for (char c : num) {\n        int digit = 0;\n        if (c >= '0' && c <= '9') {\n            digit = c - '0';\n        } else if (c >= 'A' && c <= 'F') {\n            digit = c - 'A' + 10;\n        }\n        if (primes.count(digit)) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for(char c : num) {\n        if(primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    long count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    long count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    long count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have been tasked to write a function that receives \n// a hexadecimal number as a string and counts the number of hexadecimal \n// digits that are primes (prime number, or a prime, is a natural number \n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n// >>> hex_key((\"AB\"))\n// (1)\n// >>> hex_key((\"1077E\"))\n// (2)\n// >>> hex_key((\"ABED1A33\"))\n// (4)\n// >>> hex_key((\"123456789ABCDEF0\"))\n// (6)\n// >>> hex_key((\"2020\"))\n// (2)\nlong hex_key(std::string num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    long count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\";\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"\";\n  while (decimal > 0) {\n    binary = std::to_string(decimal % 2) + binary;\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\";\n\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"\";\n  while (decimal > 0) {\n    binary = std::to_string(decimal % 2) + binary;\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\";\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\";\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\";\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\";\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"\";\n  while (decimal > 0) {\n    binary = std::to_string(decimal % 2) + binary;\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"\";\n  while (decimal > 0) {\n    binary = std::to_string(decimal % 2) + binary;\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary;\n  while (decimal > 0) {\n    binary = std::to_string(decimal % 2) + binary;\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n  std::string binary = \"\";\n  while (decimal > 0) {\n    binary = std::to_string(decimal % 2) + binary;\n    decimal /= 2;\n  }\n  return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary = \"\";\n\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary((15))\n// (\"db1111db\")\n// >>> decimal_to_binary((32))\n// (\"db100000db\")\nstd::string decimal_to_binary(long decimal) {\n    std::string binary;\n    while (decimal > 0) {\n        binary = std::to_string(decimal % 2) + binary;\n        decimal /= 2;\n    }\n    return \"db\" + binary + \"db\";"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i < s.length() - 2; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if (s.size() < 3)\n        return false;\n\n    for (int i = 0; i <= s.size() - 3; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length()<3)\n        return false;\n    for(int i=0;i<s.length()-2;i++)\n    {\n        if(s[i]==s[i+1] || s[i]==s[i+2] || s[i+1]==s[i+2])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i < s.length() - 2; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length()<3)\n        return false;\n    for(int i=0;i<s.length()-2;i++)\n    {\n        if(s[i]==s[i+1] || s[i]==s[i+2] || s[i+1]==s[i+2])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i <= s.length() - 3; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i <= s.length() - 3; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.size() < 3)\n        return false;\n\n    for(int i = 0; i <= s.size() - 3; i++)\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i <= s.length() - 3; i++)\n        if(s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n    for(int i = 0; i < s.length() - 2; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length()<3)\n        return false;\n    for(int i=0;i<s.length()-2;i++)\n    {\n        if(s[i]==s[i+1] || s[i]==s[i+2] || s[i+1]==s[i+2])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.size() < 3)\n        return false;\n\n    for(int i = 0; i <= s.size() - 3; i++)\n        if(s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i <= s.length() - 3; i++) {\n        if(s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n    for(int i = 0; i < s.length() - 2; i++)\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i < s.length() - 2; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.size()<3)\n        return false;\n    for(int i=0;i<s.size()-2;i++)\n    {\n        if(s[i]==s[i+1] || s[i]==s[i+2] || s[i+1]==s[i+2])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n  if (s.length() < 3)\n    return false;\n  for (int i = 0; i <= s.length() - 3; i++) {\n    if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2])\n      return false;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length()<3)\n        return false;\n    for(int i=0;i<s.length()-2;i++)\n    {\n        if(s[i]==s[i+1] || s[i]==s[i+2] || s[i+1]==s[i+2])\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.size() < 3)\n        return false;\n\n    for(int i = 0; i < s.size() - 2; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// Your task is to check if the string is hapcpp or not.\n// A string is hapcpp if its length is at least 3 and every 3 consecutive letters are distinct\n// For example:\n// >>> is_happy((\"a\"))\n// (false)\n// >>> is_happy((\"aa\"))\n// (false)\n// >>> is_happy((\"abcd\"))\n// (true)\n// >>> is_happy((\"aabb\"))\n// (false)\n// >>> is_happy((\"adb\"))\n// (true)\n// >>> is_happy((\"xyy\"))\n// (false)\nbool is_happy(std::string s) {\n    if(s.length() < 3)\n        return false;\n\n    for(int i = 0; i <= s.length() - 3; i++)\n    {\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0f) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7f) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3f) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0f) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7f) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3f) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0f) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7f) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3f) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0f) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7f) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0f) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        }\n        else if(grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        }\n        else if(grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        }\n        else if(grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        }\n        else if(grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        }\n        else if(grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        }\n        else if(grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        }\n        else if(grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        }\n        else if(grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        }\n        else if(grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        }\n        else if(grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        }\n        else if(grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        }\n        else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade == 4.0)\n            letter_grades.push_back(\"A+\");\n        else if(grade > 3.7)\n            letter_grades.push_back(\"A\");\n        else if(grade > 3.3)\n            letter_grades.push_back(\"A-\");\n        else if(grade > 3.0)\n            letter_grades.push_back(\"B+\");\n        else if(grade > 2.7)\n            letter_grades.push_back(\"B\");\n        else if(grade > 2.3)\n            letter_grades.push_back(\"B-\");\n        else if(grade > 2.0)\n            letter_grades.push_back(\"C+\");\n        else if(grade > 1.7)\n            letter_grades.push_back(\"C\");\n        else if(grade > 1.3)\n            letter_grades.push_back(\"C-\");\n        else if(grade > 1.0)\n            letter_grades.push_back(\"D+\");\n        else if(grade > 0.7)\n            letter_grades.push_back(\"D\");\n        else if(grade > 0.0)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        }\n        else if(grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        }\n        else if(grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        }\n        else if(grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        }\n        else if(grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        }\n        else if(grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        }\n        else if(grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        }\n        else if(grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        }\n        else if(grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        }\n        else if(grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        }\n        else if(grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        }\n        else if(grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        }\n        else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade >= 4.0)\n            letter_grades.push_back(\"A+\");\n        else if(grade > 3.7)\n            letter_grades.push_back(\"A\");\n        else if(grade > 3.3)\n            letter_grades.push_back(\"A-\");\n        else if(grade > 3.0)\n            letter_grades.push_back(\"B+\");\n        else if(grade > 2.7)\n            letter_grades.push_back(\"B\");\n        else if(grade > 2.3)\n            letter_grades.push_back(\"B-\");\n        else if(grade > 2.0)\n            letter_grades.push_back(\"C+\");\n        else if(grade > 1.7)\n            letter_grades.push_back(\"C\");\n        else if(grade > 1.3)\n            letter_grades.push_back(\"C-\");\n        else if(grade > 1.0)\n            letter_grades.push_back(\"D+\");\n        else if(grade > 0.7)\n            letter_grades.push_back(\"D\");\n        else if(grade > 0.0)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if(grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if(grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if(grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if(grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if(grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if(grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if(grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if(grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if(grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if(grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if(grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        }\n        else if(grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        }\n        else if(grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        }\n        else if(grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        }\n        else if(grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        }\n        else if(grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        }\n        else if(grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        }\n        else if(grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        }\n        else if(grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        }\n        else if(grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        }\n        else if(grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        }\n        else if(grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        }\n        else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(float grade : grades) {\n        if(grade == 4.0)\n            letter_grades.push_back(\"A+\");\n        else if(grade > 3.7)\n            letter_grades.push_back(\"A\");\n        else if(grade > 3.3)\n            letter_grades.push_back(\"A-\");\n        else if(grade > 3.0)\n            letter_grades.push_back(\"B+\");\n        else if(grade > 2.7)\n            letter_grades.push_back(\"B\");\n        else if(grade > 2.3)\n            letter_grades.push_back(\"B-\");\n        else if(grade > 2.0)\n            letter_grades.push_back(\"C+\");\n        else if(grade > 1.7)\n            letter_grades.push_back(\"C\");\n        else if(grade > 1.3)\n            letter_grades.push_back(\"C-\");\n        else if(grade > 1.0)\n            letter_grades.push_back(\"D+\");\n        else if(grade > 0.7)\n            letter_grades.push_back(\"D\");\n        else if(grade > 0.0)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        }\n        else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        }\n        else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        }\n        else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        }\n        else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        }\n        else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        }\n        else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        }\n        else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        }\n        else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        }\n        else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        }\n        else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        }\n        else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        }\n        else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (auto grade : grades) {\n        if (grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (float grade : grades) {\n        if (grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(float grade : grades) {\n        if(grade == 4.0)\n            letter_grades.push_back(\"A+\");\n        else if(grade > 3.7)\n            letter_grades.push_back(\"A\");\n        else if(grade > 3.3)\n            letter_grades.push_back(\"A-\");\n        else if(grade > 3.0)\n            letter_grades.push_back(\"B+\");\n        else if(grade > 2.7)\n            letter_grades.push_back(\"B\");\n        else if(grade > 2.3)\n            letter_grades.push_back(\"B-\");\n        else if(grade > 2.0)\n            letter_grades.push_back(\"C+\");\n        else if(grade > 1.7)\n            letter_grades.push_back(\"C\");\n        else if(grade > 1.3)\n            letter_grades.push_back(\"C-\");\n        else if(grade > 1.0)\n            letter_grades.push_back(\"D+\");\n        else if(grade > 0.7)\n            letter_grades.push_back(\"D\");\n        else if(grade > 0.0)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade == 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if(grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if(grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if(grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if(grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if(grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if(grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if(grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if(grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if(grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if(grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if(grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for(auto grade : grades) {\n        if(grade >= 4.0)\n            letter_grades.push_back(\"A+\");\n        else if(grade > 3.7)\n            letter_grades.push_back(\"A\");\n        else if(grade > 3.3)\n            letter_grades.push_back(\"A-\");\n        else if(grade > 3.0)\n            letter_grades.push_back(\"B+\");\n        else if(grade > 2.7)\n            letter_grades.push_back(\"B\");\n        else if(grade > 2.3)\n            letter_grades.push_back(\"B-\");\n        else if(grade > 2.0)\n            letter_grades.push_back(\"C+\");\n        else if(grade > 1.7)\n            letter_grades.push_back(\"C\");\n        else if(grade > 1.3)\n            letter_grades.push_back(\"C-\");\n        else if(grade > 1.0)\n            letter_grades.push_back(\"D+\");\n        else if(grade > 0.7)\n            letter_grades.push_back(\"D\");\n        else if(grade > 0.0)\n            letter_grades.push_back(\"D-\");\n        else\n            letter_grades.push_back(\"E\");\n    }\n    return letter_grades;", "#include<assert.h>\n#include<bits/stdc++.h>\n// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write \n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A \n// > 3.3                A- \n// > 3.0                B+\n// > 2.7                B \n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+ \n// > 0.7                D \n// > 0.0                D-\n// 0.0                E\n// Example:\n// >>> grade_equation((std::vector<float>({(float)4.0f, (float)3, (float)1.7f, (float)2, (float)3.5f})))\n// (std::vector<std::string>({(std::string)\"A+\", (std::string)\"B\", (std::string)\"C-\", (std::string)\"C\", (std::string)\"A-\"}))\nstd::vector<std::string> numerical_letter_grade(std::vector<float> grades) {\n    std::vector<std::string> letter_grades;\n    for (auto grade : grades) {\n        if (grade >= 4.0) {\n            letter_grades.push_back(\"A+\");\n        } else if (grade > 3.7) {\n            letter_grades.push_back(\"A\");\n        } else if (grade > 3.3) {\n            letter_grades.push_back(\"A-\");\n        } else if (grade > 3.0) {\n            letter_grades.push_back(\"B+\");\n        } else if (grade > 2.7) {\n            letter_grades.push_back(\"B\");\n        } else if (grade > 2.3) {\n            letter_grades.push_back(\"B-\");\n        } else if (grade > 2.0) {\n            letter_grades.push_back(\"C+\");\n        } else if (grade > 1.7) {\n            letter_grades.push_back(\"C\");\n        } else if (grade > 1.3) {\n            letter_grades.push_back(\"C-\");\n        } else if (grade > 1.0) {\n            letter_grades.push_back(\"D+\");\n        } else if (grade > 0.7) {\n            letter_grades.push_back(\"D\");\n        } else if (grade > 0.0) {\n            letter_grades.push_back(\"D-\");\n        } else {\n            letter_grades.push_back(\"E\");\n        }\n    }\n    return letter_grades;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int length = string.length();\n  if (length <= 1)\n    return false;\n  if (length == 2)\n    return true;\n  for (int i = 2; i <= sqrt(length); i++) {\n    if (length % i == 0)\n      return false;\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1)\n        return false;\n\n    for (int i = 2; i <= sqrt(length); i++)\n        if (length % i == 0)\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1)\n        return false;\n    if (length == 2)\n        return true;\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0)\n            return false;\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1)\n        return false;\n    for (int i = 2; i <= sqrt(length); i++)\n        if (length % i == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int length = string.length();\n  if (length <= 1)\n    return false;\n  for (int i = 2; i <= sqrt(length); i++)\n    if (length % i == 0)\n      return false;\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n\n    if (length <= 1) {\n        return false;\n    }\n\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n\n    if (length <= 1) {\n        return false;\n    }\n\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n\n    if (length <= 1) {\n        return false;\n    }\n\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1)\n        return false;\n\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0)\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int n = string.length();\n  if (n <= 1) {\n    return false;\n  }\n  for (int i = 2; i <= sqrt(n); i++) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int length = string.length();\n  if (length <= 1)\n    return false;\n  for (int i = 2; i <= sqrt(length); i++)\n    if (length % i == 0)\n      return false;\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n  int n = string.length();\n  if (n <= 1)\n    return false;\n  if (n <= 3)\n    return true;\n  if (n % 2 == 0 || n % 3 == 0)\n    return false;\n  for (int i = 5; i * i <= n; i += 6)\n    if (n % i == 0 || n % (i + 2) == 0)\n      return false;\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int n = string.length();\n    if (n <= 1)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns true if the string\n// length is a prime number or false otherwise\n// Examples\n// >>> prime_length((\"Hello\"))\n// (true)\n// >>> prime_length((\"abcdcba\"))\n// (true)\n// >>> prime_length((\"kittens\"))\n// (true)\n// >>> prime_length((\"orange\"))\n// (false)\nbool prime_length(std::string string) {\n    int length = string.length();\n    if (length <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(length); i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long count = 0;\n    if (n == 1)\n        return 1;\n    else if (n == 2)\n        return 2;\n    else if (n == 3)\n        return 4;\n    else {\n        count = 9 * (long)pow(10, n - 2);\n        count += 8 * (long)pow(10, n - 3);\n        count += 10 * (long)pow(10, n - 2);\n        count += 8 * (long)pow(10, n - 3);\n        return count;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if(n == 1)\n        return 1;\n    else if(n == 2)\n        return 2;\n    else if(n == 3)\n        return 4;\n    else\n        return 9 * starts_one_ends(n - 1);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long count = 0;\n    if (n == 1) {\n        return 1;\n    }\n    if (n == 2) {\n        return 2;\n    }\n    if (n == 3) {\n        return 4;\n    }\n    if (n == 4) {\n        return 8;\n    }\n    if (n == 5) {\n        return 16;\n    }\n    if (n == 6) {\n        return 32;\n    }\n    if (n == 7) {\n        return 64;\n    }\n    if (n == 8) {\n        return 128;\n    }\n    if (n == 9) {\n        return 256;\n    }\n    if (n == 10) {\n        return 512;\n    }\n    if (n > 10) {\n        return 1024;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    long long int count = 8;\n    long long int mul = 10;\n    for (long i = 3; i <= n; i++) {\n        mul *= 10;\n        count += mul * 8;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long start_one = 9;\n    long ends_one = 1;\n    long total = 0;\n\n    for (long i = 1; i <= n; i++) {\n        total += start_one * pow(9, i - 1);\n        start_one *= 10;\n        ends_one *= 10;\n    }\n\n    return total;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    else if (n == 2)\n        return 2;\n    else\n        return 9 * starts_one_ends(n - 1) + 8 * starts_one_ends(n - 2);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    long count = 9;\n    for (long i = 1; i < n - 1; i++)\n        count = count * 10 + 9;\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n  long count = 0;\n  if (n == 1)\n    return 1;\n  else if (n == 2)\n    return 2;\n  else if (n == 3)\n    return 4;\n  else {\n    count = 8;\n    for (int i = 4; i <= n; i++)\n      count = count * 10 + 8;\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long long count = 0;\n    if(n == 1)\n        return 1;\n    if(n == 2)\n        return 2;\n    if(n == 3)\n        return 4;\n    if(n == 4)\n        return 8;\n    if(n == 5)\n        return 16;\n    if(n == 6)\n        return 32;\n    if(n == 7)\n        return 64;\n    if(n == 8)\n        return 128;\n    if(n == 9)\n        return 256;\n    if(n == 10)\n        return 512;\n    if(n == 11)\n        return 1024;\n    if(n == 12)\n        return 2048;\n    if(n == 13)\n        return 4096;\n    if(n == 14)\n        return 8192;\n    if(n == 15)\n        return 16384;\n    if(n == 16)\n        return 32768;\n    if(n == 17)\n        return 65536;\n    if(n == 18)\n        return 131072;\n    if(n == 19)\n        return 262144;\n    if(n == 20)\n        return 524288;\n    if(n == 21)\n        return 1048576;\n    if(n == 22)\n        return 2097152;\n    if(n == 23)\n        return 4194304;\n    if(n == 24)\n        return 8388608;\n    if(n == 25)\n        return 16777216;\n    if(n == 26)\n        return 33554432;\n    if(n == 27)\n        return 67108864;\n    if(n == 28)\n        return 134217728;\n    if(n == 29)\n        return 268435456;\n    if(n == 30)\n        return 536870912;\n    if(n == 31)\n        return 1073741824;\n    if(n == 32)\n        return 2147483648;\n    if(n == 33)\n        return 4294967296;\n    if(n == 34)\n        return 8589934592;\n    if(n == 35)\n        return 17179869184;\n    if(n == 36)\n        return 34359738368;\n    if(n == 37)\n        return 68719476736;\n    if(n == 38)\n        return 137438953472;\n    if(n == 39)\n        return 274877906944;\n    if(n == 40", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    long count = 9;\n    long base = 10;\n    for (long i = 3; i <= n; i++) {\n        count += 9 * (base - 1);\n        base *= 10;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if(n == 1)\n        return 1;\n    if(n == 2)\n        return 2;\n    long long int ans = 0;\n    ans = 9 * (long long int)pow(10, n - 1);\n    ans += 8 * (long long int)pow(10, n - 2);\n    ans += 10 * (long long int)pow(10, n - 2);\n    ans += 8 * (long long int)pow(10, n - 2);\n    ans += 1;\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long count = 0;\n    if (n == 1)\n        return 1;\n    else if (n == 2)\n        return 2;\n    else {\n        count = 9 * (long)pow(10, n - 2);\n        count += 8 * (long)pow(10, n - 2);\n        count += 1;\n        return count;\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long count = 0;\n    if (n == 1) {\n        count = 1;\n    } else if (n == 2) {\n        count = 2;\n    } else {\n        count = 2 * (9 * (long)pow(10, n - 2) - 1);\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    long starts_one = 9 * starts_one_ends(n - 1);\n    long ends_one = 10 * starts_one_ends(n - 1) - 1;\n    return starts_one + ends_one;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    long long count = 9;\n    long long base = 10;\n    for (long i = 3; i <= n; i++) {\n        count += 9 * (base - 1);\n        base *= 10;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long long res = 0;\n    for (long i = 1; i <= 9; ++i) {\n        res += 9 * pow(10, n - 1);\n    }\n    for (long i = 0; i < 9; ++i) {\n        res += 10 * pow(10, i);\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    long starts_one = 9 * starts_one_ends(n - 1);\n    long ends_one = 9 * starts_one_ends(n - 1);\n    long both_one = 8 * starts_one_ends(n - 2);\n    return starts_one + ends_one - both_one;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    return 9 * starts_one_ends(n - 1) + 10;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    long count = 0;\n    if (n == 1)\n        return 1;\n    if (n == 2)\n        return 2;\n    if (n == 3)\n        return 4;\n\n    count = 9 * (long)pow(10, n - 1);\n    count += 8 * (long)pow(10, n - 2);\n    count += 10 * (long)pow(10, n - 3);\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nlong starts_one_ends(long n) {\n    if (n == 1)\n        return 1;\n    else\n        return 10 * starts_one_ends(n - 1) + 8 * pow(9, n - 2);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while(N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while(N > 0){\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary = \"\";\n    while(N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary = \"\";\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while(N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while(N){\n        binary = std::to_string(N%2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary = \"\";\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while(N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary = \"\";\n    while(N > 0){\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while(N){\n        binary = std::to_string(N%2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary = \"\";\n    while(N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while (N) {\n        binary += (N % 2) + '0';\n        N /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while (N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary;\n    while(N > 0){\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer N, return the total sum of its digits in binary.\n// Example\n// >>> solve((1000))\n// (\"1\")\n// >>> solve((150))\n// (\"110\")\n// >>> solve((147))\n// (\"1100\")\n// Variables:\n// @N integer\n// Constraints: 0 \u2264 N \u2264 10000.\n// Output:\n// a string of binary number\nstd::string solve(long N) {\n    std::string binary = \"\";\n    while(N > 0) {\n        binary = std::to_string(N % 2) + binary;\n        N /= 2;\n    }\n    return binary;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0)\n            sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0)\n      sum += lst[i];\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0)\n            sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0)\n            sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0)\n            sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0)\n      sum += lst[i];\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0)\n      sum += lst[i];\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n  long sum = 0;\n  for (int i = 1; i < lst.size(); i += 2) {\n    if (lst[i] % 2 == 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\n// Examples:\n// >>> add((std::vector<long>({(long)4, (long)2, (long)6, (long)7})))\n// (2)\nlong add(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0)\n            sum += lst[i];\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (int i = 0; i < words.size(); i++) {\n        std::sort(words[i].begin(), words[i].end());\n    }\n\n    std::stringstream result;\n    for (int i = 0; i < words.size(); i++) {\n        result << words[i];\n        if (i != words.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word;\n  std::vector<std::string> words;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  for (auto &word : words) {\n    std::sort(word.begin(), word.end());\n  }\n  std::stringstream result;\n  for (const auto &word : words) {\n    result << word << \" \";\n  }\n  std::string result_str = result.str();\n  return result_str.substr(0, result_str.size() - 1);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word;\n  std::vector<std::string> words;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  for (auto& word : words) {\n    std::sort(word.begin(), word.end());\n  }\n  std::stringstream result;\n  for (const auto& word : words) {\n    result << word << \" \";\n  }\n  std::string result_str = result.str();\n  return result_str.substr(0, result_str.size() - 1);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (int i = 0; i < words.size(); i++) {\n        std::sort(words[i].begin(), words[i].end());\n    }\n\n    std::stringstream result;\n    for (int i = 0; i < words.size(); i++) {\n        result << words[i];\n        if (i != words.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    for (const auto& word : words) {\n        std::vector<char> chars(word.begin(), word.end());\n        std::sort(chars.begin(), chars.end());\n        result += std::string(chars.begin(), chars.end()) + \" \";\n    }\n\n    result.pop_back();\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ') {\n            words.push_back(word);\n            word.clear();\n        } else {\n            word.push_back(c);\n        }\n    }\n    words.push_back(word);\n\n    for (auto& w : words) {\n        std::sort(w.begin(), w.end());\n    }\n\n    std::string result;\n    for (const auto& w : words) {\n        result += w;\n        result += ' ';\n    }\n    result.pop_back();\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::vector<std::string> words;\n  std::string word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      words.push_back(word);\n      word = \"\";\n    } else {\n      word += c;\n    }\n  }\n  words.push_back(word);\n  for (std::string &word : words) {\n    std::sort(word.begin(), word.end());\n  }\n  std::string result = \"\";\n  for (std::string &word : words) {\n    result += word;\n    result += ' ';\n  }\n  result.pop_back();\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (auto &word : words) {\n        std::sort(word.begin(), word.end());\n    }\n\n    std::stringstream result;\n    for (auto &word : words) {\n        result << word << \" \";\n    }\n\n    std::string result_str = result.str();\n    return result_str.substr(0, result_str.size() - 1);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::stringstream ss(s);\n  std::string word;\n  std::vector<std::string> words;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  for (auto &word : words) {\n    std::sort(word.begin(), word.end());\n  }\n  std::stringstream result;\n  for (const auto &word : words) {\n    result << word << \" \";\n  }\n  std::string result_str = result.str();\n  return result_str.substr(0, result_str.size() - 1);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (auto &word : words) {\n        std::sort(word.begin(), word.end());\n    }\n\n    std::stringstream result;\n    for (const auto &word : words) {\n        result << word << \" \";\n    }\n\n    std::string final_result = result.str();\n    final_result.pop_back();\n    return final_result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (int i = 0; i < words.size(); i++) {\n        std::sort(words[i].begin(), words[i].end());\n    }\n\n    std::stringstream result;\n    for (int i = 0; i < words.size(); i++) {\n        result << words[i];\n        if (i != words.size() - 1) {\n            result << \" \";\n        }\n    }\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    for (const auto& word : words) {\n        std::vector<char> chars(word.begin(), word.end());\n        std::sort(chars.begin(), chars.end());\n        result += std::string(chars.begin(), chars.end()) + \" \";\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (int i = 0; i < words.size(); i++) {\n        std::sort(words[i].begin(), words[i].end());\n    }\n\n    std::stringstream result;\n    for (int i = 0; i < words.size(); i++) {\n        result << words[i];\n        if (i != words.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    for (const auto& word : words) {\n        std::vector<char> chars(word.begin(), word.end());\n        std::sort(chars.begin(), chars.end());\n        result += std::string(chars.begin(), chars.end());\n        result += \" \";\n    }\n\n    result.pop_back();\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ') {\n            words.push_back(word);\n            word = \"\";\n        } else {\n            word += c;\n        }\n    }\n    words.push_back(word);\n\n    for (std::string &word : words) {\n        std::sort(word.begin(), word.end());\n    }\n\n    std::string result = \"\";\n    for (std::string &word : words) {\n        result += word;\n        result += ' ';\n    }\n    result.pop_back();\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::vector<std::string> ordered_words;\n    for (const auto& word : words) {\n        std::vector<char> chars(word.begin(), word.end());\n        std::sort(chars.begin(), chars.end());\n        std::string ordered_word(chars.begin(), chars.end());\n        ordered_words.push_back(ordered_word);\n    }\n\n    std::stringstream result;\n    for (const auto& word : ordered_words) {\n        result << word << \" \";\n    }\n\n    std::string result_str = result.str();\n    result_str.pop_back();\n    return result_str;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (int i = 0; i < words.size(); i++) {\n        std::sort(words[i].begin(), words[i].end());\n    }\n\n    std::stringstream result;\n    for (int i = 0; i < words.size(); i++) {\n        result << words[i];\n        if (i != words.size() - 1) {\n            result << \" \";\n        }\n    }\n\n    return result.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::vector<std::string> words;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    for (const auto& word : words) {\n        std::vector<char> chars(word.begin(), word.end());\n        std::sort(chars.begin(), chars.end());\n        result += std::string(chars.begin(), chars.end()) + \" \";\n    }\n\n    result.pop_back();\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n  std::vector<std::string> words;\n  std::string word = \"\";\n  for (char c : s) {\n    if (c == ' ') {\n      words.push_back(word);\n      word = \"\";\n    } else {\n      word += c;\n    }\n  }\n  words.push_back(word);\n  for (auto &w : words) {\n    std::sort(w.begin(), w.end());\n  }\n  std::string result = \"\";\n  for (auto &w : words) {\n    result += w;\n    result += ' ';\n  }\n  result.pop_back();\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words (separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\n// For example:\n// >>> anti_shuffle((\"Hi\"))\n// (\"Hi\")\n// >>> anti_shuffle((\"hello\"))\n// (\"ehllo\")\n// >>> anti_shuffle((\"Hello World!!!\"))\n// (\"Hello !!!Wdlor\")\nstd::string anti_shuffle(std::string s) {\n    std::stringstream ss(s);\n    std::string word;\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    for (auto &word : words) {\n        std::sort(word.begin(), word.end());\n    }\n\n    std::stringstream result;\n    for (const auto &word : words) {\n        result << word << \" \";\n    }\n\n    std::string final_result = result.str();\n    final_result.pop_back();\n    return final_result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); ++i) {\n        for (long j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); ++i) {\n        for (long j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const auto& a, const auto& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return (std::get<0>(a) < std::get<0>(b)) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const auto& a, const auto& b) {\n        return (std::get<0>(a) < std::get<0>(b)) ||\n               ((std::get<0>(a) == std::get<0>(b)) && (std::get<1>(a) > std::get<1>(b)));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); ++i) {\n        for (long j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const auto &a, const auto &b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const auto& a, const auto& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); ++i) {\n        for (long j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return (std::get<0>(a) < std::get<0>(b)) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional data, as a nested vectors,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the vector,\n// and return vector of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})})), (1))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1, 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2, 5), (std::tuple<long, long>)std::make_tuple(2, 0)}))\n// >>> get_row((std::vector<std::vector<long>>()), (1))\n// (std::vector<std::tuple<long, long>>())\n// >>> get_row((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(), (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3})})), (3))\n// (std::vector<std::tuple<long, long>>({(std::tuple<long, long>)std::make_tuple(2, 2)}))\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>> lst, long x) {\n    std::vector<std::tuple<long, long>> result;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n                result.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a) > std::get<1>(b));\n    });\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  if (array.empty())\n    return array;\n  bool is_even = (array[0] + array[array.size() - 1]) % 2 == 0;\n  std::vector<long> sorted_array(array);\n  std::sort(sorted_array.begin(), sorted_array.end());\n  if (is_even)\n    std::reverse(sorted_array.begin(), sorted_array.end());\n  return sorted_array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  if (array.size() == 0)\n    return array;\n  long sum = array[0] + array[array.size() - 1];\n  if (sum % 2 == 0)\n    std::sort(array.begin(), array.end(), std::greater<long>());\n  else\n    std::sort(array.begin(), array.end());\n  return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> sorted_array = array;\n    std::sort(sorted_array.begin(), sorted_array.end());\n    if ((sorted_array[0] + sorted_array[sorted_array.size() - 1]) % 2 == 0) {\n        std::reverse(sorted_array.begin(), sorted_array.end());\n    }\n    return sorted_array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  if (array.empty())\n    return array;\n  std::vector<long> sorted_array(array);\n  std::sort(sorted_array.begin(), sorted_array.end());\n  if ((sorted_array.front() + sorted_array.back()) % 2 == 0)\n    std::reverse(sorted_array.begin(), sorted_array.end());\n  return sorted_array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> result;\n    if (array.size() == 0)\n        return result;\n    if (array.size() == 1)\n        return array;\n\n    bool is_even = (array[0] + array[array.size() - 1]) % 2 == 0;\n\n    if (is_even) {\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    } else {\n        std::sort(array.begin(), array.end());\n    }\n\n    return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  if (array.size() == 0)\n    return array;\n  if ((array[0] + array[array.size() - 1]) % 2 == 0)\n    std::sort(array.begin(), array.end(), std::greater<long>());\n  else\n    std::sort(array.begin(), array.end());\n  return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> result(array);\n    std::sort(result.begin(), result.end());\n    if ((result[0] + result[result.size() - 1]) % 2 == 0) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  if (array.empty())\n    return array;\n  std::vector<long> sorted_array(array);\n  std::sort(sorted_array.begin(), sorted_array.end());\n  if ((sorted_array[0] + sorted_array[sorted_array.size() - 1]) % 2 == 0)\n    std::reverse(sorted_array.begin(), sorted_array.end());\n  return sorted_array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.size() == 0) {\n        return array;\n    }\n\n    if ((array[0] + array[array.size() - 1]) % 2 == 0) {\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    } else {\n        std::sort(array.begin(), array.end());\n    }\n\n    return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> result(array);\n    std::sort(result.begin(), result.end());\n    if ((result[0] + result[result.size() - 1]) % 2 == 0) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.size() == 0)\n        return array;\n\n    std::vector<long> result(array);\n\n    if ((result[0] + result[result.size() - 1]) % 2 == 0)\n        std::sort(result.begin(), result.end(), std::greater<long>());\n    else\n        std::sort(result.begin(), result.end());\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.size() == 0)\n        return array;\n\n    if ((array[0] + array[array.size() - 1]) % 2 == 0)\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    else\n        std::sort(array.begin(), array.end());\n\n    return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  if (array.empty())\n    return array;\n  std::vector<long> result(array);\n  if ((result[0] + result[result.size() - 1]) % 2 == 0)\n    std::sort(result.begin(), result.end(), std::greater<long>());\n  else\n    std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n  if (array.empty())\n    return array;\n  long sum = array[0] + array[array.size() - 1];\n  if (sum % 2 == 0)\n    std::sort(array.begin(), array.end(), std::greater<long>());\n  else\n    std::sort(array.begin(), array.end());\n  return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> result;\n    if (array.empty())\n        return result;\n\n    if ((array[0] + array[array.size() - 1]) % 2 == 0) {\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    } else {\n        std::sort(array.begin(), array.end());\n    }\n\n    return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty())\n        return array;\n\n    long sum = array[0] + array[array.size() - 1];\n\n    if (sum % 2 == 0) {\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    } else {\n        std::sort(array.begin(), array.end());\n    }\n\n    return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> result = array;\n    std::sort(result.begin(), result.end());\n    if ((result[0] + result[result.size() - 1]) % 2 == 0) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> sorted_array = array;\n    std::sort(sorted_array.begin(), sorted_array.end());\n\n    if ((sorted_array[0] + sorted_array[sorted_array.size() - 1]) % 2 == 0) {\n        std::reverse(sorted_array.begin(), sorted_array.end());\n    }\n\n    return sorted_array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    if (array.empty())\n        return array;\n\n    bool is_even = (array[0] + array[array.size() - 1]) % 2 == 0;\n\n    if (is_even)\n        std::sort(array.begin(), array.end(), std::greater<long>());\n    else\n        std::sort(array.begin(), array.end());\n\n    return array;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of non-negative integers, return a cocpp of the given vector after sorting,\n// you will sort the given vector in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given vector.\n// Examples:\n// >>> sort_array((std::vector<long>()))\n// (std::vector<long>())\n// >>> sort_array((std::vector<long>({(long)5})))\n// (std::vector<long>({(long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)2, (long)4, (long)3, (long)0, (long)1, (long)5, (long)6})))\n// (std::vector<long>({(long)6, (long)5, (long)4, (long)3, (long)2, (long)1, (long)0}))\nstd::vector<long> sort_array(std::vector<long> array) {\n    std::vector<long> result = array;\n    std::sort(result.begin(), result.end());\n    if ((result[0] + result[result.size() - 1]) % 2 == 0) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for(char c : s) {\n        if(c >= 'a' && c <= 'z') {\n            encrypted += (c + 2 * 2) % 26 + 'a';\n        }\n        else if(c >= 'A' && c <= 'Z') {\n            encrypted += (c + 2 * 2) % 26 + 'A';\n        }\n        else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c + 4);\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c + 4);\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for(char c : s) {\n        if(c >= 'a' && c <= 'z') {\n            encrypted += (c + 4);\n        }\n        else if(c >= 'A' && c <= 'Z') {\n            encrypted += (c + 4);\n        }\n        else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 2 * 2) % 26 + 'a';\n        }\n        else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 2 * 2) % 26 + 'A';\n        }\n        else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 4) % 26 + 'a';\n        }\n        else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 4) % 26 + 'A';\n        }\n        else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 2 * 2) % 26 + 'a';\n        }\n        else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 2 * 2) % 26 + 'A';\n        }\n        else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for(char c : s) {\n        if(c >= 'a' && c <= 'z') {\n            encrypted += (c + 2 * 2) % 26 + 'a';\n        }\n        else if(c >= 'A' && c <= 'Z') {\n            encrypted += (c + 2 * 2) % 26 + 'A';\n        }\n        else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c + 2 * 2) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 2 * 2) % 26 + 'a';\n        }\n        else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 2 * 2) % 26 + 'A';\n        }\n        else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 2 * 2) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 2 * 2) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c + 2 * 2) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string result;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            result += (c - 'a' + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            result += (c - 'A' + 2 * 2) % 26 + 'A';\n        } else {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 4) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 4) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted_string = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted_string += (c + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted_string += (c + 2 * 2) % 26 + 'A';\n        } else {\n            encrypted_string += c;\n        }\n    }\n    return encrypted_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 2 * 2) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string result;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            result += (c - 'a' + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            result += (c - 'A' + 2 * 2) % 26 + 'A';\n        } else {\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted_string = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted_string += (char)(((c - 'a' + 2 * 2) % 26) + 'a');\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted_string += (char)(((c - 'A' + 2 * 2) % 26) + 'A');\n        } else {\n            encrypted_string += c;\n        }\n    }\n    return encrypted_string;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 4) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 4) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated. \n// The alphabet should be rotated in a manner such that the letters \n// shift down by two multiplied to two places.\n// For example:\n// >>> encrypt((\"hi\"))\n// (\"lm\")\n// >>> encrypt((\"asdfghjkl\"))\n// (\"ewhjklnop\")\n// >>> encrypt((\"gf\"))\n// (\"kj\")\n// >>> encrypt((\"et\"))\n// (\"ix\")\nstd::string encrypt(std::string s) {\n    std::string encrypted = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            encrypted += (c - 'a' + 2 * 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            encrypted += (c - 'A' + 2 * 2) % 26 + 'A';\n        } else {\n            encrypted += c;\n        }\n    }\n    return encrypted;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    long first_smallest = std::numeric_limits<long>::max();\n    long second_smallest = std::numeric_limits<long>::max();\n\n    for (auto x : lst) {\n        if (x < first_smallest) {\n            second_smallest = first_smallest;\n            first_smallest = x;\n        } else if (x < second_smallest && x != first_smallest) {\n            second_smallest = x;\n        }\n    }\n\n    if (second_smallest == std::numeric_limits<long>::max())\n        return std::nullopt;\n\n    return second_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    long first = std::numeric_limits<long>::max();\n    long second = std::numeric_limits<long>::max();\n\n    for (long i : lst) {\n        if (i < first) {\n            second = first;\n            first = i;\n        } else if (i < second && i != first) {\n            second = i;\n        }\n    }\n\n    if (second == std::numeric_limits<long>::max())\n        return std::nullopt;\n\n    return second;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    long smallest = lst[0];\n    long second_smallest = std::numeric_limits<long>::max();\n\n    for (long i : lst) {\n        if (i < smallest) {\n            second_smallest = smallest;\n            smallest = i;\n        } else if (i < second_smallest && i != smallest) {\n            second_smallest = i;\n        }\n    }\n\n    if (second_smallest == std::numeric_limits<long>::max()) {\n        return std::nullopt;\n    }\n\n    return second_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2) {\n    return std::nullopt;\n  }\n  long first = std::numeric_limits<long>::max();\n  long second = std::numeric_limits<long>::max();\n  for (long x : lst) {\n    if (x < first) {\n      second = first;\n      first = x;\n    } else if (x < second && x != first) {\n      second = x;\n    }\n  }\n  if (second == std::numeric_limits<long>::max()) {\n    return std::nullopt;\n  }\n  return second;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2)\n    return std::nullopt;\n  std::sort(lst.begin(), lst.end());\n  auto it = std::unique(lst.begin(), lst.end());\n  lst.resize(std::distance(lst.begin(), it));\n  if (lst.size() < 2)\n    return std::nullopt;\n  return lst[1];", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    std::sort(lst.begin(), lst.end());\n\n    long smallest = lst[0];\n    long next_smallest = lst[1];\n\n    if (next_smallest == smallest)\n        return std::nullopt;\n\n    return next_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    long first = std::numeric_limits<long>::max();\n    long second = std::numeric_limits<long>::max();\n\n    for (long x : lst) {\n        if (x < first) {\n            second = first;\n            first = x;\n        } else if (x < second && x != first) {\n            second = x;\n        }\n    }\n\n    if (second == std::numeric_limits<long>::max())\n        return std::nullopt;\n\n    return second;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    std::sort(lst.begin(), lst.end());\n\n    long first = lst[0];\n    long second = lst[1];\n\n    if (first == second)\n        return std::nullopt;\n\n    return second;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    long first_smallest = std::numeric_limits<long>::max();\n    long second_smallest = std::numeric_limits<long>::max();\n\n    for (long num : lst) {\n        if (num < first_smallest) {\n            second_smallest = first_smallest;\n            first_smallest = num;\n        } else if (num < second_smallest && num != first_smallest) {\n            second_smallest = num;\n        }\n    }\n\n    if (second_smallest == std::numeric_limits<long>::max()) {\n        return std::nullopt;\n    }\n\n    return second_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n  if (lst.size() < 2)\n    return std::nullopt;\n  std::sort(lst.begin(), lst.end());\n  return lst[1];", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    std::sort(lst.begin(), lst.end());\n\n    long smallest = lst[0];\n    long next_smallest = lst[1];\n\n    if (next_smallest == smallest) {\n        return std::nullopt;\n    }\n\n    return next_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    long first = std::numeric_limits<long>::max();\n    long second = std::numeric_limits<long>::max();\n\n    for (long num : lst) {\n        if (num < first) {\n            second = first;\n            first = num;\n        } else if (num < second && num != first) {\n            second = num;\n        }\n    }\n\n    if (second == std::numeric_limits<long>::max())\n        return std::nullopt;\n\n    return second;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    std::sort(lst.begin(), lst.end());\n\n    long first = lst[0];\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] != first)\n            return lst[i];\n    }\n\n    return std::nullopt;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    long smallest = std::numeric_limits<long>::max();\n    long second_smallest = std::numeric_limits<long>::max();\n\n    for (long num : lst) {\n        if (num < smallest) {\n            second_smallest = smallest;\n            smallest = num;\n        } else if (num < second_smallest && num != smallest) {\n            second_smallest = num;\n        }\n    }\n\n    if (second_smallest == std::numeric_limits<long>::max()) {\n        return std::nullopt;\n    }\n\n    return second_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    std::sort(lst.begin(), lst.end());\n\n    long smallest = lst[0];\n    long next_smallest = lst[1];\n\n    if (next_smallest == smallest)\n        return std::nullopt;\n\n    return next_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    long first = lst[0], second = std::numeric_limits<long>::max();\n    for (long i : lst) {\n        if (i < first) {\n            second = first;\n            first = i;\n        } else if (i < second && i != first) {\n            second = i;\n        }\n    }\n\n    if (second == std::numeric_limits<long>::max())\n        return std::nullopt;\n\n    return second;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2) {\n        return std::nullopt;\n    }\n\n    long first_smallest = std::numeric_limits<long>::max();\n    long second_smallest = std::numeric_limits<long>::max();\n\n    for (long num : lst) {\n        if (num < first_smallest) {\n            second_smallest = first_smallest;\n            first_smallest = num;\n        } else if (num < second_smallest && num != first_smallest) {\n            second_smallest = num;\n        }\n    }\n\n    if (second_smallest == std::numeric_limits<long>::max()) {\n        return std::nullopt;\n    }\n\n    return second_smallest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    std::sort(lst.begin(), lst.end());\n\n    auto it = std::unique(lst.begin(), lst.end());\n    lst.resize(std::distance(lst.begin(), it));\n\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    return lst[1];", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    long first = std::numeric_limits<long>::max();\n    long second = std::numeric_limits<long>::max();\n\n    for (long i : lst) {\n        if (i < first) {\n            second = first;\n            first = i;\n        } else if (i < second && i != first) {\n            second = i;\n        }\n    }\n\n    if (second == std::numeric_limits<long>::max())\n        return std::nullopt;\n\n    return second;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// Write a function next_smallest() that returns the 2nd smallest element of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5, (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n// std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n// std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n    if (lst.size() < 2)\n        return std::nullopt;\n\n    long first = std::numeric_limits<long>::max();\n    long second = std::numeric_limits<long>::max();\n\n    for (long i : lst) {\n        if (i < first) {\n            second = first;\n            first = i;\n        } else if (i < second && i != first) {\n            second = i;\n        }\n    }\n\n    if (second == std::numeric_limits<long>::max())\n        return std::nullopt;\n\n    return second;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::istringstream iss(S);\n    std::string word;\n    long count = 0;\n    while (iss >> word) {\n        if (word[0] == 'I') {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::stringstream ss(S);\n    std::string word;\n    while (std::getline(ss, word, '.')) {\n        if (word.find(\"I\") == 0)\n            count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    long count = 0;\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n        if (word3.substr(0, 1) == \"I\") {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    long count = 0;\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n        std::istringstream iss(word3);\n        std::string word4;\n        while (iss >> word4) {\n            if (word4 == \"I\") {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::istringstream iss(S);\n    std::string word;\n    long count = 0;\n    while (iss >> word) {\n        if (word == \"I\") {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::stringstream ss(S);\n    std::string word;\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n        std::istringstream iss(word3);\n        std::string word4;\n        while (iss >> word4) {\n            if (word4 == \"I\") {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::stringstream ss(S);\n    std::string word;\n\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n\n        if (std::getline(ss2, word2, '?')) {\n            std::stringstream ss3(word2);\n            std::string word3;\n\n            if (std::getline(ss3, word3, '!')) {\n                std::stringstream ss4(word3);\n                std::string word4;\n\n                while (std::getline(ss4, word4, ' ')) {\n                    if (word4 == \"I\") {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::stringstream ss(S);\n    std::string word;\n    while (std::getline(ss, word, '.')) {\n        if (word.empty())\n            continue;\n        std::stringstream ss2(word);\n        std::string w;\n        if (std::getline(ss2, w, '?')) {\n            if (w.empty())\n                continue;\n            std::stringstream ss3(w);\n            std::string w2;\n            if (std::getline(ss3, w2, '!')) {\n                if (w2.empty())\n                    continue;\n                if (w2[0] == 'I')\n                    count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::stringstream ss(S);\n    std::string word;\n    while (std::getline(ss, word, '.')) {\n        if (word.empty())\n            continue;\n        std::stringstream ss2(word);\n        std::string w;\n        std::getline(ss2, w, ' ');\n        if (w == \"I\")\n            count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    long count = 0;\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n        std::istringstream iss(word3);\n        std::string word4;\n        while (iss >> word4) {\n            if (word4 == \"I\") {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::istringstream iss(S);\n    std::string word;\n    while (iss >> word) {\n        if (word == \"I\") {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::istringstream iss(S);\n    std::string word;\n    long count = 0;\n    while (iss >> word) {\n        if (word == \"I\") {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::istringstream iss(S);\n    std::string word;\n    long count = 0;\n    while (iss >> word) {\n        if (word == \"I\") {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    long count = 0;\n    while (std::getline(ss, word, '.')) {\n        if (word.empty())\n            continue;\n        std::stringstream ss2(word);\n        std::string w;\n        std::getline(ss2, w, ' ');\n        if (w == \"I\")\n            count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    long count = 0;\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n        std::istringstream iss(word3);\n        std::string word4;\n        while (iss >> word4) {\n            if (word4 == \"I\") {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    long count = 0;\n\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n\n        std::transform(word3.begin(), word3.end(), word3.begin(), ::tolower);\n\n        std::istringstream iss(word3);\n        std::string token;\n        if (std::getline(iss, token, ' ')) {\n            if (token == \"i\") {\n                count++;\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::istringstream iss(S);\n    std::string word;\n    long boredom_count = 0;\n    while (iss >> word) {\n        if (word == \"I\") {\n            boredom_count++;\n        }\n    }\n    return boredom_count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    std::stringstream ss(S);\n    std::string word;\n    long count = 0;\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n        if (word3.substr(0, 1) == \"I\") {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::stringstream ss(S);\n    std::string word;\n\n    while (std::getline(ss, word, '.')) {\n        std::stringstream ss2(word);\n        std::string word2;\n        std::getline(ss2, word2, '?');\n        std::stringstream ss3(word2);\n        std::string word3;\n        std::getline(ss3, word3, '!');\n        if (word3.size() > 0 && word3[0] == 'I') {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You'll be given a string of words, and your task is to count the number\n// of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored((\"Hello world\"))\n// (0)\n// >>> is_bored((\"The sky is blue. The sun is shining. I love this weather\"))\n// (1)\nlong is_bored(std::string S) {\n    long count = 0;\n    std::stringstream ss(S);\n    std::string word;\n    while (std::getline(ss, word, '.')) {\n        if (word.empty())\n            continue;\n        std::stringstream ss2(word);\n        std::string first_word;\n        std::getline(ss2, first_word, ' ');\n        if (first_word == \"I\")\n            count++;\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    // Check if all numbers are integers\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        // Check if one of the numbers is equal to the sum of the other two\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if(x == (int)x && y == (int)y && z == (int)z) {\n        if(x == y + z || y == x + z || z == x + y)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    // Check if all numbers are integers\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        // Check if one of the numbers is equal to the sum of the other two\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    // Check if all numbers are integers\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        // Check if one of the numbers is equal to the sum of the other two\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  // Check if all numbers are integers\n  if (x == (int)x && y == (int)y && z == (int)z) {\n    // Check if one of the numbers is equal to the sum of the other two\n    if (x == y + z || y == x + z || z == x + y) {\n      return true;\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  // Check if all numbers are integers\n  if (x == (int)x && y == (int)y && z == (int)z) {\n    // Check if one of the numbers is equal to the sum of the other two\n    if (x == y + z || y == x + z || z == x + y) {\n      return true;\n    }\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    // Check if all numbers are integers\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        // Check if one of the numbers is equal to the sum of the other two\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        if (x == y + z || y == x + z || z == x + y)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    // Check if all numbers are integers\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        // Check if one of the numbers is equal to the sum of the other two\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    // Check if all numbers are integers\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        // Check if one of the numbers is equal to the sum of the other two\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n  int a = (int)x;\n  int b = (int)y;\n  int c = (int)z;\n  if (a == b + c || b == a + c || c == a + b)\n    return true;\n  else\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        if (x == y + z || y == x + z || z == x + y)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        if (x == y + z || y == x + z || z == x + y)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == round(x) && y == round(y) && z == round(z)) {\n        if (x == y + z || y == x + z || z == x + y)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == round(x) && y == round(y) && z == round(z)) {\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        if (x == y + z || y == x + z || z == x + y)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\n// Examples\n// >>> any_int((float(5)), (float(2)), (float(7)))\n// (true)\n// >>> any_int((float(3)), (float(2)), (float(2)))\n// (false)\n// >>> any_int((float(3)), (float(-2)), (float(1)))\n// (true)\n// >>> any_int((3.6f), (-2.2f), (float(2)))\n// (false)\nbool any_int(float x, float y, float z) {\n    // Check if all numbers are integers\n    if (x == (int)x && y == (int)y && z == (int)z) {\n        // Check if one of the numbers is equal to the sum of the other two\n        if (x == y + z || y == x + z || z == x + y) {\n            return true;\n        }\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c) : (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? c - ' ' : c + ' ') : (c >= 'A' && c <= 'Z' ? c + ' ' : c - ' ');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for(char c : message) {\n        if(vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? (c - 'A' + 'a') : c) : (c - 'a' + 'A');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c) : (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'A' && c <= 'Z') ? (c + 32) : (c - 32);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'A' && c <= 'Z') ? (c + 32) : (c - 32);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'A' && c <= 'Z') ? (c + 32) : (c - 32);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? (c + 2) % 26 + 'a' : (c + 2) % 26 + 'A';\n        }\n        c = (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c) : (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n        result += c;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? (c - 'A' + 'a') : c) : (c >= 'a' && c <= 'z' ? (c - 'a' + 'A') : c);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c ^ 32) : c;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? (c + 2) % 26 + 'a' : (c + 2) % 26 + 'A';\n        }\n        c = (c >= 'a' && c <= 'z') ? c ^ 32 : c;\n        result += c;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'A' && c <= 'Z') ? (c + 32) : (c - 32);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c ^ ('a' ^ 'A')) : c;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c ^ ('a' ^ 'A')) : c;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? (c + 2) % 26 + 'a' : (c + 2) % 26 + 'A';\n        }\n        c = (c >= 'a' && c <= 'z') ? c ^ 32 : c;\n        result += c;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for(char c : message) {\n        if(vowels.find(c) != std::string::npos) {\n            if(isupper(c)) {\n                result += (char)((c - 'A' + 2) % 26 + 'A');\n            } else {\n                result += (char)((c - 'a' + 2) % 26 + 'a');\n            }\n        } else {\n            result += (isupper(c) ? toupper(c) : tolower(c));\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c ^ 0x20) : (c ^ 0x20);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? ((c - 'a' + 2) % 26 + 'a') : ((c - 'A' + 2) % 26 + 'A');\n        }\n        result += (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? (c - 'A' + 'a') : c) : (c >= 'a' && c <= 'z' ? (c - 'a' + 'A') : c);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? (c + 2) % 26 + 'a' : (c + 2) % 26 + 'A';\n        }\n        result += (c >= 'A' && c <= 'Z') ? (c >= 'A' && c <= 'Z') ? (c - 'A' + 'a') : (c - 'A' + 'A');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a message, and encodes in such a \n// way that it swaps case of all letters, replaces all vowels in \n// the message with the letter that appears 2 places ahead of that \n// vowel in the english alphabet. \n// Assume only letters. \n// Examples:\n// >>> encode((\"test\"))\n// (\"TGST\")\n// >>> encode((\"This is a message\"))\n// (\"tHKS KS C MGSSCGG\")\nstd::string encode(std::string message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (vowels.find(c) != std::string::npos) {\n            c = (c >= 'a' && c <= 'z') ? (c + 2) % 26 + 'a' : (c + 2) % 26 + 'A';\n        }\n        c = (c >= 'a' && c <= 'z') ? (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c) : (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n        result += c;\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for(long i: lst) {\n        if(i > max_prime && is_prime(i)) {\n            max_prime = i;\n        }\n    }\n    long sum = 0;\n    while(max_prime) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long i : lst) {\n        if (i > max_prime && is_prime(i)) {\n            max_prime = i;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for(long i: lst) {\n        if(i > max_prime && isPrime(i)) {\n            max_prime = i;\n        }\n    }\n\n    long sum = 0;\n    while(max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n    long sum = 0;\n    while (max_prime) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n    return sum_of_digits(max_prime);", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long i : lst) {\n        if (i > max_prime && is_prime(i)) {\n            max_prime = i;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && isPrime(num)) {\n            max_prime = num;\n        }\n    }\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for(long i : lst) {\n        if(i > max_prime && is_prime(i)) {\n            max_prime = i;\n        }\n    }\n\n    long sum = 0;\n    while(max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && isPrime(num)) {\n            max_prime = num;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long i : lst) {\n        if (i > max_prime && is_prime(i)) {\n            max_prime = i;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (auto num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long i : lst) {\n        if (i > max_prime && is_prime(i)) {\n            max_prime = i;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime > 0) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n    long sum = 0;\n    while (max_prime) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long maxPrime = 0;\n    for (long num : lst) {\n        if (num > maxPrime && isPrime(num)) {\n            maxPrime = num;\n        }\n    }\n\n    long sum = 0;\n    while (maxPrime > 0) {\n        sum += maxPrime % 10;\n        maxPrime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (long i : lst) {\n        if (i > max_prime && is_prime(i)) {\n            max_prime = i;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\n// Examples:\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)3, (long)2, (long)1, (long)3, (long)5, (long)7, (long)4, (long)5, (long)5, (long)5, (long)2, (long)181, (long)32, (long)4, (long)32, (long)3, (long)2, (long)32, (long)324, (long)4, (long)3})))\n// (10)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)0, (long)1, (long)8, (long)2, (long)4597, (long)2, (long)1, (long)3, (long)40, (long)1, (long)2, (long)1, (long)2, (long)4, (long)2, (long)5, (long)1})))\n// (25)\n// >>> skjkasdkd((std::vector<long>({(long)1, (long)3, (long)1, (long)32, (long)5107, (long)34, (long)83278, (long)109, (long)163, (long)23, (long)2323, (long)32, (long)30, (long)1, (long)9, (long)3})))\n// (13)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)724, (long)32, (long)71, (long)99, (long)32, (long)6, (long)0, (long)5, (long)91, (long)83, (long)0, (long)5, (long)6})))\n// (11)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)81, (long)12, (long)3, (long)1, (long)21})))\n// (3)\n// >>> skjkasdkd((std::vector<long>({(long)0, (long)8, (long)1, (long)2, (long)1, (long)7})))\n// (7)\nlong skjkasdkd(std::vector<long> lst) {\n    long max_prime = 0;\n    for (auto num : lst) {\n        if (num > max_prime && is_prime(num)) {\n            max_prime = num;\n        }\n    }\n\n    long sum = 0;\n    while (max_prime) {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if(dict.empty())\n        return false;\n\n    bool is_lower = true;\n    bool is_upper = true;\n\n    for(auto& it: dict) {\n        if(is_lower && !std::all_of(it.first.begin(), it.first.end(), ::islower))\n            is_lower = false;\n\n        if(is_upper && !std::all_of(it.first.begin(), it.first.end(), ::isupper))\n            is_upper = false;\n\n        if(!is_lower && !is_upper)\n            return false;\n    }\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = true;\n    bool is_upper = true;\n\n    for (auto& key : dict) {\n        if (key.first != key.first.lower() && key.first != key.first.upper())\n            return false;\n\n        is_lower = is_lower && (key.first == key.first.lower());\n        is_upper = is_upper && (key.first == key.first.upper());\n    }\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n  if (dict.empty())\n    return false;\n  bool is_lower = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n    return std::all_of(pair.first.begin(), pair.first.end(), ::islower);\n  });\n  bool is_upper = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n    return std::all_of(pair.first.begin(), pair.first.end(), ::isupper);\n  });\n  return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if(dict.empty())\n        return false;\n\n    bool is_lower = true;\n    bool is_upper = true;\n\n    for(auto& key : dict) {\n        if(key.first != key.first.lower())\n            is_lower = false;\n        if(key.first != key.first.upper())\n            is_upper = false;\n    }\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const auto& pair) {\n        return std::all_of(pair.first.begin(), pair.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if(dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p){\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p){\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::islower);\n    });\n\n    bool is_upper = std::all_of(dict.begin(), dict.end(), [](const std::pair<std::string, std::string>& p) {\n        return std::all_of(p.first.begin(), p.first.end(), ::isupper);\n    });\n\n    return is_lower || is_upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a map, return true if all keys are strings in lower \n// case or all keys are strings in upper case, else return false.\n// The function should return false is the given map is empty.\n// Examples:\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"b\", \"banana\"}})))\n// (true)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {\"A\", \"banana\"}, {\"B\", \"banana\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"a\", \"apple\"}, {8, \"banana\"}, {\"a\", \"apple\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"Name\", \"John\"}, {\"Age\", \"36\"}, {\"City\", \"Houston\"}})))\n// (false)\n// >>> check_dict_case((std::map<std::string,std::string>({{\"STATE\", \"NC\"}, {\"ZIP\", \"12345\"}})))\n// (true)\nbool check_dict_case(std::map<std::string,std::string> dict) {\n    if (dict.empty())\n        return false;\n\n    bool is_lower = true;\n    bool is_upper = true;\n\n    for (auto& key : dict) {\n        if (key.first != key.first.lower())\n            is_lower = false;\n        if (key.first != key.first.upper())\n            is_upper = false;\n    }\n\n    return is_lower || is_upper;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n\n    for (long p = 2; p <= n; p++) {\n        if (is_prime[p])\n            primes.push_back(p);\n    }\n\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2)\n    return primes;\n  bool isPrime[n];\n  memset(isPrime, true, sizeof(isPrime));\n  for (long p = 2; p * p <= n; p++) {\n    if (isPrime[p]) {\n      for (long i = p * p; i <= n; i += p)\n        isPrime[i] = false;\n    }\n  }\n  for (long p = 2; p <= n; p++) {\n    if (isPrime[p])\n      primes.push_back(p);\n  }\n  return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n    for (long p = 2; p <= n; p++) {\n        if (is_prime[p])\n            primes.push_back(p);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2)\n    return primes;\n  bool prime[n];\n  memset(prime, true, sizeof(prime));\n  for (long p = 2; p * p <= n; p++) {\n    if (prime[p]) {\n      for (long i = p * p; i <= n; i += p)\n        prime[i] = false;\n    }\n  }\n  for (long p = 2; p <= n; p++) {\n    if (prime[p])\n      primes.push_back(p);\n  }\n  return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2)\n    return primes;\n  for (long i = 2; i < n; i++) {\n    bool is_prime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime)\n      primes.push_back(i);\n  }\n  return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n    for (long p = 2; p <= n; p++) {\n        if (is_prime[p])\n            primes.push_back(p);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n    for (long p = 2; p <= n; p++) {\n        if (is_prime[p])\n            primes.push_back(p);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n\n    for (long i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (long j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (long i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n    for (long i = 2; i < n; i++) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2)\n    return primes;\n  for (long i = 2; i < n; i++) {\n    bool is_prime = true;\n    for (long j = 2; j * j <= i; j++) {\n      if (i % j == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime)\n      primes.push_back(i);\n  }\n  return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n    for (long p = 2; p <= n; p++) {\n        if (is_prime[p])\n            primes.push_back(p);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n\n    for (long i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (long j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (long i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (long i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (long j = i * i; j < n; j += i)\n                is_prime[j] = false;\n        }\n    }\n    for (long i = 2; i < n; i++) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 1)\n        return primes;\n\n    bool is_prime[n + 1];\n    memset(is_prime, true, sizeof(is_prime));\n\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n\n    for (long p = 2; p <= n; p++) {\n        if (is_prime[p])\n            primes.push_back(p);\n    }\n\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n    for (long i = 2; i < n; i++) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    bool is_prime[n];\n    memset(is_prime, true, sizeof(is_prime));\n    for (long p = 2; p * p < n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i < n; i += p)\n                is_prime[i] = false;\n        }\n    }\n    for (long p = 2; p < n; p++) {\n        if (is_prime[p])\n            primes.push_back(p);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 2)\n        return primes;\n    for (long i = 2; i < n; i++) {\n        bool is_prime = true;\n        for (long j = 2; j * j <= i; j++) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime)\n            primes.push_back(i);\n    }\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 1)\n        return primes;\n\n    std::vector<bool> is_prime(n + 1, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n\n    for (long p = 2; p * p <= n; p++) {\n        if (is_prime[p]) {\n            for (long i = p * p; i <= n; i += p)\n                is_prime[i] = false;\n        }\n    }\n\n    for (long i = 2; i <= n; i++) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n    std::vector<long> primes;\n    if (n <= 1)\n        return primes;\n\n    bool isPrime[n+1];\n    memset(isPrime, true, sizeof(isPrime));\n\n    for (long p = 2; p*p <= n; p++) {\n        if (isPrime[p] == true) {\n            for (long i = p*p; i <= n; i += p)\n                isPrime[i] = false;\n        }\n    }\n\n    for (long p = 2; p <= n; p++)\n        if (isPrime[p])\n            primes.push_back(p);\n\n    return primes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement a function that takes an non-negative integer and returns a vector of the first n\n// integers that are prime numbers and less than n.\n// for example:\n// >>> count_up_to((5))\n// (std::vector<long>({(long)2, (long)3}))\n// >>> count_up_to((11))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7}))\n// >>> count_up_to((0))\n// (std::vector<long>())\n// >>> count_up_to((20))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17, (long)19}))\n// >>> count_up_to((1))\n// (std::vector<long>())\n// >>> count_up_to((18))\n// (std::vector<long>({(long)2, (long)3, (long)5, (long)7, (long)11, (long)13, (long)17}))\nstd::vector<long> count_up_to(long n) {\n  std::vector<long> primes;\n  if (n <= 2)\n    return primes;\n  bool is_prime[n];\n  memset(is_prime, true, sizeof(is_prime));\n  for (long p = 2; p * p <= n; p++) {\n    if (is_prime[p]) {\n      for (long i = p * p; i <= n; i += p)\n        is_prime[i] = false;\n    }\n  }\n  for (long p = 2; p <= n; p++) {\n    if (is_prime[p])\n      primes.push_back(p);\n  }\n  return primes;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long result = 0;\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    result = unit_digit_a * unit_digit_b;\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    return unit_digit_a * unit_digit_b;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long product = (a % 10) * (b % 10);\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long a_unit = a % 10;\n    long b_unit = b % 10;\n    return a_unit * b_unit;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long result = 0;\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    result = unit_digit_a * unit_digit_b;\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long result = (a % 10) * (b % 10);\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long result = 0;\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    result = unit_digit_a * unit_digit_b;\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long product = (a % 10) * (b % 10);\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long a_unit = a % 10;\n    long b_unit = b % 10;\n    return a_unit * b_unit;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long a_unit = a % 10;\n    long b_unit = b % 10;\n    return a_unit * b_unit;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long result = (a % 10) * (b % 10);\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long product = 0;\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    product = unit_digit_a * unit_digit_b;\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long result = (a % 10) * (b % 10);\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    return (a % 10) * (b % 10);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long a_unit = a % 10;\n    long b_unit = b % 10;\n    return a_unit * b_unit;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long product = (a % 10) * (b % 10);\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long product = 0;\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    product = unit_digit_a * unit_digit_b;\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long product = (a % 10) * (b % 10);\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long result = 0;\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    result = unit_digit_a * unit_digit_b;\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Complete the function that takes two integers and returns \n// the product of their unit digits.\n// Assume the input is always valid.\n// Examples:\n// >>> multiply((148), (412))\n// (16)\n// >>> multiply((19), (28))\n// (72)\n// >>> multiply((2020), (1851))\n// (0)\n// >>> multiply((14), (-15))\n// (20)\nlong multiply(long a, long b) {\n    long product = 0;\n    long unit_digit_a = a % 10;\n    long unit_digit_b = b % 10;\n    product = unit_digit_a * unit_digit_b;\n    return product;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.size(); i += 2) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n        count++;\n      }\n    }\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (long i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count += 1;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (size_t i = 0; i < s.size(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (long i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n      count++;\n    }\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (long i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (int i = 0; i < s.length(); i += 2) {\n    char c = s[i];\n    if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n      count++;\n    }\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n  long count = 0;\n  for (size_t i = 0; i < s.size(); i += 2) {\n    if (s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n      count++;\n    }\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// >>> count_upper((\"aBCdEf\"))\n// (1)\n// >>> count_upper((\"abcdefg\"))\n// (0)\n// >>> count_upper((\"dBBE\"))\n// (0)\nlong count_upper(std::string s) {\n    long count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    std::stringstream ss(value);\n    double num;\n    ss >> num;\n    long rounded = (long)num;\n    if (num - rounded > 0.5) {\n        rounded += 1;\n    }\n    if (num - rounded == 0.5 && rounded > 0) {\n        rounded += 1;\n    }\n    if (num - rounded == 0.5 && rounded < 0) {\n        rounded -= 1;\n    }\n    return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double num;\n  iss >> num;\n  long rounded = lround(num);\n  if (num - rounded == 0.5) {\n    if (rounded == 0)\n      return 1;\n    else if (rounded > 0)\n      return rounded + 1;\n    else\n      return rounded - 1;\n  }\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    std::istringstream iss(value);\n    double number;\n    iss >> number;\n    long rounded = std::round(number);\n    if (number - rounded == 0.5) {\n        if (rounded == 0) {\n            return 1;\n        }\n        return rounded + (rounded > 0 ? 1 : -1);\n    }\n    return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double num;\n  iss >> num;\n  long rounded = lround(num);\n  if (num - rounded == 0.5) {\n    if (rounded == 0) {\n      return 1;\n    }\n    return rounded + (rounded < 0 ? -1 : 1);\n  }\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    std::istringstream iss(value);\n    double num;\n    iss >> num;\n    long rounded = lround(num);\n    if (num - rounded == 0.5) {\n        if (rounded == 0)\n            return 1;\n        else\n            return rounded + (rounded > 0 ? 1 : -1);\n    }\n    return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::stringstream ss(value);\n  double num;\n  ss >> num;\n  long rounded = std::round(num);\n  if (num - rounded == 0.5) {\n    if (rounded == 0)\n      return 1;\n    else\n      return rounded + (rounded < 0 ? -1 : 1);\n  }\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    double num = std::stod(value);\n    long rounded = std::round(num);\n    if (num - rounded == 0.5) {\n        if (rounded == 0) {\n            return 1;\n        }\n        return rounded + (rounded > 0 ? 1 : -1);\n    }\n    return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    std::istringstream iss(value);\n    double number;\n    iss >> number;\n    long rounded = std::round(number);\n    if (number < 0 && rounded != number) {\n        rounded -= 1;\n    }\n    return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double number;\n  iss >> number;\n  long lower = static_cast<long>(std::floor(number));\n  long upper = static_cast<long>(std::ceil(number));\n  long closest;\n  if (number - lower >= upper - number) {\n    closest = upper;\n  } else {\n    closest = lower;\n  }\n  return closest;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    std::istringstream iss(value);\n    double number;\n    iss >> number;\n\n    long lower = static_cast<long>(std::floor(number));\n    long upper = static_cast<long>(std::ceil(number));\n\n    if (number - lower <= upper - number)\n        return lower;\n    else\n        return upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double num;\n  iss >> num;\n  long rounded = (long)num;\n  if (num - rounded > 0.5) {\n    rounded++;\n  }\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long rounded = std::round(num);\n  if (num - rounded == 0.5) {\n    return rounded + (num > 0 ? 1 : -1);\n  }\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double num;\n  iss >> num;\n  long rounded = lround(num);\n  if (num - rounded == 0.5) {\n    if (rounded == 0)\n      return 1;\n    else if (rounded > 0)\n      return rounded + 1;\n    else\n      return rounded - 1;\n  }\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    std::istringstream iss(value);\n    double number;\n    iss >> number;\n    long long_number = static_cast<long>(number);\n    if (number > 0) {\n        if (number - long_number >= 0.5) {\n            long_number++;\n        }\n    }\n    else {\n        if (long_number - number >= 0.5) {\n            long_number--;\n        }\n    }\n    return long_number;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::stringstream ss(value);\n  double num;\n  ss >> num;\n  long rounded = std::round(num);\n  if (num - rounded == 0.5) {\n    if (rounded > 0) {\n      rounded += 1;\n    } else {\n      rounded -= 1;\n    }\n  }\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    std::istringstream iss(value);\n    double num;\n    iss >> num;\n    long rounded = std::round(num);\n    if (num - rounded == 0.5) {\n        if (rounded > 0) {\n            rounded += 1;\n        } else {\n            rounded -= 1;\n        }\n    }\n    return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double number;\n  iss >> number;\n  long lower = static_cast<long>(number);\n  long upper = static_cast<long>(std::ceil(number));\n  long lower_diff = std::abs(number - lower);\n  long upper_diff = std::abs(number - upper);\n  if (lower_diff < upper_diff)\n    return lower;\n  else\n    return upper;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double number;\n  iss >> number;\n  long integer_part = static_cast<long>(number);\n  double fractional_part = number - integer_part;\n  if (fractional_part >= 0.5) {\n    if (number >= 0) {\n      integer_part++;\n    } else {\n      integer_part--;\n    }\n  }\n  return integer_part;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  std::istringstream iss(value);\n  double number;\n  iss >> number;\n  long rounded = lround(number);\n  if (number < 0 && rounded > number)\n    rounded--;\n  else if (number > 0 && rounded < number)\n    rounded++;\n  return rounded;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n  double num = std::stod(value);\n  long rounded = std::round(num);\n  if (num > 0 && num - rounded > 0.5) {\n    return rounded + 1;\n  }\n  if (num < 0 && rounded - num > 0.5) {\n    return rounded - 1;\n  }\n  return rounded;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> stones;\n    for (long i = 0; i < n; i++) {\n        stones.push_back(n + 2 * i);\n    }\n    return stones;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while(n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? (n + 1) : (n + 2);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> result;\n  while (n > 0) {\n    result.push_back(n);\n    n = (n % 2 == 0) ? n + 1 : n + 2;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n += (n % 2 == 0) ? 1 : 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> stones;\n    for (long i = 0; i < n; i++) {\n        stones.push_back(n + 2 * i);\n    }\n    return stones;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n += (n % 2 == 0) ? 1 : 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> result;\n  while (n > 0) {\n    result.push_back(n);\n    n = (n % 2 == 0) ? n + 1 : n + 2;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while(n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while(n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while(n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? (n + 1) : (n + 2);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> result;\n  while (n > 0) {\n    result.push_back(n);\n    n = (n % 2 == 0) ? (n + 1) : (n + 2);\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? (n + 1) : (n + 2);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while(n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? (n + 1) : (n + 2);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n  std::vector<long> result;\n  while (n > 0) {\n    result.push_back(n);\n    n = (n % 2 == 0) ? (n + 1) : (n + 2);\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> result;\n    while (n > 0) {\n        result.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a vector, where element at index\n// i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile((3))\n// (std::vector<long>({(long)3, (long)5, (long)7}))\nstd::vector<long> make_a_pile(long n) {\n    std::vector<long> res;\n    while (n > 0) {\n        res.push_back(n);\n        n = (n % 2 == 0) ? n + 1 : n + 2;\n    }\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  for (char c : s) {\n    if (c == ' ' || c == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word.clear();\n      }\n    } else {\n      word += c;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  for (char c : s) {\n    if (c == ' ' || c == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word.clear();\n      }\n    } else {\n      word += c;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  for (char c : s) {\n    if (c == ' ' || c == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word.clear();\n      }\n    } else {\n      word += c;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (word != \"\") {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (word != \"\") {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (word != \"\") {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (word != \"\") {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word = \"\";\n  for (int i = 0; i < s.length(); i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (word != \"\") {\n        words.push_back(word);\n        word = \"\";\n      }\n    } else {\n      word += s[i];\n    }\n  }\n  if (word != \"\") {\n    words.push_back(word);\n  }\n  return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word = \"\";\n  for (char c : s) {\n    if (c == ' ' || c == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word = \"\";\n      }\n    } else {\n      word += c;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word = \"\";\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n  std::vector<std::string> words;\n  std::string word;\n  for (char c : s) {\n    if (c == ' ' || c == ',') {\n      if (!word.empty()) {\n        words.push_back(word);\n        word.clear();\n      }\n    } else {\n      word += c;\n    }\n  }\n  if (!word.empty()) {\n    words.push_back(word);\n  }\n  return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return a vector of the words.\n// For example:\n// >>> words_string((\"Hi, my name is John\"))\n// (std::vector<std::string>({(std::string)\"Hi\", (std::string)\"my\", (std::string)\"name\", (std::string)\"is\", (std::string)\"John\"}))\n// >>> words_string((\"One, two, three, four, five, six\"))\n// (std::vector<std::string>({(std::string)\"One\", (std::string)\"two\", (std::string)\"three\", (std::string)\"four\", (std::string)\"five\", (std::string)\"six\"}))\nstd::vector<std::string> words_string(std::string s) {\n    std::vector<std::string> words;\n    std::string word;\n    for (char c : s) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                words.push_back(word);\n                word.clear();\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        words.push_back(word);\n    }\n    return words;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x += 1;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    if (y % 2 == 0) {\n        return y;\n    }\n    if (y - x <= 2) {\n        return -1;\n    }\n    return y - 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 != 0) {\n        x++;\n    }\n    if (y % 2 != 0) {\n        y--;\n    }\n    if (x > y) {\n        return -1;\n    }\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    // Check if x is even, if not increment it by 1\n    if(x % 2 != 0)\n        x++;\n\n    // Check if y is even, if not decrement it by 1\n    if(y % 2 != 0)\n        y--;\n\n    // If x is greater than y, return -1\n    if(x > y)\n        return -1;\n\n    // Return the biggest even number in the range [x, y]\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x += 1;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    // Write your code here\n    if(x%2==0)\n    {\n        if(x>=y)\n        return x;\n        else\n        return y;\n    }\n    else\n    {\n        x++;\n        if(x%2==0)\n        {\n            if(x>=y)\n            return x;\n            else\n            return y;\n        }\n        else\n        {\n            x+=2;\n            if(x>=y)\n            return x;\n            else\n            return y;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    // Check if the range [x, y] contains at least one even number.\n    if (x % 2 != 0 && y % 2 != 0) {\n        return -1;\n    }\n\n    // Find the biggest even number in the range [x, y].\n    long result = -1;\n    for (long i = y; i >= x; --i) {\n        if (i % 2 == 0) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x += 1;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 != 0) {\n        x += 1;\n    }\n    if (y % 2 != 0) {\n        y -= 1;\n    }\n    if (x > y) {\n        return -1;\n    }\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x += 1;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    // Check if x is odd, if so, increment it by 1\n    if (x % 2 != 0) {\n        x++;\n    }\n\n    // Check if y is odd, if so, decrement it by 1\n    if (y % 2 != 0) {\n        y--;\n    }\n\n    // If x is greater than y, then return -1\n    if (x > y) {\n        return -1;\n    }\n\n    // Return the biggest even number in the range [x, y]\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 != 0) {\n        x += 1;\n    }\n    if (y % 2 != 0) {\n        y -= 1;\n    }\n    if (x > y) {\n        return -1;\n    }\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x += 1;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x++;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    // Your code goes here\n    long result = -1;\n    for (long i = x; i <= y; i++) {\n        if (i % 2 == 0) {\n            result = i;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x++;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 != 0) {\n        x += 1;\n    }\n    if (y % 2 != 0) {\n        y -= 1;\n    }\n    if (x > y) {\n        return -1;\n    }\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x += 1;\n        if (x % 2 == 0) {\n            return x;\n        }\n        else {\n            x += 2;\n            if (x % 2 == 0) {\n                return x;\n            }\n            else {\n                x += 2;\n                if (x % 2 == 0) {\n                    return x;\n                }\n                else {\n                    x += 2;\n                    if (x % 2 == 0) {\n                        return x;\n                    }\n                    else {\n                        x += 2;\n                        if (x % 2 == 0) {\n                            return x;\n                        }\n                        else {\n                            x += 2;\n                            if (x % 2 == 0) {\n                                return x;\n                            }\n                            else {\n                                x += 2;\n                                if (x % 2 == 0) {\n                                    return x;\n                                }\n                                else {\n                                    x += 2;\n                                    if (x % 2 == 0) {\n                                        return x;\n                                    }\n                                    else {\n                                        x += 2;\n                                        if (x % 2 == 0) {\n                                            return x;\n                                        }\n                                        else {\n                                            x += 2;\n                                            if (x % 2 == 0) {\n                                                return x;\n                                            }\n                                            else {\n                                                x += 2;\n                                                if (x % 2 == 0) {\n                                                    return x;\n                                                }\n                                                else {\n                                                    x += 2;\n                                                    if (x % 2 == 0) {\n                                                        return x;\n                                                    }\n                                                    else {\n                                                        x += 2;\n                                                        if (x % 2 == 0) {\n                                                            return x;\n                                                        }\n                                                        else {\n                                                            x += 2;\n                                                            if (x % 2 == 0) {\n                                                                return x;\n                                                            }\n                                                            else {\n                                                                x += 2;\n                                                                if (x % 2 == 0) {\n                                                                    return x;\n                                                                }\n                                                                else {\n                                                                    x += 2;\n                                                                    if (x % 2 == 0) {\n                                                                        return x;\n                                                                    }\n                                                                    else {\n                                                                        x += 2;\n                                                                        if (x % 2 == 0) {\n                                                                            return x;\n                                                                        }\n                                                                        else {\n                                                                            x += 2;\n                                                                            if (x % 2 == 0) {\n                                                                                return x;\n", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    if (x % 2 == 0) {\n        return x;\n    }\n    else {\n        x += 1;\n        if (x > y) {\n            return -1;\n        }\n        else {\n            return x;\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If \n// there's no such number, then the function should return -1.\n// For example:\n// >>> choose_num((12), (15))\n// (14)\n// >>> choose_num((13), (12))\n// (-1)\nlong choose_num(long x, long y) {\n    // Your code goes here\n    if(x%2==0)\n    {\n        if(y%2==0)\n        {\n            if(x<=y)\n            return y;\n            else\n            return -1;\n        }\n        else\n        {\n            y-=1;\n            if(x<=y)\n            return y;\n            else\n            return -1;\n        }\n    }\n    else\n    {\n        x+=1;\n        if(x%2==0)\n        {\n            if(x<=y)\n            return x;\n            else\n            return -1;\n        }\n        else\n        {\n            x+=2;\n            if(x<=y)\n            return x;\n            else\n            return -1;\n        }\n    }"], ["#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(32 - binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m)\n        return -1;\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(32 - binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary.erase(0, binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if(n > m)\n        return -1;\n    long sum = 0;\n    for(long i = n; i <= m; i++)\n        sum += i;\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(32 - binary.find_first_not_of('0'));\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(32 - binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if(n > m)\n        return -1;\n    long sum = 0;\n    for(long i = n; i <= m; i++)\n        sum += i;\n    long avg = sum / (m - n + 1);\n    return std::bitset<32>(avg).to_string();", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    return binary.substr(32 - binary.find_first_not_of('0'));", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary.erase(0, binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(binary.find('1'));\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    return binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if(n > m)\n        return -1;\n    long sum = 0;\n    for(long i = n; i <= m; i++)\n        sum += i;\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(32 - binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    return std::bitset<32>(avg).to_string();", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if(n > m)\n        return -1;\n    long sum = 0;\n    for(long i = n; i <= m; i++)\n        sum += i;\n    long avg = sum / (m - n + 1);\n    return std::bitset<32>(avg).to_string();", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if(n > m)\n        return Union_std_string_long(-1);\n    long sum = 0;\n    for(long i = n; i <= m; i++)\n        sum += i;\n    long avg = (sum + (m - n + 1) / 2) / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(32 - binary.find_first_not_of('0'));\n    return Union_std_string_long(\"0b\" + binary);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary = binary.substr(32 - binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary.erase(0, binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    return std::bitset<32>(avg).to_string();", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary.erase(0, binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary.erase(0, binary.find_first_not_of('0'));\n    return \"0b\" + binary;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_string_long{\n    std::string f0;\n    long f1;    Union_std_string_long(std::string _f0) : f0(_f0) {}\n    Union_std_string_long(long _f1) : f1(_f1) {}\n    ~Union_std_string_long() {}\n    bool operator==(std::string f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m (including n and m). \n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\n// Example:\n// >>> rounded_avg((1), (5))\n// \"0b11\"\n// >>> rounded_avg((7), (5))\n// -1\n// >>> rounded_avg((10), (20))\n// \"0b1111\"\n// >>> rounded_avg((20), (33))\n// \"0b11010\"\nUnion_std_string_long rounded_avg(long n, long m) {\n    if (n > m) {\n        return -1;\n    }\n    long sum = 0;\n    for (long i = n; i <= m; i++) {\n        sum += i;\n    }\n    long avg = sum / (m - n + 1);\n    std::string binary = std::bitset<32>(avg).to_string();\n    binary.erase(0, binary.find_first_not_of('0'));\n    return \"0b\" + binary;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (auto i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (auto num : x) {\n        bool has_even_digit = false;\n        while (num > 0) {\n            if ((num % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (auto i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (auto num : x) {\n        bool has_even_digit = false;\n        while (num > 0) {\n            if ((num % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (auto num : x) {\n        bool has_even_digit = false;\n        while (num > 0) {\n            if ((num % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if ((i % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (auto num : x) {\n        bool has_even_digit = false;\n        while (num > 0) {\n            if ((num % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for(auto i: x){\n        bool flag = true;\n        while(i){\n            if(i%10%2 == 0){\n                flag = false;\n                break;\n            }\n            i /= 10;\n        }\n        if(flag){\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for(long i : x) {\n        bool has_even_digit = false;\n        while(i > 0) {\n            if((i % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if(!has_even_digit)\n            result.push_back(i);\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        long num = i;\n        while (num > 0) {\n            if ((num % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long num : x) {\n        bool has_even_digit = false;\n        while (num > 0) {\n            if ((num % 10) % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            num /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(num);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of positive integers x. return a sorted vector of all \n// elements that hasn't any even digit.\n// Note: Returned vector should be sorted in increasing order.\n// For example:\n// >>> unique_digits((std::vector<long>({(long)15, (long)33, (long)1422, (long)1})))\n// (std::vector<long>({(long)1, (long)15, (long)33}))\n// >>> unique_digits((std::vector<long>({(long)152, (long)323, (long)1422, (long)10})))\n// (std::vector<long>())\nstd::vector<long> unique_digits(std::vector<long> x) {\n    std::vector<long> result;\n    for (long i : x) {\n        bool has_even_digit = false;\n        while (i > 0) {\n            if (i % 10 % 2 == 0) {\n                has_even_digit = true;\n                break;\n            }\n            i /= 10;\n        }\n        if (!has_even_digit) {\n            result.push_back(i);\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    std::vector<std::string> result;\n\n    std::sort(arr.begin(), arr.end());\n    std::reverse(arr.begin(), arr.end());\n\n    for (long num : arr) {\n        if (num >= 1 && num <= 9) {\n            result.push_back(names[num - 1]);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> result;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        result.push_back(names[i - 1]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for(auto i: arr) {\n        if(i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for(auto i: temp) {\n        ans.push_back(names[i-1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> res;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        res.push_back(names[i - 1]);\n    }\n\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::map<long, std::string> mp = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n    for (long i : arr) {\n        if (mp.find(i) != mp.end()) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        ans.push_back(mp[i]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9)\n            temp.push_back(i);\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        ans.push_back(names[i - 1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> nums = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for(long i : arr) {\n        if(i >= 1 && i <= 9)\n            temp.push_back(i);\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for(long i : temp) {\n        ans.push_back(nums[i-1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    for(long i: arr){\n        if(i>=1 && i<=9){\n            temp.push_back(i);\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n    for(long i: temp){\n        ans.push_back(names[i-1]);\n    }\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> nums = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        ans.push_back(nums[i - 1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> nums = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        ans.push_back(nums[i - 1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> res;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        res.push_back(names[i - 1]);\n    }\n\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> nums = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        ans.push_back(nums[i - 1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    std::vector<std::string> result;\n\n    std::sort(arr.begin(), arr.end());\n    std::reverse(arr.begin(), arr.end());\n\n    for (long num : arr) {\n        if (num >= 1 && num <= 9) {\n            result.push_back(names[num - 1]);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        ans.push_back(names[i - 1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> result;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for(long i : arr) {\n        if(i >= 1 && i <= 9)\n            temp.push_back(i);\n    }\n\n    std::sort(temp.begin(), temp.end(), std::greater<long>());\n\n    for(long i : temp) {\n        result.push_back(names[i-1]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::map<long, std::string> mp = {{1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}};\n\n    for (auto i : arr) {\n        if (i >= 1 && i <= 9)\n            temp.push_back(i);\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (auto i : temp) {\n        ans.push_back(mp[i]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> nums = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        ans.push_back(nums[i - 1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> res;\n    std::vector<long> temp;\n    std::vector<std::string> names = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n    std::reverse(temp.begin(), temp.end());\n\n    for (long i : temp) {\n        res.push_back(names[i - 1]);\n    }\n\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n    std::vector<std::string> ans;\n    std::vector<long> temp;\n    std::vector<std::string> nums = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n\n    for (long i : arr) {\n        if (i >= 1 && i <= 9) {\n            temp.push_back(i);\n        }\n    }\n\n    std::sort(temp.begin(), temp.end(), std::greater<long>());\n\n    for (long i : temp) {\n        ans.push_back(nums[i - 1]);\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting vector, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n// For example:\n// >>> by_length((std::vector<long>({(long)2, (long)1, (long)1, (long)4, (long)5, (long)8, (long)2, (long)3})))\n// (std::vector<std::string>({(std::string)\"Eight\", (std::string)\"Five\", (std::string)\"Four\", (std::string)\"Three\", (std::string)\"Two\", (std::string)\"Two\", (std::string)\"One\", (std::string)\"One\"}))\n// If the vector is empty, return an empty vector:\n// >>> by_length((std::vector<long>()))\n// (std::vector<std::string>())\n// If the vector has any strange number ignore it:\n// >>> by_length((std::vector<long>({(long)1, (long)-1, (long)55})))\n// (std::vector<std::string>({(std::string)\"One\"}))\nstd::vector<std::string> by_length(std::vector<long> arr) {\n  std::vector<std::string> ans;\n  std::vector<long> temp;\n  std::vector<std::string> nums = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n  for (long i : arr) {\n    if (i >= 1 && i <= 9) {\n      temp.push_back(i);\n    }\n  }\n  std::sort(temp.begin(), temp.end());\n  std::reverse(temp.begin(), temp.end());\n  for (long i : temp) {\n    ans.push_back(nums[i - 1]);\n  }\n  return ans;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> res(n);\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            res[i - 1] = 1;\n            for (long j = 2; j <= i; ++j) {\n                res[i - 1] *= j;\n            }\n        } else {\n            res[i - 1] = 0;\n            for (long j = 1; j <= i; ++j) {\n                res[i - 1] += j;\n            }\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> res(n);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long fact = 1;\n            for (long j = 1; j <= i; j++) {\n                fact *= j;\n            }\n            res[i - 1] = fact;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            res[i - 1] = sum;\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i - 1] = 1;\n            for (long j = 2; j <= i; j++) {\n                result[i - 1] *= j;\n            }\n        } else {\n            result[i - 1] = 0;\n            for (long j = 1; j <= i; j++) {\n                result[i - 1] += j;\n            }\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for(long i = 1; i <= n; i++) {\n        if(i % 2 == 0) {\n            long factorial = 1;\n            for(long j = 1; j <= i; j++) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for(long j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result(n);\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result[i - 1] = factorial;\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n// Example:\n// >>> f((5))\n// (std::vector<long>({(long)1, (long)2, (long)6, (long)24, (long)15}))\nstd::vector<long> f(long n) {\n    std::vector<long> result;\n    for (long i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            long factorial = 1;\n            for (long j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result.push_back(factorial);\n        } else {\n            long sum = 0;\n            for (long j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even = 0, odd = 0;\n  for (long i = 1; i <= n; i++) {\n    long rev = 0;\n    long temp = i;\n    while (temp > 0) {\n      rev = rev * 10 + temp % 10;\n      temp /= 10;\n    }\n    if (i == rev) {\n      if (i % 2 == 0)\n        even++;\n      else\n        odd++;\n    }\n  }\n  return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even = 0, odd = 0;\n  for (long i = 1; i <= n; i++) {\n    long rev = 0;\n    long temp = i;\n    while (temp > 0) {\n      rev = rev * 10 + temp % 10;\n      temp /= 10;\n    }\n    if (i == rev) {\n      if (i % 2 == 0)\n        even++;\n      else\n        odd++;\n    }\n  }\n  return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even_count = 0;\n  long odd_count = 0;\n  for (long i = 1; i <= n; i++) {\n    long rev = 0;\n    long temp = i;\n    while (temp > 0) {\n      rev = rev * 10 + temp % 10;\n      temp /= 10;\n    }\n    if (i == rev) {\n      if (i % 2 == 0)\n        even_count++;\n      else\n        odd_count++;\n    }\n  }\n  return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0, odd_count = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n  long even = 0, odd = 0;\n  for (long i = 1; i <= n; i++) {\n    long rev = 0;\n    long temp = i;\n    while (temp > 0) {\n      rev = rev * 10 + temp % 10;\n      temp /= 10;\n    }\n    if (rev == i) {\n      if (i % 2 == 0)\n        even++;\n      else\n        odd++;\n    }\n  }\n  return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp != 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0, odd_count = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (rev == i) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (rev == i) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0, odd_count = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even = 0, odd = 0;\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (i == rev) {\n            if (i % 2 == 0)\n                even++;\n            else\n                odd++;\n        }\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// >>> even_odd_palindrome((3))\n// (std::make_tuple(1, 2))\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// >>> even_odd_palindrome((12))\n// (std::make_tuple(4, 6))\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nstd::tuple<long, long> even_odd_palindrome(long n) {\n    long even_count = 0;\n    long odd_count = 0;\n\n    for (long i = 1; i <= n; i++) {\n        long rev = 0;\n        long temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n\n        if (i == rev) {\n            if (i % 2 == 0)\n                even_count++;\n            else\n                odd_count++;\n        }\n    }\n\n    return std::make_tuple(even_count, odd_count);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for(auto num : arr){\n        long sum = 0;\n        bool isNegative = false;\n        if(num < 0){\n            num = -num;\n            isNegative = true;\n        }\n        while(num > 0){\n            sum += num % 10;\n            num /= 10;\n        }\n        if(isNegative){\n            sum = -sum;\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (auto num : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long i : arr) {\n    long sum = 0;\n    bool is_negative = false;\n    if (i < 0) {\n      is_negative = true;\n      i = -i;\n    }\n    while (i > 0) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if (is_negative)\n      sum = -sum;\n    if (sum > 0)\n      count++;\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long num : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i : arr) {\n        long sum = 0;\n        bool negative = false;\n        if (i < 0) {\n            negative = true;\n            i = -i;\n        }\n        while (i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if (negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for(long i : arr){\n        long sum = 0;\n        if(i < 0){\n            i = -i;\n            sum -= i;\n        }\n        while(i){\n            sum += i % 10;\n            i /= 10;\n        }\n        if(sum > 0)\n            count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (auto num : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for(long i : arr) {\n        long sum = 0;\n        while(i != 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if(sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (i < 0) {\n            is_negative = true;\n            i = -i;\n        }\n        while (i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for(long i : arr) {\n        long sum = 0;\n        while(i != 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if(sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long num : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n  long count = 0;\n  for (long num : arr) {\n    long sum = 0;\n    bool is_negative = false;\n    if (num < 0) {\n      is_negative = true;\n      num = -num;\n    }\n    while (num > 0) {\n      sum += num % 10;\n      num /= 10;\n    }\n    if (is_negative) {\n      sum = -sum;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long num : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for(long i : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if(i < 0) {\n            is_negative = true;\n            i = -i;\n        }\n        while(i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if(is_negative)\n            sum = -sum;\n        if(sum > 0)\n            count++;\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i : arr) {\n        long sum = 0;\n        bool negative = false;\n        if (i < 0) {\n            negative = true;\n            i = -i;\n        }\n        while (i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if (negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (i < 0) {\n            is_negative = true;\n            i = -i;\n        }\n        while (i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long num : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long num : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i : arr) {\n        long sum = 0;\n        bool is_negative = false;\n        if (i < 0) {\n            is_negative = true;\n            i = -i;\n        }\n        while (i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if (is_negative) {\n            sum = -sum;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function count_nums which takes a vector of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums((std::vector<long>()))\n// (0)\n// >>> count_nums((std::vector<long>({(long)-1, (long)11, (long)-11})))\n// (1)\n// >>> count_nums((std::vector<long>({(long)1, (long)1, (long)2})))\n// (3)\nlong count_nums(std::vector<long> arr) {\n    long count = 0;\n    for (long i : arr) {\n        long sum = 0;\n        if (i < 0) {\n            i = -i;\n            sum -= i;\n        }\n        while (i > 0) {\n            sum += i % 10;\n            i /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n\n    if (count <= 1) {\n        return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return true;\n\n    int n = arr.size();\n    int count = 0;\n\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[(i+1)%n]) {\n            count++;\n            if(count > 1)\n                return false;\n        }\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    long n = arr.size();\n    long count = 0;\n    long i = 0;\n\n    while (i < n) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n            if (count > 1) {\n                return false;\n            }\n        }\n        i++;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty())\n        return true;\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n            if (count > 1)\n                return false;\n        }\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty())\n        return true;\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n])\n            count++;\n    }\n\n    if (count <= 1)\n        return true;\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty())\n        return true;\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n            if (count > 1)\n                return false;\n        }\n    }\n\n    if (arr[n - 1] < arr[0])\n        count++;\n\n    return count <= 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    // Write your code here\n    if(arr.size() == 0)\n        return true;\n\n    int n = arr.size();\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1)\n                return false;\n        }\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    long n = arr.size();\n    long count = 0;\n    long i = 0;\n\n    while (i < n) {\n        if (arr[i] <= arr[i - 1]) {\n            count++;\n        }\n        i++;\n    }\n\n    if (count == 0 || count == 1 || count == n - 1) {\n        return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int i = 0;\n    while (i < n && arr[i] <= arr[i + 1]) {\n        i++;\n    }\n\n    if (i == n - 1) {\n        return true;\n    }\n\n    int j = n - 1;\n    while (arr[j] >= arr[j - 1]) {\n        j--;\n    }\n\n    return i >= j;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty())\n        return true;\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n])\n            count++;\n    }\n\n    if (count == 0 || count == 1 || count == n - 1)\n        return true;\n    else\n        return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty())\n        return true;\n\n    long n = arr.size();\n    long count = 0;\n    long i = 0;\n\n    while (i < n) {\n        if (arr[i] <= arr[i - 1]) {\n            count++;\n            if (count > 1)\n                return false;\n        }\n        i++;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty())\n        return true;\n\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n\n    if (arr[n - 1] < arr[0]) {\n        count++;\n    }\n\n    return count <= 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0)\n        return true;\n\n    int count = 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1])\n            count++;\n    }\n\n    if (count == 0 || count == 1)\n        return true;\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.size() == 0)\n        return true;\n\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n\n    if (arr[n - 1] < arr[0]) {\n        count++;\n    }\n\n    return count <= 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    int n = arr.size();\n    if (n == 0)\n        return true;\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n])\n            count++;\n    }\n\n    if (count == 0 || count == 1 || count == n - 1)\n        return true;\n    else\n        return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty())\n        return true;\n\n    long n = arr.size();\n    long count = 0;\n\n    for (long i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n            if (count > 1)\n                return false;\n        }\n    }\n\n    if (arr[n - 1] < arr[0])\n        count++;\n\n    return count <= 1;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if(arr.size() == 0)\n        return true;\n\n    int n = arr.size();\n    int count = 0;\n\n    for(int i = 0; i < n; i++) {\n        if(arr[i] > arr[(i+1)%n]) {\n            count++;\n        }\n    }\n\n    if(count == 0 || count == 1 || count == n-1)\n        return true;\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int i = 0;\n    while (i < n && arr[i] <= arr[i + 1]) {\n        i++;\n    }\n\n    if (i == n - 1) {\n        return true;\n    }\n\n    int j = n - 1;\n    while (arr[j] >= arr[j - 1]) {\n        j--;\n    }\n\n    return i >= j;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n\n    if (count == 0 || count == 1 || count == n - 1) {\n        return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// We have a vector 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n// numbers in the vector will be randomly ordered. Your task is to determine if\n// it is possible to get a vector sorted in non-decreasing order by performing \n// the following operation on the given vector:\n// You are allowed to perform right shift operation any number of times.\n// One right shift operation means shifting all elements of the vector by one\n// position in the right direction. The last element of the vector will be moved to\n// the starting position in the vector i.e. 0th index. \n// If it is possible to obtain the sorted vector by performing the above operation\n// then return true else return false.\n// If the given vector is empty then return true.\n// Note: The given vector is guaranteed to have unique elements.\n// For Example:\n// >>> move_one_ball((std::vector<long>({(long)3, (long)4, (long)5, (long)1, (long)2})))\n// (true)\n// Explanation: By performin 2 right shift operations, non-decreasing order can\n// be achieved for the given vector.\n// >>> move_one_ball((std::vector<long>({(long)3, (long)5, (long)4, (long)1, (long)2})))\n// (false)\n// Explanation:It is not possible to get non-decreasing order for the given\n// vector by performing any number of right shift operations.\nbool move_one_ball(std::vector<long> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    long n = arr.size();\n    long count = 0;\n    long i = 0;\n\n    while (i < n) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            count++;\n            if (count > 1) {\n                return false;\n            }\n        }\n        i++;\n    }\n\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd_count = 0;\n    for(auto i: lst1){\n        if(i%2 != 0){\n            odd_count++;\n        }\n    }\n    if(odd_count == 0){\n        return \"YES\";\n    }\n    int even_count = 0;\n    for(auto i: lst2){\n        if(i%2 == 0){\n            even_count++;\n        }\n    }\n    if(even_count >= odd_count){\n        return \"YES\";\n    }\n    return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Your code goes here\n    int odd1 = 0, odd2 = 0;\n    for(auto i : lst1)\n        if(i%2 != 0)\n            odd1++;\n    for(auto i : lst2)\n        if(i%2 != 0)\n            odd2++;\n    if(odd1 > odd2)\n        return \"NO\";\n    else\n        return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Initialize count of odd numbers in lst1 and even numbers in lst2\n    int odd_count = 0, even_count = 0;\n\n    // Count odd numbers in lst1 and even numbers in lst2\n    for(auto num : lst1) {\n        if(num % 2 != 0) odd_count++;\n    }\n    for(auto num : lst2) {\n        if(num % 2 == 0) even_count++;\n    }\n\n    // If odd count in lst1 is greater than even count in lst2, return \"NO\"\n    if(odd_count > even_count) return \"NO\";\n\n    // Otherwise, return \"YES\"\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  // Your code goes here\n  int odd_count = 0;\n  for (auto i : lst1) {\n    if (i % 2 != 0) {\n      odd_count++;\n    }\n  }\n  if (odd_count == 0) {\n    return \"YES\";\n  }\n  int even_count = 0;\n  for (auto i : lst2) {\n    if (i % 2 == 0) {\n      even_count++;\n    }\n  }\n  if (even_count >= odd_count) {\n    return \"YES\";\n  }\n  return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Your code goes here\n    int odd_count = 0;\n    for(int i = 0; i < lst1.size(); i++){\n        if(lst1[i] % 2 != 0){\n            odd_count++;\n        }\n    }\n\n    if(odd_count == 0){\n        return \"YES\";\n    }\n\n    int even_count = 0;\n    for(int i = 0; i < lst2.size(); i++){\n        if(lst2[i] % 2 == 0){\n            even_count++;\n        }\n    }\n\n    if(even_count >= odd_count){\n        return \"YES\";\n    }\n\n    return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int count = 0;\n    for(long i : lst1){\n        if(i % 2 != 0){\n            count++;\n        }\n    }\n    if(count == 0){\n        return \"YES\";\n    }\n    int odd_count = 0;\n    for(long i : lst2){\n        if(i % 2 != 0){\n            odd_count++;\n        }\n    }\n    if(odd_count >= count){\n        return \"YES\";\n    }\n    return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd_count = 0;\n    for(auto i : lst1)\n        if(i % 2 != 0)\n            odd_count++;\n\n    if(odd_count == 0)\n        return \"YES\";\n\n    int even_count = 0;\n    for(auto i : lst2)\n        if(i % 2 == 0)\n            even_count++;\n\n    if(even_count >= odd_count)\n        return \"YES\";\n\n    return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  int odd_count = 0;\n  for (auto num : lst1) {\n    if (num % 2 != 0) {\n      odd_count++;\n    }\n  }\n  if (odd_count == 0) {\n    return \"YES\";\n  }\n  std::sort(lst1.begin(), lst1.end());\n  std::sort(lst2.begin(), lst2.end());\n  int i = 0, j = lst2.size() - 1;\n  while (i < lst1.size() && j >= 0) {\n    if (lst1[i] % 2 != 0 && lst2[j] % 2 == 0) {\n      std::swap(lst1[i], lst2[j]);\n      odd_count--;\n      if (odd_count == 0) {\n        return \"YES\";\n      }\n    }\n    if (lst1[i] % 2 != 0) {\n      i++;\n    } else {\n      j--;\n    }\n  }\n  return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Count the number of odd numbers in lst1\n    int odd_count = 0;\n    for (auto num : lst1) {\n        if (num % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    // Count the number of even numbers in lst2\n    int even_count = 0;\n    for (auto num : lst2) {\n        if (num % 2 == 0) {\n            even_count++;\n        }\n    }\n\n    // If the number of odd numbers in lst1 is greater than the number of even numbers in lst2,\n    // then it is impossible to make lst1 a vector of only even numbers.\n    if (odd_count > even_count) {\n        return \"NO\";\n    }\n\n    // Otherwise, it is possible to make lst1 a vector of only even numbers.\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd_count = 0;\n    for(auto i : lst1)\n        if(i%2 != 0)\n            odd_count++;\n\n    if(odd_count == 0)\n        return \"YES\";\n\n    std::sort(lst2.begin(), lst2.end());\n\n    for(auto i : lst1){\n        if(i%2 != 0){\n            if(std::binary_search(lst2.begin(), lst2.end(), i+1) || std::binary_search(lst2.begin(), lst2.end(), i-1))\n                odd_count--;\n        }\n    }\n\n    if(odd_count == 0)\n        return \"YES\";\n    else\n        return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd1 = 0, odd2 = 0;\n    for(auto i : lst1)\n        if(i % 2 != 0)\n            odd1++;\n    for(auto i : lst2)\n        if(i % 2 != 0)\n            odd2++;\n    if(odd1 > odd2)\n        return \"NO\";\n    else\n        return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Your code goes here\n    int odd1 = 0, odd2 = 0;\n    for(auto i: lst1)\n        if(i%2 != 0)\n            odd1++;\n    for(auto i: lst2)\n        if(i%2 != 0)\n            odd2++;\n    if(odd1 > odd2)\n        return \"NO\";\n    else\n        return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd_count = 0;\n    for(auto i : lst1){\n        if(i%2 != 0){\n            odd_count++;\n        }\n    }\n    if(odd_count == 0){\n        return \"YES\";\n    }\n    std::sort(lst1.begin(), lst1.end());\n    std::sort(lst2.begin(), lst2.end());\n    int i = 0, j = lst2.size()-1;\n    while(i < lst1.size() && j >= 0){\n        if(lst1[i]%2 != 0 && lst2[j]%2 == 0){\n            std::swap(lst1[i], lst2[j]);\n            odd_count--;\n            if(odd_count == 0){\n                return \"YES\";\n            }\n        }\n        if(lst1[i]%2 != 0){\n            i++;\n        }\n        if(lst2[j]%2 == 0){\n            j--;\n        }\n    }\n    return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd_count = 0;\n    for(auto i : lst1) {\n        if(i % 2 != 0) {\n            odd_count++;\n        }\n    }\n    if(odd_count == 0) {\n        return \"YES\";\n    }\n    int even_count = 0;\n    for(auto i : lst2) {\n        if(i % 2 == 0) {\n            even_count++;\n        }\n    }\n    if(odd_count <= even_count) {\n        return \"YES\";\n    }\n    return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    int odd1 = 0, odd2 = 0;\n    for(auto i : lst1)\n        if(i%2 != 0)\n            odd1++;\n    for(auto i : lst2)\n        if(i%2 != 0)\n            odd2++;\n    if(odd1 > odd2)\n        return \"NO\";\n    else\n        return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Your code goes here\n    int odd_count = 0;\n    for(auto i: lst1){\n        if(i%2 != 0){\n            odd_count++;\n        }\n    }\n    if(odd_count == 0){\n        return \"YES\";\n    }\n    int even_count = 0;\n    for(auto i: lst2){\n        if(i%2 == 0){\n            even_count++;\n        }\n    }\n    if(even_count >= odd_count){\n        return \"YES\";\n    }\n    return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Your code goes here\n    int count = 0;\n    for(int i=0; i<lst1.size(); i++){\n        if(lst1[i]%2 != 0){\n            count++;\n        }\n    }\n    if(count == 0){\n        return \"YES\";\n    }\n    else{\n        int odd_count = 0;\n        for(int i=0; i<lst2.size(); i++){\n            if(lst2[i]%2 != 0){\n                odd_count++;\n            }\n        }\n        if(odd_count >= count){\n            return \"YES\";\n        }\n        else{\n            return \"NO\";\n        }\n    }", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n  // Your code goes here\n  int odd_count = 0;\n  for(auto x : lst1)\n    if(x % 2 != 0)\n      odd_count++;\n  if(odd_count == 0)\n    return \"YES\";\n  std::sort(lst2.begin(), lst2.end());\n  for(auto x : lst1)\n    if(x % 2 != 0){\n      auto it = std::lower_bound(lst2.begin(), lst2.end(), x);\n      if(it != lst2.end() && *it % 2 == 0)\n        odd_count--;\n    }\n  if(odd_count == 0)\n    return \"YES\";\n  return \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Your code goes here\n    int odd_count = 0;\n    for(auto i: lst1){\n        if(i%2 != 0){\n            odd_count++;\n        }\n    }\n    if(odd_count == 0){\n        return \"YES\";\n    }\n    std::sort(lst2.begin(), lst2.end());\n    for(int i=0; i<odd_count; i++){\n        if(lst2.size() == 0){\n            return \"NO\";\n        }\n        if(lst2[lst2.size()-1]%2 != 0){\n            lst2.pop_back();\n        }\n        else{\n            return \"NO\";\n        }\n    }\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this problem, you will implement a function that takes two vectors of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n// For example:\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4})))\n// (\"YES\")\n// >>> exchange((std::vector<long>({(long)1, (long)2, (long)3, (long)4})), (std::vector<long>({(long)1, (long)5, (long)3, (long)4})))\n// (\"NO\")\n// It is assumed that the input vectors will be non-empty.\nstd::string exchange(std::vector<long> lst1, std::vector<long> lst2) {\n    // Your code goes here\n    int odd1 = 0, odd2 = 0;\n    for(int i = 0; i < lst1.size(); i++){\n        if(lst1[i] % 2 != 0) odd1++;\n    }\n    for(int i = 0; i < lst2.size(); i++){\n        if(lst2[i] % 2 != 0) odd2++;\n    }\n    if(odd1 <= odd2) return \"YES\";\n    else return \"NO\";"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while(ss >> word) {\n        hist[word]++;\n    }\n    long max_count = 0;\n    for(auto& it: hist) {\n        max_count = std::max(max_count, it.second);\n    }\n    std::map<std::string,long> result;\n    for(auto& it: hist) {\n        if(it.second == max_count) {\n            result[it.first] = it.second;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while (ss >> word) {\n        hist[word]++;\n    }\n\n    long max_count = 0;\n    for (auto &p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto &p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = p.second;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while (ss >> word) {\n        hist[word]++;\n    }\n\n    long max_count = 0;\n    for (auto &pair : hist) {\n        max_count = std::max(max_count, pair.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto &pair : hist) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        hist[token]++;\n    }\n\n    long max_count = 0;\n    for (auto& it : hist) {\n        max_count = std::max(max_count, it.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto& it : hist) {\n        if (it.second == max_count) {\n            result[it.first] = it.second;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> hist;\n  std::stringstream ss(test);\n  std::string word;\n  while (ss >> word) {\n    hist[word]++;\n  }\n  long max_count = 0;\n  for (auto& p : hist) {\n    max_count = std::max(max_count, p.second);\n  }\n  std::map<std::string,long> result;\n  for (auto& p : hist) {\n    if (p.second == max_count) {\n      result[p.first] = p.second;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        hist[token]++;\n    }\n\n    long max_count = 0;\n    for (auto &p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto &p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = p.second;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> hist;\n  std::stringstream ss(test);\n  std::string word;\n  while(ss >> word) {\n    hist[word]++;\n  }\n  long max_count = 0;\n  for(auto &p : hist) {\n    max_count = std::max(max_count, p.second);\n  }\n  std::map<std::string,long> result;\n  for(auto &p : hist) {\n    if(p.second == max_count) {\n      result[p.first] = p.second;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        hist[token]++;\n    }\n\n    long max_count = 0;\n    for (auto const& [letter, count] : hist) {\n        max_count = std::max(max_count, count);\n    }\n\n    std::map<std::string,long> result;\n    for (auto const& [letter, count] : hist) {\n        if (count == max_count) {\n            result[letter] = count;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> hist;\n  std::stringstream ss(test);\n  std::string word;\n  while (ss >> word) {\n    hist[word]++;\n  }\n  long max_count = 0;\n  for (auto& pair : hist) {\n    max_count = std::max(max_count, pair.second);\n  }\n  std::map<std::string,long> result;\n  for (auto& pair : hist) {\n    if (pair.second == max_count) {\n      result[pair.first] = pair.second;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> hist;\n  std::stringstream ss(test);\n  std::string word;\n  while (ss >> word) {\n    hist[word]++;\n  }\n  long max_count = 0;\n  for (auto &p : hist) {\n    max_count = std::max(max_count, p.second);\n  }\n  std::map<std::string,long> result;\n  for (auto &p : hist) {\n    if (p.second == max_count) {\n      result[p.first] = p.second;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while (ss >> word) {\n        hist[word]++;\n    }\n\n    long max_count = 0;\n    for (auto& p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto& p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = p.second;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        hist[token]++;\n    }\n\n    long max_count = 0;\n    for (auto& pair : hist) {\n        max_count = std::max(max_count, pair.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto& pair : hist) {\n        if (pair.second == max_count) {\n            result[pair.first] = pair.second;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        hist[token]++;\n    }\n\n    long max_count = 0;\n    for (auto &p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto &p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = max_count;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while (ss >> word) {\n        hist[word]++;\n    }\n\n    long max_count = 0;\n    for (auto& p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto& p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = max_count;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> hist;\n  if (test.empty())\n    return hist;\n  std::istringstream iss(test);\n  std::string word;\n  while (iss >> word)\n    hist[word]++;\n  long max_count = 0;\n  for (auto &p : hist)\n    max_count = std::max(max_count, p.second);\n  std::map<std::string,long> result;\n  for (auto &p : hist)\n    if (p.second == max_count)\n      result[p.first] = p.second;\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        hist[token]++;\n    }\n\n    long max_count = 0;\n    for (auto const& [letter, count] : hist) {\n        max_count = std::max(max_count, count);\n    }\n\n    std::map<std::string,long> result;\n    for (auto const& [letter, count] : hist) {\n        if (count == max_count) {\n            result[letter] = count;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while (ss >> word) {\n        hist[word]++;\n    }\n    long max_count = 0;\n    for (auto &p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n    std::map<std::string,long> result;\n    for (auto &p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = p.second;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while (ss >> word) {\n        hist[word]++;\n    }\n    long max_count = 0;\n    for (auto& p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n    std::map<std::string,long> result;\n    for (auto& p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = p.second;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n  std::map<std::string,long> hist;\n  std::stringstream ss(test);\n  std::string word;\n  while(ss >> word) {\n    hist[word]++;\n  }\n  long max_count = 0;\n  for(auto &p : hist) {\n    max_count = std::max(max_count, p.second);\n  }\n  std::map<std::string,long> result;\n  for(auto &p : hist) {\n    if(p.second == max_count) {\n      result[p.first] = p.second;\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string representing a space separated lowercase letters, return a map\n// of the letter with the most repetition and containing the corresponding count.\n// If several letters have the same occurrence, return all of them.\n// Example:\n// >>> histogram((\"a b c\"))\n// (std::map<std::string,long>({{\"a\", 1}, {\"b\", 1}, {\"c\", 1}}))\n// >>> histogram((\"a b b a\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"a b c a b\"))\n// (std::map<std::string,long>({{\"a\", 2}, {\"b\", 2}}))\n// >>> histogram((\"b b b b a\"))\n// (std::map<std::string,long>({{\"b\", 4}}))\n// >>> histogram((\"\"))\n// (std::map<std::string,long>())\nstd::map<std::string,long> histogram(std::string test) {\n    std::map<std::string,long> hist;\n    std::stringstream ss(test);\n    std::string word;\n    while (ss >> word) {\n        hist[word]++;\n    }\n\n    long max_count = 0;\n    for (auto &p : hist) {\n        max_count = std::max(max_count, p.second);\n    }\n\n    std::map<std::string,long> result;\n    for (auto &p : hist) {\n        if (p.second == max_count) {\n            result[p.first] = p.second;\n        }\n    }\n\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    for (char ch : s) {\n        if (c.find(ch) == std::string::npos) {\n            result += ch;\n        }\n    }\n\n    bool is_palindrome = false;\n    int n = result.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (result[i] != result[n - i - 1]) {\n            break;\n        }\n        if (i == n / 2 - 1) {\n            is_palindrome = true;\n        }\n    }\n\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    // Your code goes here\n    std::unordered_set<char> set;\n    for(char ch : c) {\n        set.insert(ch);\n    }\n    std::string result;\n    for(char ch : s) {\n        if(!set.count(ch)) {\n            result.push_back(ch);\n        }\n    }\n    bool is_palindrome = false;\n    int n = result.size();\n    for(int i = 0; i < n/2; i++) {\n        if(result[i] == result[n-i-1]) {\n            is_palindrome = true;\n        }\n        else {\n            is_palindrome = false;\n            break;\n        }\n    }\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  // Your code goes here\n  std::string result;\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  bool is_palindrome = false;\n  if (result == std::string(result.rbegin(), result.rend())) {\n    is_palindrome = true;\n  }\n  return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    for (char ch : s) {\n        if (c.find(ch) == std::string::npos) {\n            result.push_back(ch);\n        }\n    }\n    bool is_palindrome = false;\n    if (result == std::string(result.rbegin(), result.rend())) {\n        is_palindrome = true;\n    }\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  // Your code goes here\n  std::string result;\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  bool is_palindrome = false;\n  if (result == std::string(result.rbegin(), result.rend())) {\n    is_palindrome = true;\n  }\n  return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    std::unordered_set<char> set_c;\n\n    for (char ch : c) {\n        set_c.insert(ch);\n    }\n\n    for (char ch : s) {\n        if (set_c.find(ch) == set_c.end()) {\n            result.push_back(ch);\n        }\n    }\n\n    bool is_palindrome = false;\n    int n = result.size();\n\n    for (int i = 0; i < n / 2; i++) {\n        if (result[i] != result[n - 1 - i]) {\n            break;\n        }\n\n        if (i == n / 2 - 1) {\n            is_palindrome = true;\n        }\n    }\n\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  // Your code goes here\n  std::unordered_set<char> set;\n  for(char ch : c)\n    set.insert(ch);\n\n  std::string result;\n  for(char ch : s)\n    if(set.find(ch) == set.end())\n      result.push_back(ch);\n\n  bool is_palindrome = false;\n  if(result == std::string(result.rbegin(), result.rend()))\n    is_palindrome = true;\n\n  return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    for (char ch : s) {\n        if (c.find(ch) == std::string::npos) {\n            result += ch;\n        }\n    }\n\n    bool is_palindrome = false;\n    if (result == std::string(result.rbegin(), result.rend())) {\n        is_palindrome = true;\n    }\n\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    for (char ch : s) {\n        if (c.find(ch) == std::string::npos) {\n            result += ch;\n        }\n    }\n\n    bool is_palindrome = false;\n    if (result == std::string(result.rbegin(), result.rend())) {\n        is_palindrome = true;\n    }\n\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    // Your code goes here\n    std::string res;\n    for(int i = 0; i < s.length(); i++) {\n        if(c.find(s[i]) == std::string::npos) {\n            res += s[i];\n        }\n    }\n\n    bool is_palindrome = false;\n    if(res == std::string(res.rbegin(), res.rend())) {\n        is_palindrome = true;\n    }\n\n    return std::make_tuple(res, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    for (char ch : s) {\n        if (c.find(ch) == std::string::npos) {\n            result += ch;\n        }\n    }\n\n    bool is_palindrome = false;\n    if (result == std::string(result.rbegin(), result.rend())) {\n        is_palindrome = true;\n    }\n\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    // Your code goes here\n    for(int i = 0; i < c.length(); i++)\n    {\n        s.erase(std::remove(s.begin(), s.end(), c[i]), s.end());\n    }\n\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n\n    if(s == rev)\n        return std::make_tuple(s, true);\n    else\n        return std::make_tuple(s, false);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::unordered_set<char> set;\n  for (char ch : c) {\n    set.insert(ch);\n  }\n  std::string result;\n  for (char ch : s) {\n    if (!set.count(ch)) {\n      result.push_back(ch);\n    }\n  }\n  bool is_palindrome = false;\n  if (result == std::string(result.rbegin(), result.rend())) {\n    is_palindrome = true;\n  }\n  return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result;\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  bool is_palindrome = false;\n  if (result == std::string(result.rbegin(), result.rend())) {\n    is_palindrome = true;\n  }\n  return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n  std::string result;\n  for (char ch : s) {\n    if (c.find(ch) == std::string::npos) {\n      result += ch;\n    }\n  }\n  bool is_palindrome = false;\n  if (result == std::string(result.rbegin(), result.rend())) {\n    is_palindrome = true;\n  }\n  return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    for (char ch : s) {\n        if (c.find(ch) == std::string::npos) {\n            result += ch;\n        }\n    }\n\n    bool is_palindrome = false;\n    if (result == std::string(result.rbegin(), result.rend())) {\n        is_palindrome = true;\n    }\n\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::unordered_set<char> set(c.begin(), c.end());\n    std::string result;\n    for (char ch : s) {\n        if (!set.count(ch)) {\n            result.push_back(ch);\n        }\n    }\n    bool is_palindrome = false;\n    if (result == std::string(result.rbegin(), result.rend())) {\n        is_palindrome = true;\n    }\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::unordered_set<char> set;\n    for (char ch : c) {\n        set.insert(ch);\n    }\n\n    std::string result;\n    for (char ch : s) {\n        if (!set.count(ch)) {\n            result.push_back(ch);\n        }\n    }\n\n    bool is_palindrome = false;\n    int n = result.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (result[i] != result[n - 1 - i]) {\n            break;\n        }\n        if (i == n / 2 - 1) {\n            is_palindrome = true;\n        }\n    }\n\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    std::string result;\n    std::unordered_set<char> set_c;\n    for (char ch : c) {\n        set_c.insert(ch);\n    }\n    for (char ch : s) {\n        if (!set_c.count(ch)) {\n            result.push_back(ch);\n        }\n    }\n    bool is_palindrome = false;\n    int n = result.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (result[i] == result[n - i - 1]) {\n            is_palindrome = true;\n        } else {\n            is_palindrome = false;\n            break;\n        }\n    }\n    return std::make_tuple(result, is_palindrome);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Task\n// We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n// then check if the result string is palindrome.\n// A string is called palindrome if it reads the same backward as forward.\n// You should return a tuple containing the result string and true/false for the check.\n// Example\n// >>> reverse_delete((\"abcde\"), (\"ae\"))\n// (std::make_tuple(\"bcd\", false))\n// >>> reverse_delete((\"abcdef\"), (\"b\"))\n// (std::make_tuple(\"acdef\", false))\n// >>> reverse_delete((\"abcdedcba\"), (\"ab\"))\n// (std::make_tuple(\"cdedc\", true))\nstd::tuple<std::string, bool> reverse_delete(std::string s, std::string c) {\n    // Your code goes here\n    for (int i = 0; i < c.length(); i++) {\n        s.erase(std::remove(s.begin(), s.end(), c[i]), s.end());\n    }\n\n    bool is_palindrome = false;\n    if (s == std::string(s.rbegin(), s.rend())) {\n        is_palindrome = true;\n    }\n\n    return std::make_tuple(s, is_palindrome);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (std::string str : lst) {\n    int count = 0;\n    for (char c : str) {\n      if ((c - '0') % 2 == 1) {\n        count++;\n      }\n    }\n    std::string new_str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(new_str);\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (std::string str : lst) {\n        int odd_count = 0;\n        for (char c : str) {\n            if (c % 2 != 0) {\n                odd_count++;\n            }\n        }\n        std::string new_str = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(new_str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto str : lst) {\n        int odd_count = 0;\n        for (auto c : str) {\n            if ((c - '0') % 2 == 1) {\n                odd_count++;\n            }\n        }\n        std::string new_str = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(new_str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (char c : lst[i]) {\n            if (c - '0' % 2 != 0) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (char c : lst[i]) {\n            if (c - '0' % 2 == 1) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (std::string str : lst) {\n    int count = 0;\n    for (char c : str) {\n      if (c - '0' % 2 == 1) {\n        count++;\n      }\n    }\n    std::string output = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(output);\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] % 2 != 0) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (std::string str : lst) {\n        int odd_count = 0;\n        for (char c : str) {\n            if (c - '0' % 2 == 1) {\n                odd_count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto str : lst) {\n        int count = 0;\n        for (auto c : str) {\n            if (c - '0' % 2 == 1) {\n                count++;\n            }\n        }\n        std::string res_str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(res_str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (std::string str : lst) {\n        int odd_count = 0;\n        for (char c : str) {\n            if (c - '0' % 2 == 1) {\n                odd_count++;\n            }\n        }\n        std::string new_str = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(new_str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (char c : lst[i]) {\n            if (c - '0' % 2 != 0) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (std::string str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if (c - '0' % 2 == 1) {\n                count++;\n            }\n        }\n        std::string new_str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(new_str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        int odd_count = 0;\n        for (auto &c : str) {\n            if (c - '0' % 2 == 1) {\n                odd_count++;\n            }\n        }\n        std::stringstream ss;\n        ss << \"the number of odd elements \" << odd_count << \"n the str\" << odd_count << \"ng \" << odd_count << \" of the \" << odd_count << \"nput.\";\n        result.push_back(ss.str());\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] % 2 != 0) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (std::string str : lst) {\n        int odd_count = 0;\n        for (char c : str) {\n            if (c % 2 != 0) {\n                odd_count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] % 2 != 0) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] % 2 != 0) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (char c : lst[i]) {\n            if (c - '0' % 2 == 1) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (int j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] % 2 != 0) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\n// >>> odd_count((std::vector<std::string>({(std::string)\"1234567\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}))\n// >>> odd_count((std::vector<std::string>({(std::string)\"3\", (std::string)\"11111111\"})))\n// (std::vector<std::string>({(std::string)\"the number of odd elements 1n the str1ng 1 of the 1nput.\", (std::string)\"the number of odd elements 8n the str8ng 8 of the 8nput.\"}))\nstd::vector<std::string> odd_count(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (int i = 0; i < lst.size(); i++) {\n        int count = 0;\n        for (char c : lst[i]) {\n            if (c - '0' % 2 == 1) {\n                count++;\n            }\n        }\n        std::string str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(str);\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long current_sum = 0;\n\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long current_sum = 0;\n\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long current_sum = 0;\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long current_sum = 0;\n\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_sum = nums[0];\n  long sum = 0;\n  for (long num : nums) {\n    sum += num;\n    min_sum = std::min(min_sum, sum);\n    if (sum > 0)\n      sum = 0;\n  }\n  return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long current_sum = 0;\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long current_sum = 0;\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long sum = 0;\n    for (long num : nums) {\n        sum += num;\n        min_sum = std::min(min_sum, sum);\n        if (sum > 0)\n            sum = 0;\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long current_sum = 0;\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_sum = std::numeric_limits<long>::max();\n  long sum = 0;\n  for (long num : nums) {\n    sum += num;\n    min_sum = std::min(min_sum, sum);\n    if (sum > 0)\n      sum = 0;\n  }\n  return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long current_sum = 0;\n\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_sum = std::numeric_limits<long>::max();\n  long sum = 0;\n  for (long num : nums) {\n    sum += num;\n    min_sum = std::min(min_sum, sum);\n    if (sum > 0) {\n      sum = 0;\n    }\n  }\n  return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long sum = 0;\n    for (long num : nums) {\n        sum += num;\n        min_sum = std::min(min_sum, sum);\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = nums[0];\n    long current_sum = 0;\n    for (long num : nums) {\n        current_sum += num;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_sum = std::numeric_limits<long>::max();\n  long current_sum = 0;\n  for (long num : nums) {\n    current_sum += num;\n    min_sum = std::min(min_sum, current_sum);\n    if (current_sum > 0) {\n      current_sum = 0;\n    }\n  }\n  return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long sum = 0;\n    for (long num : nums) {\n        sum += num;\n        min_sum = std::min(min_sum, sum);\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long sum = 0;\n    for (long num : nums) {\n        sum += num;\n        min_sum = std::min(min_sum, sum);\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n  long min_sum = std::numeric_limits<long>::max();\n  long sum = 0;\n  for (long num : nums) {\n    sum += num;\n    min_sum = std::min(min_sum, sum);\n    if (sum > 0) {\n      sum = 0;\n    }\n  }\n  return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long sum = 0;\n    for (long num : nums) {\n        sum += num;\n        min_sum = std::min(min_sum, sum);\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return min_sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n// >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2, (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2, (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n    long min_sum = std::numeric_limits<long>::max();\n    long sum = 0;\n    for (long num : nums) {\n        sum += num;\n        min_sum = std::min(min_sum, sum);\n        if (sum > 0) {\n            sum = 0;\n        }\n    }\n    return min_sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> row_sum(n, 0);\n    std::vector<long> col_sum(m, 0);\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            row_sum[i] += grid[i][j];\n            col_sum[j] += grid[i][j];\n        }\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                long min_capacity = std::min(row_sum[i], col_sum[j]);\n                ans += min_capacity / capacity;\n                if (min_capacity % capacity != 0) {\n                    ans++;\n                }\n                row_sum[i] -= min_capacity;\n                col_sum[j] -= min_capacity;\n            }\n        }\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> row_sum(n, 0);\n    std::vector<long> col_sum(m, 0);\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            row_sum[i] += grid[i][j];\n            col_sum[j] += grid[i][j];\n        }\n    }\n    std::vector<long> row_max(n, 0);\n    std::vector<long> col_max(m, 0);\n    for (long i = 0; i < n; i++) {\n        row_max[i] = *std::max_element(row_sum.begin(), row_sum.begin() + i + 1);\n    }\n    for (long j = 0; j < m; j++) {\n        col_max[j] = *std::max_element(col_sum.begin(), col_sum.begin() + j + 1);\n    }\n    for (long i = 0; i < n;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n\n    for (long i = 0; i < n; i++) {\n        long water = 0;\n        for (long j = 0; j < m; j++) {\n            water += grid[i][j];\n        }\n        ans += (water + capacity - 1) / capacity;\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> row_sum(n, 0);\n    std::vector<long> col_sum(m, 0);\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            row_sum[i] += grid[i][j];\n            col_sum[j] += grid[i][j];\n        }\n    }\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                long min_capacity = std::min(row_sum[i], col_sum[j]);\n                ans += (min_capacity + capacity - 1) / capacity;\n                row_sum[i] -= min_capacity;\n                col_sum[j] -= min_capacity;\n            }\n        }\n    }\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n    long count = 0;\n\n    for (long i = 0; i < rows; i++) {\n        long water = 0;\n        for (long j = 0; j < cols; j++) {\n            water += grid[i][j];\n        }\n        count += water / capacity;\n        if (water % capacity != 0) {\n            count++;\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long result = 0;\n    long total_water = 0;\n    long row = grid.size();\n    long col = grid[0].size();\n\n    for (long i = 0; i < row; i++) {\n        for (long j = 0; j < col; j++) {\n            total_water += grid[i][j];\n        }\n    }\n\n    long bucket_capacity = capacity;\n    while (total_water > 0) {\n        long water_filled = 0;\n        for (long i = 0; i < row; i++) {\n            for (long j = 0; j < col; j++) {\n                if (grid[i][j] > 0) {\n                    if (bucket_capacity > grid[i][j]) {\n                        water_filled += grid[i][j];\n                        grid[i][j] = 0;\n                    } else {\n                        water_filled += bucket_capacity;\n                        grid[i][j] -= bucket_capacity;\n                    }\n                    bucket_capacity = capacity;\n                }\n            }\n        }\n        result += 1;\n        total_water -= water_filled", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long total = 0;\n    long rows = grid.size();\n    long cols = grid[0].size();\n\n    for (long i = 0; i < rows; i++) {\n        long water = 0;\n        for (long j = 0; j < cols; j++) {\n            water += grid[i][j];\n        }\n        total += water / capacity;\n        if (water % capacity != 0) {\n            total++;\n        }\n    }\n\n    return total;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long result = 0;\n    long current_capacity = 0;\n    for (long i = 0; i < grid.size(); i++) {\n        for (long j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                current_capacity += 1;\n                if (current_capacity == capacity) {\n                    result += 1;\n                    current_capacity = 0;\n                }\n            }\n        }\n    }\n    if (current_capacity > 0) {\n        result += 1;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> row_sum(n, 0);\n    std::vector<long> col_sum(m, 0);\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            row_sum[i] += grid[i][j];\n            col_sum[j] += grid[i][j];\n        }\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                long min_capacity = std::min(row_sum[i], col_sum[j]);\n                ans += (min_capacity + capacity - 1) / capacity;\n                row_sum[i] -= min_capacity;\n                col_sum[j] -= min_capacity;\n            }\n        }\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> row_sum(n, 0);\n    std::vector<long> col_sum(m, 0);\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            row_sum[i] += grid[i][j];\n            col_sum[j] += grid[i][j];\n        }\n    }\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                long row_capacity = capacity - row_sum[i];\n                long col_capacity = capacity - col_sum[j];\n                long cell_capacity = std::min(row_capacity, col_capacity);\n                ans += cell_capacity;\n                row_sum[i] -= cell_capacity;\n                col_sum[j] -= cell_capacity;\n            }\n        }\n    }\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long rows = grid.size();\n    long cols = grid[0].size();\n    long total_water = 0;\n    for (long i = 0; i < rows; i++) {\n        for (long j = 0; j < cols; j++) {\n            total_water += grid[i][j];\n        }\n    }\n\n    long times = total_water / capacity;\n    return times;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n        }\n        ans += (sum + capacity - 1) / capacity;\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> row_sum(n, 0);\n    std::vector<long> col_sum(m, 0);\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            row_sum[i] += grid[i][j];\n            col_sum[j] += grid[i][j];\n        }\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                long min_capacity = std::min(row_sum[i], col_sum[j]);\n                ans += (min_capacity + capacity - 1) / capacity;\n                row_sum[i] -= min_capacity;\n                col_sum[j] -= min_capacity;\n            }\n        }\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    for (long i = 0; i < n; i++) {\n        long water = 0;\n        for (long j = 0; j < m; j++) {\n            water += grid[i][j];\n        }\n        ans += (water + capacity - 1) / capacity;\n    }\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long total = 0;\n    long rows = grid.size();\n    long cols = grid[0].size();\n    for (long i = 0; i < rows; i++) {\n        long water = 0;\n        for (long j = 0; j < cols; j++) {\n            water += grid[i][j];\n        }\n        total += water / capacity;\n    }\n    return total;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n\n    for (long i = 0; i < n; i++) {\n        long sum = 0;\n        for (long j = 0; j < m; j++) {\n            sum += grid[i][j];\n        }\n        ans += (sum + capacity - 1) / capacity;\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    long current_fill = 0;\n    for (long i = 0; i < grid.size(); i++) {\n        for (long j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                current_fill++;\n            }\n        }\n        max_fill += std::min(current_fill, capacity);\n        current_fill = 0;\n    }\n    return max_fill;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long total = 0;\n    long rows = grid.size();\n    long cols = grid[0].size();\n    std::vector<long> col_sum(cols, 0);\n\n    for (long i = 0; i < rows; i++) {\n        for (long j = 0; j < cols; j++) {\n            col_sum[j] += grid[i][j];\n        }\n    }\n\n    for (long i = 0; i < cols; i++) {\n        total += col_sum[i] / capacity;\n        if (col_sum[i] % capacity != 0) {\n            total++;\n        }\n    }\n\n    return total;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    long n = grid.size();\n    long m = grid[0].size();\n    for (long i = 0; i < n; i++) {\n        long water = 0;\n        for (long j = 0; j < m; j++) {\n            water += grid[i][j];\n        }\n        ans += (water + capacity - 1) / capacity;\n    }\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1))\n// (6)\n// Example 2:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2))\n// (5)\n// Example 3:\n// >>> max_fill((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5))\n// (0)\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n  long rows = grid.size();\n  long cols = grid[0].size();\n  long total_water = 0;\n  for (long i = 0; i < rows; i++) {\n    for (long j = 0; j < cols; j++) {\n      total_water += grid[i][j];\n    }\n  }\n  long result = total_water / capacity;\n  return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        std::string a_bin = std::bitset<64>(a).to_string();\n        std::string b_bin = std::bitset<64>(b).to_string();\n        int a_ones = std::count(a_bin.begin(), a_bin.end(), '1');\n        int b_ones = std::count(b_bin.begin(), b_bin.end(), '1');\n        return a_ones < b_ones || (a_ones == b_ones && a < b);\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int ones_a = std::bitset<64>(a).count();\n        int ones_b = std::bitset<64>(b).count();\n        return ones_a < ones_b || (ones_a == ones_b && a < b);\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int ones_a = std::bitset<64>(a).count();\n        int ones_b = std::bitset<64>(b).count();\n        return ones_a == ones_b ? a < b : ones_a < ones_b;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int count_a = std::bitset<32>(a).count();\n        int count_b = std::bitset<32>(b).count();\n        if (count_a == count_b)\n            return a < b;\n        return count_a < count_b;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int ones_a = std::bitset<32>(a).count();\n        int ones_b = std::bitset<32>(b).count();\n        if (ones_a == ones_b)\n            return a < b;\n        return ones_a < ones_b;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        auto count_ones = [](long n) {\n            long count = 0;\n            while (n) {\n                count += n & 1;\n                n >>= 1;\n            }\n            return count;\n        };\n        return count_ones(a) < count_ones(b) || (count_ones(a) == count_ones(b) && a < b);\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        auto a_bin = std::bitset<64>(a).count();\n        auto b_bin = std::bitset<64>(b).count();\n        return a_bin == b_bin ? a < b : a_bin < b_bin;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int count_a = std::bitset<32>(a).count();\n        int count_b = std::bitset<32>(b).count();\n        if (count_a == count_b)\n            return a < b;\n        return count_a < count_b;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int ones_a = std::bitset<64>(a).count();\n        int ones_b = std::bitset<64>(b).count();\n        return ones_a < ones_b || (ones_a == ones_b && a < b);\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int count_a = std::bitset<32>(a).count();\n        int count_b = std::bitset<32>(b).count();\n        if (count_a == count_b)\n            return a < b;\n        return count_a < count_b;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        std::string a_bin = std::bitset<64>(a).to_string();\n        std::string b_bin = std::bitset<64>(b).to_string();\n        int a_ones = std::count(a_bin.begin(), a_bin.end(), '1');\n        int b_ones = std::count(b_bin.begin(), b_bin.end(), '1');\n        if (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        auto count_ones = [](long n) {\n            int count = 0;\n            while (n) {\n                count += n & 1;\n                n >>= 1;\n            }\n            return count;\n        };\n        int a_ones = count_ones(a);\n        int b_ones = count_ones(b);\n        return a_ones == b_ones ? a < b : a_ones < b_ones;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int ones_a = std::bitset<64>(a).count();\n        int ones_b = std::bitset<64>(b).count();\n        return ones_a < ones_b || (ones_a == ones_b && a < b);\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        auto count_ones = [](long x) {\n            long count = 0;\n            while (x) {\n                count += x & 1;\n                x >>= 1;\n            }\n            return count;\n        };\n        auto ones_a = count_ones(a);\n        auto ones_b = count_ones(b);\n        return ones_a < ones_b || (ones_a == ones_b && a < b);\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int count_a = std::bitset<32>(a).count();\n        int count_b = std::bitset<32>(b).count();\n        if (count_a == count_b)\n            return a < b;\n        else\n            return count_a < count_b;\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), [](long a, long b) {\n    auto count_ones = [](long n) {\n      long count = 0;\n      while (n) {\n        count += n & 1;\n        n >>= 1;\n      }\n      return count;\n    };\n    auto ones_a = count_ones(a);\n    auto ones_b = count_ones(b);\n    return ones_a == ones_b ? a < b : ones_a < ones_b;\n  });\n  return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n  std::sort(arr.begin(), arr.end(), [](long a, long b) {\n    int count_a = std::bitset<64>(a).count();\n    int count_b = std::bitset<64>(b).count();\n    if (count_a == count_b)\n      return a < b;\n    else\n      return count_a < count_b;\n  });\n  return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        auto count_ones = [](long n) {\n            long count = 0;\n            while (n) {\n                count += n & 1;\n                n >>= 1;\n            }\n            return count;\n        };\n\n        auto ones_a = count_ones(a);\n        auto ones_b = count_ones(b);\n\n        return ones_a == ones_b ? a < b : ones_a < ones_b;\n    });\n\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        int ones_a = std::bitset<64>(a).count();\n        int ones_b = std::bitset<64>(b).count();\n        return ones_a < ones_b || (ones_a == ones_b && a < b);\n    });\n    return arr;", "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to sort a vector of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\n// It must be implemented like this:\n// >>> sort_array((std::vector<long>({(long)1, (long)5, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5}))\n// >>> sort_array((std::vector<long>({(long)-2, (long)-3, (long)-4, (long)-5, (long)-6})))\n// (std::vector<long>({(long)-6, (long)-5, (long)-4, (long)-3, (long)-2}))\n// >>> sort_array((std::vector<long>({(long)1, (long)0, (long)2, (long)3, (long)4})))\n// (std::vector<long>({(long)0, (long)1, (long)2, (long)3, (long)4}))\nstd::vector<long> sort_array(std::vector<long> arr) {\n    std::sort(arr.begin(), arr.end(), [](long a, long b) {\n        std::string a_str = std::bitset<64>(a).to_string();\n        std::string b_str = std::bitset<64>(b).to_string();\n        int a_ones = std::count(a_str.begin(), a_str.end(), '1');\n        int b_ones = std::count(b_str.begin(), b_str.end(), '1');\n        return a_ones < b_ones || (a_ones == b_ones && a < b);\n    });\n    return arr;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long count = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                count++;\n            }\n        }\n        if (count == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::string word;\n    std::istringstream iss(s);\n    while (iss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long count = 0;\n        for (char c : word) {\n            if (std::isalpha(c) && !std::isupper(c))\n                count++;\n        }\n        if (count == n)\n            result.push_back(word);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long count = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                count++;\n            }\n        }\n        if (count == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (std::tolower(c) != 'a' && std::tolower(c) != 'e' &&\n                std::tolower(c) != 'i' && std::tolower(c) != 'o' &&\n                std::tolower(c) != 'u') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long count = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                count++;\n            }\n        }\n        if (count == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' &&\n                c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a vector of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty vector.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\nstd::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string> result;\n    std::stringstream ss(s);\n    std::string word;\n    while (ss >> word) {\n        long consonants = 0;\n        for (char c : word) {\n            if (std::tolower(c) != 'a' && std::tolower(c) != 'e' && std::tolower(c) != 'i' && std::tolower(c) != 'o' && std::tolower(c) != 'u') {\n                consonants++;\n            }\n        }\n        if (consonants == n) {\n            result.push_back(word);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    for (int i = word.length() - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (int i = word.size() - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    int vowel_index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            vowel_index = i;\n            break;\n        }\n    }\n\n    if (vowel_index != -1) {\n        for (int i = vowel_index - 1; i >= 0; i--) {\n            if (vowels.find(word[i]) == std::string::npos) {\n                result += word[i];\n            }\n            else {\n                break;\n            }\n        }\n        result += word[vowel_index];\n        for (int i = vowel_index + 1; i < word.length(); i++) {\n            if (vowels.find(word[i]) == std::string::npos) {\n                result += word[i];\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    for (int i = n - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            return std::string(1, word[i]);\n        }\n    }\n    return \"\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n    for (int i = n - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == n - 1)\n                return \"\";\n            if (vowels.find(word[i - 1]) == std::string::npos &&\n                vowels.find(word[i + 1]) == std::string::npos)\n                return word[i];\n        }\n    }\n    return \"\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (int i = word.length() - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i == 0 || i == word.length() - 1)\n                continue;\n            else if (vowels.find(word[i - 1]) == std::string::npos &&\n                     vowels.find(word[i + 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (int i = word.length() - 2; i >= 0; --i) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    int vowel_index = -1;\n\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            vowel_index = i;\n            break;\n        }\n    }\n\n    if (vowel_index == -1) {\n        return \"\";\n    }\n\n    for (int i = vowel_index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n\n    for (int i = vowel_index + 1; i < word.length(); i++) {\n        if (vowels.find(word[i]) == std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string res = \"\";\n    int n = word.size();\n    for(int i = n - 2; i >= 0; i--){\n        if(vowels.find(word[i]) != std::string::npos){\n            if(i == 0 || vowels.find(word[i - 1]) == std::string::npos){\n                res = word[i];\n                break;\n            }\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    bool is_vowel = false;\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (is_vowel) {\n                result = word[i];\n                break;\n            }\n            is_vowel = true;\n        }\n        else {\n            is_vowel = false;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) == std::string::npos &&\n                i < word.length() - 1 && vowels.find(word[i + 1]) == std::string::npos) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    int vowel_index = -1;\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            vowel_index = i;\n            break;\n        }\n    }\n\n    if (vowel_index == -1 || vowel_index == word.length() - 1 || vowel_index == 0) {\n        return \"\";\n    }\n\n    for (int i = vowel_index - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) == std::string::npos) {\n            for (int j = vowel_index + 1; j < word.length(); j++) {\n                if (vowels.find(word[j]) == std::string::npos) {\n                    result = word[vowel_index];\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.length();\n    for (int i = n - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            return std::string(1, word[i]);\n        }\n    }\n    return \"\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (int i = word.size() - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            result += word[i];\n            break;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (int i = word.size() - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            result += word[i];\n            break;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i > 0 && vowels.find(word[i - 1]) == std::string::npos &&\n                vowels.find(word[i + 1]) == std::string::npos) {\n                return word.substr(i, 1);\n            }\n        }\n    }\n    return \"\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    for (int i = word.length() - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    for (int i = word.size() - 2; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos &&\n            vowels.find(word[i + 1]) == std::string::npos) {\n            return word.substr(i, 1);\n        }\n    }\n    return \"\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel((\"yogurt\"))\n// (\"u\")\n// >>> get_closest_vowel((\"FULL\"))\n// (\"U\")\n// >>> get_closest_vowel((\"quick\"))\n// (\"\")\n// >>> get_closest_vowel((\"ab\"))\n// (\"\")\nstd::string get_closest_vowel(std::string word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result = \"\";\n    for (int i = word.length() - 1; i >= 0; i--) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (i == 0 || vowels.find(word[i - 1]) == std::string::npos) {\n                continue;\n            }\n            if (i == word.length() - 1 || vowels.find(word[i + 1]) == std::string::npos) {\n                continue;\n            }\n            result = word[i];\n            break;\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count = 0;\n  for (char c : s1) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  for (char c : s2) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count == 0)\n    return \"Yes\";\n  else\n    return \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s;\n  for (auto &str : lst) {\n    s += str;\n  }\n  int count = 0;\n  for (auto &c : s) {\n    if (c == '(') {\n      count++;\n    } else {\n      count--;\n    }\n    if (count < 0) {\n      return \"No\";\n    }\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0], s2 = lst[1];\n  int open = 0;\n  for (char c : s1) {\n    if (c == '(')\n      open++;\n    else\n      open--;\n  }\n  if (open != 0)\n    return \"No\";\n  open = 0;\n  for (char c : s2) {\n    if (c == '(')\n      open++;\n    else\n      open--;\n  }\n  if (open != 0)\n    return \"No\";\n  return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count = 0;\n  for (char c : s1) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  count = 0;\n  for (char c : s2) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count = 0;\n  for (char c : s1) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  count = 0;\n  for (char c : s2) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count = 0;\n  for (char c : s1) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  count = 0;\n  for (char c : s2) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0], s2 = lst[1];\n  int count = 0;\n  for (char c : s1) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  count = 0;\n  for (char c : s2) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s;\n  for (auto &str : lst) {\n    s += str;\n  }\n  int count = 0;\n  for (char c : s) {\n    if (c == '(') {\n      count++;\n    } else {\n      count--;\n    }\n    if (count < 0) {\n      return \"No\";\n    }\n  }\n  if (count == 0) {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string str = lst[0] + lst[1];\n  int count = 0;\n  for (char c : str) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s = lst[0] + lst[1];\n  int count = 0;\n  for (char c : s) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n    if (count < 0)\n      return \"No\";\n  }\n  return count == 0 ? \"Yes\" : \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// >>> match_parens((std::vector<std::string>({(std::string)\"()(\", (std::string)\")\"})))\n// (\"Yes\")\n// >>> match_parens((std::vector<std::string>({(std::string)\")\", (std::string)\")\"})))\n// (\"No\")\nstd::string match_parens(std::vector<std::string> lst) {\n  std::string s1 = lst[0];\n  std::string s2 = lst[1];\n  int count = 0;\n  for (char c : s1) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  count = 0;\n  for (char c : s2) {\n    if (c == '(')\n      count++;\n    else\n      count--;\n  }\n  if (count != 0)\n    return \"No\";\n  return \"Yes\";"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n\n    for (long num : arr) {\n        max_heap.push(num);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k)\n            max_heap.pop();\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long> max_heap;\n\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < arr.size(); i++) {\n        pq.push(arr[i]);\n        if (pq.size() > k)\n            pq.pop();\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(res.begin(), res.end());\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> res;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < arr.size(); i++) {\n        if (pq.size() < k) {\n            pq.push(arr[i]);\n        } else if (arr[i] > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n        }\n    }\n    while (!pq.empty()) {\n        res.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(res.begin(), res.end());\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < arr.size(); i++) {\n        if (pq.size() < k) {\n            pq.push(arr[i]);\n        } else if (arr[i] > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (pq.size() < k) {\n            pq.push(arr[i]);\n        } else if (arr[i] > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n        }\n    }\n\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n    for (long i = 0; i < arr.size(); ++i) {\n        if (pq.size() < k) {\n            pq.push(arr[i]);\n        } else if (arr[i] > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n        }\n    }\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n\n    for (long i = 0; i < arr.size(); i++) {\n        if (pq.size() < k) {\n            pq.push(arr[i]);\n        } else if (arr[i] > pq.top()) {\n            pq.pop();\n            pq.push(arr[i]);\n        }\n    }\n\n    while (!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n    for (long num : arr) {\n        max_heap.push(num);\n        if (max_heap.size() > k)\n            max_heap.pop();\n    }\n    std::vector<long> result;\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long> max_heap;\n\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::vector<long> res;\n  std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n  for (long i = 0; i < arr.size(); i++) {\n    pq.push(arr[i]);\n    if (pq.size() > k) {\n      pq.pop();\n    }\n  }\n  while (!pq.empty()) {\n    res.push_back(pq.top());\n    pq.pop();\n  }\n  std::reverse(res.begin(), res.end());\n  return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n  std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n  for (long i = 0; i < arr.size(); i++) {\n    if (pq.size() < k) {\n      pq.push(arr[i]);\n    } else if (arr[i] > pq.top()) {\n      pq.pop();\n      pq.push(arr[i]);\n    }\n  }\n  std::vector<long> res;\n  while (!pq.empty()) {\n    res.push_back(pq.top());\n    pq.pop();\n  }\n  return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long> max_heap;\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n\n    for (long i = 0; i < arr.size(); i++) {\n        max_heap.push(arr[i]);\n        if (max_heap.size() > k) {\n            max_heap.pop();\n        }\n    }\n\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector arr of integers and a positive integer k, return a sorted vector \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum((std::vector<long>({(long)-3, (long)-4, (long)5})), (3))\n// (std::vector<long>({(long)-4, (long)-3, (long)5}))\n// Example 2:\n// >>> maximum((std::vector<long>({(long)4, (long)-4, (long)4})), (2))\n// (std::vector<long>({(long)4, (long)4}))\n// Example 3:\n// >>> maximum((std::vector<long>({(long)-3, (long)2, (long)1, (long)2, (long)-1, (long)-2, (long)1})), (1))\n// (std::vector<long>({(long)2}))\n// Note:\n// 1. The length of the vector will be in the range of [1, 1000].\n// 2. The elements in the vector will be in the range of [-1000, 1000].\n// 3. 0 <= k <= len(arr)\nstd::vector<long> maximum(std::vector<long> arr, long k) {\n    std::vector<long> result;\n    std::priority_queue<long, std::vector<long>, std::greater<long>> max_heap;\n    for (long i = 0; i < arr.size(); i++) {\n        if (max_heap.size() < k) {\n            max_heap.push(arr[i]);\n        } else if (arr[i] > max_heap.top()) {\n            max_heap.pop();\n            max_heap.push(arr[i]);\n        }\n    }\n    while (!max_heap.empty()) {\n        result.push_back(max_heap.top());\n        max_heap.pop();\n    }\n    std::reverse(result.begin(), result.end());\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for(int i = 0; i < lst.size(); i += 2)\n        if(lst[i] % 2 != 0)\n            sum += lst[i];\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for(int i = 0; i < lst.size(); i += 2) {\n        if(lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\n// Examples\n// >>> solution((std::vector<long>({(long)5, (long)8, (long)7, (long)1})))\n// (12)\n// >>> solution((std::vector<long>({(long)3, (long)3, (long)3, (long)3, (long)3})))\n// (9)\n// >>> solution((std::vector<long>({(long)30, (long)13, (long)24, (long)321})))\n// (0)\nlong solution(std::vector<long> lst) {\n    long sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1);\n  assert(k >= 1 && k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    long num = arr[i];\n    if (num >= 100) {\n      continue;\n    }\n    sum += num;\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1);\n  assert(k >= 1 && k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    long num = arr[i];\n    if (num < 10) {\n      sum += num;\n    } else if (num < 100) {\n      sum += num % 10 + num / 10;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        if (arr[i] < 10) {\n            sum += arr[i];\n        } else if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1 && arr.size() <= 100);\n  assert(k >= 1 && k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    if (arr[i] >= 100) {\n      continue;\n    }\n    sum += arr[i];\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        if (arr[i] < 10) {\n            sum += arr[i];\n        } else if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        long num = arr[i];\n        long num_digits = std::to_string(num).length();\n        if (num_digits <= 2) {\n            sum += num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1);\n  assert(k >= 1 && k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    long num = arr[i];\n    while (num > 0) {\n      long digit = num % 10;\n      sum += digit;\n      num /= 10;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    if (arr[i] >= 100) {\n      continue;\n    }\n    sum += arr[i];\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1);\n  assert(k >= 1);\n  assert(k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    long num = arr[i];\n    while (num > 0) {\n      long digit = num % 10;\n      if (digit > 9) {\n        return -1;\n      }\n      sum += digit;\n      num /= 10;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        if (arr[i] < 10) {\n            sum += arr[i];\n        } else if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        long num = arr[i];\n        if (num < 10) {\n            sum += num;\n        } else if (num < 100) {\n            sum += num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    if (arr[i] < 10) {\n      sum += arr[i];\n    } else if (arr[i] < 100) {\n      sum += arr[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1);\n  assert(k >= 1);\n  assert(k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    long num = arr[i];\n    if (num >= 100) {\n      continue;\n    }\n    sum += num;\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        if (arr[i] >= 100) {\n            continue;\n        }\n        sum += arr[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        long num = arr[i];\n        if (num < 10) {\n            sum += num;\n        } else if (num < 100) {\n            sum += num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1 && arr.size() <= 100);\n  assert(k >= 1 && k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    long num = arr[i];\n    while (num > 0) {\n      long digit = num % 10;\n      sum += digit;\n      num /= 10;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n    long sum = 0;\n    for (long i = 0; i < k; i++) {\n        if (arr[i] < 10) {\n            sum += arr[i];\n        } else if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    long num = arr[i];\n    if (num < 10) {\n      sum += num;\n    } else if (num < 100) {\n      sum += num % 10 + num / 10;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  assert(arr.size() >= 1);\n  assert(k >= 1);\n  assert(k <= arr.size());\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    if (arr[i] < 100) {\n      sum += arr[i];\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a non-empty vector of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n// Example:\n// >>> add_elements((std::vector<long>({(long)111, (long)21, (long)3, (long)4000, (long)5, (long)6, (long)7, (long)8, (long)9})), (4))\n// (24)\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nlong add_elements(std::vector<long> arr, long k) {\n  long sum = 0;\n  for (long i = 0; i < k; i++) {\n    if (arr[i] < 10) {\n      sum += arr[i];\n    } else if (arr[i] < 100) {\n      sum += arr[i];\n    }\n  }\n  return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            result.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while(n != 1){\n        if(n % 2 != 0){\n            result.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_collatz.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while(n != 1){\n        if(n % 2 != 0){\n            odd_collatz.push_back(n);\n        }\n        n = (n % 2 == 0) ? n/2 : 3*n + 1;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            result.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            result.push_back(n);\n        }\n        n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while(n != 1){\n        if(n%2 != 0){\n            odd_collatz.push_back(n);\n            n = 3*n + 1;\n        }\n        else{\n            n = n/2;\n        }\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            result.push_back(n);\n        }\n        n = n / 2;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while(n != 1){\n        if(n % 2 != 0){\n            odd_collatz.push_back(n);\n        }\n        n = (n % 2 == 0) ? n/2 : 3*n + 1;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_collatz.push_back(n);\n        }\n        n = n / 2;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while (n != 1) {\n        if (n % 2 == 1) {\n            odd_collatz.push_back(n);\n        }\n        n = n / 2;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            result.push_back(n);\n        }\n        n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            result.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_collatz.push_back(n);\n        }\n        n = n / 2;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> collatz;\n    while (n != 1) {\n        if (n % 2 == 1) {\n            collatz.push_back(n);\n        }\n        n = n / 2;\n    }\n    collatz.push_back(1);\n    std::sort(collatz.begin(), collatz.end());\n    return collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while(n != 1) {\n        if(n % 2 != 0) {\n            odd_collatz.push_back(n);\n        }\n        n = n / 2;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while(n != 1){\n        if(n % 2 != 0){\n            odd_collatz.push_back(n);\n        }\n        n = n / 2;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while (n != 1) {\n        if (n % 2 == 1) {\n            odd_collatz.push_back(n);\n            n = 3 * n + 1;\n        } else {\n            n /= 2;\n        }\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> result;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            result.push_back(n);\n        }\n        n = n % 2 == 0 ? n / 2 : 3 * n + 1;\n    }\n    result.push_back(1);\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return a sorted vector that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned vector sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz((5))\n// (std::vector<long>({(long)1, (long)5}))\nstd::vector<long> get_odd_collatz(long n) {\n    std::vector<long> odd_collatz;\n    while (n != 1) {\n        if (n % 2 != 0) {\n            odd_collatz.push_back(n);\n        }\n        n = (n % 2 == 0) ? n / 2 : 3 * n + 1;\n    }\n    odd_collatz.push_back(1);\n    std::sort(odd_collatz.begin(), odd_collatz.end());\n    return odd_collatz;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    std::vector<std::string> parts;\n\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if (parts.size() != 3)\n        return false;\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    }\n    catch (...) {\n        return false;\n    }\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > 31)\n        return false;\n\n    if (month == 2 && day > 29)\n        return false;\n\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31)\n        return false;\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if(date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    std::vector<std::string> parts;\n\n    while(std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if(parts.size() != 3)\n        return false;\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    } catch(...) {\n        return false;\n    }\n\n    if(month < 1 || month > 12)\n        return false;\n\n    if(day < 1 || day > 31)\n        return false;\n\n    if((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n        return false;\n\n    if(month == 2 && day > 29)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if(date.empty())\n        return false;\n\n    std::regex date_regex(\"^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-[0-9]{4}$\");\n    std::smatch match;\n\n    if(std::regex_match(date, match, date_regex)) {\n        int month = std::stoi(date.substr(0, 2));\n        int day = std::stoi(date.substr(3, 2));\n        int year = std::stoi(date.substr(6, 4));\n\n        if(month < 1 || month > 12)\n            return false;\n\n        if(day < 1 || day > 31)\n            return false;\n\n        if(month == 2) {\n            if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\n                if(day > 29)\n                    return false;\n            }\n            else {\n                if(day > 28)\n                    return false;\n            }\n        }\n        else if(month == 4 || month == 6 || month == 9 || month == 11) {\n            if(day > 30)\n                return false;\n        }\n\n        return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    int month, day, year;\n\n    std::getline(ss, part, '-');\n    month = std::stoi(part);\n\n    std::getline(ss, part, '-');\n    day = std::stoi(part);\n\n    std::getline(ss, part, '-');\n    year = std::stoi(part);\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > 31)\n        return false;\n\n    if (month == 2 && day > 29)\n        return false;\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::vector<std::string> parts;\n    std::stringstream ss(date);\n    std::string part;\n\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if (parts.size() != 3)\n        return false;\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    }\n    catch (...) {\n        return false;\n    }\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > 31)\n        return false;\n\n    if ((month == 2 && day > 29) ||\n        (month == 4 && day > 30) ||\n        (month == 6 && day > 30) ||\n        (month == 9 && day > 30) ||\n        (month == 11 && day > 30))\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    std::vector<std::string> parts;\n\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if (parts.size() != 3)\n        return false;\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    } catch (...) {\n        return false;\n    }\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > 31)\n        return false;\n\n    if (month == 2 && day > 29)\n        return false;\n\n    if (month == 4 || month == 6 || month == 9 || month == 11)\n        if (day > 30)\n            return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.empty())\n    return false;\n\n  std::vector<std::string> date_parts = {\"\", \"\", \"\"};\n  std::stringstream ss(date);\n  std::string part;\n  int i = 0;\n  while (std::getline(ss, part, '-')) {\n    date_parts[i] = part;\n    i++;\n  }\n\n  if (date_parts.size() != 3)\n    return false;\n\n  int month = std::stoi(date_parts[0]);\n  int day = std::stoi(date_parts[1]);\n  int year = std::stoi(date_parts[2]);\n\n  if (month < 1 || month > 12)\n    return false;\n\n  if (day < 1 || day > 31)\n    return false;\n\n  if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n    return false;\n\n  if (month == 2 && day > 29)\n    return false;\n\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if(date.empty())\n        return false;\n\n    std::regex date_regex(\"^(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])-[0-9]{4}$\");\n    std::smatch match;\n\n    if(std::regex_search(date, match, date_regex)) {\n        int month = std::stoi(date.substr(0, 2));\n        int day = std::stoi(date.substr(3, 2));\n        int year = std::stoi(date.substr(6, 4));\n\n        if(month < 1 || month > 12)\n            return false;\n\n        if((month == 4 || month == 6 || month == 9 || month == 11) && day < 1 || day > 30)\n            return false;\n\n        if((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day < 1 || day > 31))\n            return false;\n\n        if(month == 2 && (day < 1 || day > 29))\n            return false;\n\n        if(year < 0 || year > 9999)\n            return false;\n\n        return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.empty())\n    return false;\n\n  std::stringstream ss(date);\n  std::string part;\n  int month, day, year;\n  std::vector<int> days_in_month{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n  std::getline(ss, part, '-');\n  month = std::stoi(part);\n  if (month < 1 || month > 12)\n    return false;\n\n  std::getline(ss, part, '-');\n  day = std::stoi(part);\n  if (day < 1 || day > days_in_month[month - 1])\n    return false;\n\n  std::getline(ss, part, '-');\n  year = std::stoi(part);\n  if (year < 0)\n    return false;\n\n  // Leap year check for February\n  if (month == 2 && day == 29 && (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))\n    return true;\n\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if(date.empty())\n    return false;\n  std::stringstream ss(date);\n  std::string part;\n  std::vector<std::string> parts;\n  while(std::getline(ss, part, '-')) {\n    parts.push_back(part);\n  }\n  if(parts.size() != 3)\n    return false;\n  int month, day, year;\n  try {\n    month = std::stoi(parts[0]);\n    day = std::stoi(parts[1]);\n    year = std::stoi(parts[2]);\n  }\n  catch(...) {\n    return false;\n  }\n  if(month < 1 || month > 12)\n    return false;\n  if(day < 1 || day > 31)\n    return false;\n  if(month == 2 && day > 29)\n    return false;\n  if((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31)\n    return false;\n  if((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n    return false;\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::vector<std::string> parts;\n    std::stringstream ss(date);\n    std::string part;\n\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if (parts.size() != 3)\n        return false;\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    } catch (...) {\n        return false;\n    }\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > 31)\n        return false;\n\n    if (month == 2 && day > 29)\n        return false;\n\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31)\n        return false;\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty()) {\n        return false;\n    }\n\n    std::stringstream ss(date);\n    std::string part;\n    int month, day, year;\n    char dash;\n\n    std::getline(ss, part, '-');\n    month = std::stoi(part);\n\n    std::getline(ss, part, '-');\n    day = std::stoi(part);\n\n    std::getline(ss, part, '-');\n    year = std::stoi(part);\n\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    if (month == 2) {\n        if (day < 1 || day > 29) {\n            return false;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        if (day < 1 || day > 30) {\n            return false;\n        }\n    } else {\n        if (day < 1 || day > 31) {\n            return false;\n        }\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if(date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    std::vector<std::string> parts;\n\n    while(std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if(parts.size() != 3)\n        return false;\n\n    int month = std::stoi(parts[0]);\n    int day = std::stoi(parts[1]);\n    int year = std::stoi(parts[2]);\n\n    if(month < 1 || month > 12)\n        return false;\n\n    if(day < 1 || day > 31)\n        return false;\n\n    if(month == 2) {\n        if(day > 29)\n            return false;\n    }\n    else if(month == 4 || month == 6 || month == 9 || month == 11) {\n        if(day > 30)\n            return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    int month, day, year;\n    std::vector<int> days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    std::getline(ss, part, '-');\n    month = std::stoi(part);\n\n    std::getline(ss, part, '-');\n    day = std::stoi(part);\n\n    std::getline(ss, part, '-');\n    year = std::stoi(part);\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > days_in_month[month - 1])\n        return false;\n\n    if (month == 2 && day > 29)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    std::vector<std::string> parts;\n\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if (parts.size() != 3)\n        return false;\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    }\n    catch (...) {\n        return false;\n    }\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > 31)\n        return false;\n\n    if (month == 2 && day > 29)\n        return false;\n\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31)\n        return false;\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty())\n        return false;\n\n    std::stringstream ss(date);\n    std::string part;\n    std::vector<std::string> parts;\n\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if (parts.size() != 3)\n        return false;\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    } catch (...) {\n        return false;\n    }\n\n    if (month < 1 || month > 12)\n        return false;\n\n    if (day < 1 || day > 31)\n        return false;\n\n    if (month == 2 && day > 29)\n        return false;\n\n    if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31)\n        return false;\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n    if (date.empty()) {\n        return false;\n    }\n\n    std::stringstream ss(date);\n    std::string part;\n    std::vector<std::string> parts;\n\n    while (std::getline(ss, part, '-')) {\n        parts.push_back(part);\n    }\n\n    if (parts.size() != 3) {\n        return false;\n    }\n\n    int month, day, year;\n    try {\n        month = std::stoi(parts[0]);\n        day = std::stoi(parts[1]);\n        year = std::stoi(parts[2]);\n    } catch (...) {\n        return false;\n    }\n\n    if (month < 1 || month > 12) {\n        return false;\n    }\n\n    if (day < 1 || day > 31) {\n        return false;\n    }\n\n    if (month == 2 && day > 29) {\n        return false;\n    }\n\n    if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {\n        return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.empty())\n    return false;\n  std::stringstream ss(date);\n  std::string part;\n  std::vector<std::string> parts;\n  while (std::getline(ss, part, '-')) {\n    parts.push_back(part);\n  }\n  if (parts.size() != 3)\n    return false;\n  int month, day, year;\n  try {\n    month = std::stoi(parts[0]);\n    day = std::stoi(parts[1]);\n    year = std::stoi(parts[2]);\n  } catch (...) {\n    return false;\n  }\n  if (month < 1 || month > 12)\n    return false;\n  if (day < 1 || day > 31)\n    return false;\n  if (month == 2 && day > 29)\n    return false;\n  if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n    return false;\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.empty())\n    return false;\n\n  std::stringstream ss(date);\n  std::string part;\n  std::vector<std::string> parts;\n  while (std::getline(ss, part, '-')) {\n    parts.push_back(part);\n  }\n\n  if (parts.size() != 3)\n    return false;\n\n  int month, day, year;\n  try {\n    month = std::stoi(parts[0]);\n    day = std::stoi(parts[1]);\n    year = std::stoi(parts[2]);\n  } catch (...) {\n    return false;\n  }\n\n  if (month < 1 || month > 12)\n    return false;\n\n  if (day < 1 || day > 31)\n    return false;\n\n  if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30)\n    return false;\n\n  if (month == 2 && day > 29)\n    return false;\n\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You have to write a function which validates a given date string and\n// returns true if the date is valid otherwise false.\n// The date is valid if all of the following rules are satisfied:\n// 1. The date string is not empty.\n// 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n// 3. The months should not be less than 1 or higher than 12.\n// 4. The date should be in the format: mm-dd-yyyy\n// >>> valid_date((\"03-11-2000\"))\n// (true)\n// >>> valid_date((\"15-01-2012\"))\n// (false)\n// >>> valid_date((\"04-0-2040\"))\n// (false)\n// >>> valid_date((\"06-04-2020\"))\n// (true)\n// >>> valid_date((\"06/04/2020\"))\n// (false)\nbool valid_date(std::string date) {\n  if (date.empty())\n    return false;\n  std::vector<std::string> date_parts = {date.substr(0, 2), date.substr(3, 2), date.substr(6, 4)};\n  int month = std::stoi(date_parts[0]);\n  int day = std::stoi(date_parts[1]);\n  int year = std::stoi(date_parts[2]);\n  if (month < 1 || month > 12 || day < 1 || year < 0)\n    return false;\n  if ((month == 2 && day > 29) || (month == 4 && day > 30) || (month == 6 && day > 30) ||\n      (month == 9 && day > 30) || (month == 11 && day > 30) || (month == 1 && day > 31) ||\n      (month == 3 && day > 31) || (month == 5 && day > 31) || (month == 7 && day > 31) ||\n      (month == 8 && day > 31) || (month == 10 && day > 31) || (month == 12 && day > 31))\n    return false;\n  if (date.find(\"-\") == std::string::npos)\n    return false;\n  return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> result;\n    std::stringstream ss(txt);\n    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    if (result.size() == 0) {\n        std::stringstream ss(txt);\n        std::string item;\n        while (std::getline(ss, item, ',')) {\n            if (!item.empty()) {\n                result.push_back(item);\n            }\n        }\n    }\n    if (result.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(result);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    size_t pos = 0;\n    while ((pos = txt.find(' ')) != std::string::npos) {\n        res.push_back(txt.substr(0, pos));\n        txt.erase(0, pos + 1);\n    }\n    if (res.empty()) {\n        pos = 0;\n        while ((pos = txt.find(',')) != std::string::npos) {\n            res.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n    }\n    if (res.empty()) {\n        int count = 0;\n        for (char c : txt) {\n            if ('a' <= c && c <= 'z' && (c - 'a') % 2 == 1)\n                count++;\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (!word.empty())\n            res.push_back(word);\n    }\n    if (res.size() == 0) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            if (!word.empty())\n                res.push_back(word);\n        }\n    }\n    if (res.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1)\n                    count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (!word.empty())\n            res.push_back(word);\n    }\n    if (res.size() == 0) {\n        ss.str(txt);\n        ss.clear();\n        while (std::getline(ss, word, ',')) {\n            if (!word.empty())\n                res.push_back(word);\n        }\n    }\n    if (res.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (std::islower(c)) {\n                if ((c - 'a') % 2 == 1)\n                    count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::string word = \"\";\n    for (char c : txt) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                res.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        res.push_back(word);\n    }\n    if (!res.empty()) {\n        return Union_std_vector_std_string__long(res);\n    }\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            if ((c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return Union_std_vector_std_string__long(count);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    size_t pos = txt.find(' ');\n    if (pos != std::string::npos) {\n        while (pos != std::string::npos) {\n            res.push_back(txt.substr(0, pos));\n            txt = txt.substr(pos + 1);\n            pos = txt.find(' ');\n        }\n        res.push_back(txt);\n        return Union_std_vector_std_string__long(res);\n    }\n    pos = txt.find(',');\n    if (pos != std::string::npos) {\n        while (pos != std::string::npos) {\n            res.push_back(txt.substr(0, pos));\n            txt = txt.substr(pos + 1);\n            pos = txt.find(',');\n        }\n        res.push_back(txt);\n        return Union_std_vector_std_string__long(res);\n    }\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z' && (c - 'a') % 2 == 1) {\n            count++;\n        }\n    }\n    return Union_std_vector_std_string__long(count);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    size_t pos = 0;\n    while ((pos = txt.find(' ')) != std::string::npos) {\n        res.push_back(txt.substr(0, pos));\n        txt.erase(0, pos + 1);\n    }\n    if (res.empty()) {\n        pos = 0;\n        while ((pos = txt.find(',')) != std::string::npos) {\n            res.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n    }\n    if (res.empty()) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        if (!item.empty())\n            res.push_back(item);\n    }\n    if (res.empty()) {\n        std::stringstream ss(txt);\n        std::string item;\n        while (std::getline(ss, item, ',')) {\n            if (!item.empty())\n                res.push_back(item);\n        }\n    }\n    if (res.empty()) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1)\n                    count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    size_t pos = 0;\n    while ((pos = txt.find(' ')) != std::string::npos) {\n        res.push_back(txt.substr(0, pos));\n        txt.erase(0, pos + 1);\n    }\n    if (res.empty()) {\n        pos = 0;\n        while ((pos = txt.find(',')) != std::string::npos) {\n            res.push_back(txt.substr(0, pos));\n            txt.erase(0, pos + 1);\n        }\n    }\n    if (res.empty()) {\n        int count = 0;\n        for (char c : txt) {\n            if ('a' <= c && c <= 'z' && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (!word.empty())\n            res.push_back(word);\n    }\n    if (res.size() == 0) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            if (!word.empty())\n                res.push_back(word);\n        }\n    }\n    if (res.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (std::islower(c)) {\n                if ((c - 'a') % 2 == 1)\n                    count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (!word.empty()) {\n            res.push_back(word);\n        }\n    }\n    if (res.size() == 0) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            if (!word.empty()) {\n                res.push_back(word);\n            }\n        }\n    }\n    if (res.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> result;\n    std::string word = \"\";\n    for (char c : txt) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n    if (!result.empty()) {\n        return Union_std_vector_std_string__long(result);\n    }\n    int count = 0;\n    for (char c : txt) {\n        if (c >= 'a' && c <= 'z') {\n            count += (c - 'a') % 2;\n        }\n    }\n    return Union_std_vector_std_string__long(count);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> result;\n    if (txt.find(' ') != std::string::npos) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (ss >> word) {\n            result.push_back(word);\n        }\n    } else if (txt.find(',') != std::string::npos) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (getline(ss, word, ',')) {\n            result.push_back(word);\n        }\n    } else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(result);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (!word.empty())\n            res.push_back(word);\n    }\n    if (res.size() == 0) {\n        ss.str(txt);\n        ss.clear();\n        while (std::getline(ss, word, ',')) {\n            if (!word.empty())\n                res.push_back(word);\n        }\n    }\n    if (res.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (std::islower(c)) {\n                if ((std::tolower(c) - 'a') % 2 == 1)\n                    count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> result;\n    std::stringstream ss(txt);\n    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        if (!item.empty()) {\n            result.push_back(item);\n        }\n    }\n    if (result.size() == 0) {\n        std::stringstream ss(txt);\n        std::string item;\n        while (std::getline(ss, item, ',')) {\n            if (!item.empty()) {\n                result.push_back(item);\n            }\n        }\n    }\n    if (result.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(result);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> result;\n    std::string word = \"\";\n    for (char c : txt) {\n        if (c == ' ' || c == ',') {\n            if (!word.empty()) {\n                result.push_back(word);\n                word = \"\";\n            }\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) {\n        result.push_back(word);\n    }\n    if (result.empty()) {\n        long count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1) {\n                    count++;\n                }\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(result);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> result;\n    size_t pos = 0;\n    while ((pos = txt.find(' ')) != std::string::npos) {\n        result.push_back(txt.substr(0, pos));\n        txt.erase(0, pos + 1);\n    }\n    if (result.size() == 0) {\n        pos = txt.find(',');\n        if (pos != std::string::npos) {\n            while ((pos = txt.find(',')) != std::string::npos) {\n                result.push_back(txt.substr(0, pos));\n                txt.erase(0, pos + 1);\n            }\n            result.push_back(txt);\n        } else {\n            int count = 0;\n            for (char c : txt) {\n                if (std::islower(c) && ((c - 'a') % 2 == 1)) {\n                    count++;\n                }\n            }\n            return Union_std_vector_std_string__long(count);\n        }\n    }\n    return Union_std_vector_std_string__long(result);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (!word.empty())\n            res.push_back(word);\n    }\n    if (res.size() == 0) {\n        std::stringstream ss(txt);\n        std::string word;\n        while (std::getline(ss, word, ',')) {\n            if (!word.empty())\n                res.push_back(word);\n        }\n    }\n    if (res.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                if ((c - 'a') % 2 == 1)\n                    count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    std::stringstream ss(txt);\n    std::string word;\n    while (std::getline(ss, word, ' ')) {\n        if (!word.empty()) {\n            res.push_back(word);\n        }\n    }\n    if (res.size() == 0) {\n        ss.str(txt);\n        while (std::getline(ss, word, ',')) {\n            if (!word.empty()) {\n                res.push_back(word);\n            }\n        }\n    }\n    if (res.size() == 0) {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z') {\n                count++;\n            }\n        }\n        return Union_std_vector_std_string__long(count);\n    }\n    return Union_std_vector_std_string__long(res);", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_std_vector_std_string__long{\n    std::vector<std::string> f0;\n    long f1;    Union_std_vector_std_string__long(std::vector<std::string> _f0) : f0(_f0) {}\n    Union_std_vector_std_string__long(long _f1) : f1(_f1) {}\n    ~Union_std_vector_std_string__long() {}\n    bool operator==(std::vector<std::string> f) {\n        return f0 == f ;\n    }    bool operator==(long f) {\n        return f1 == f ;\n    }\n};\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>> split_words((\"Hello world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"Hello,world!\"))\n// std::vector<std::string>({(std::string)\"Hello\", (std::string)\"world!\"})\n// >>> split_words((\"abcdef\"))\n// 3\nUnion_std_vector_std_string__long split_words(std::string txt) {\n    std::vector<std::string> res;\n    if (txt.find(' ') != std::string::npos) {\n        std::stringstream ss(txt);\n        std::string item;\n        while (std::getline(ss, item, ' ')) {\n            res.push_back(item);\n        }\n        return res;\n    }\n    else if (txt.find(',') != std::string::npos) {\n        std::stringstream ss(txt);\n        std::string item;\n        while (std::getline(ss, item, ',')) {\n            res.push_back(item);\n        }\n        return res;\n    }\n    else {\n        int count = 0;\n        for (char c : txt) {\n            if (c >= 'a' && c <= 'z' && (c - 'a') % 2 == 1) {\n                count++;\n            }\n        }\n        return count;\n    }"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_set<long> s;\n  for (long i : lst) {\n    if (s.find(i) != s.end()) {\n      return false;\n    }\n    s.insert(i);\n  }\n  return std::is_sorted(lst.begin(), lst.end());", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_set<long> s;\n  for (long i : lst) {\n    if (s.find(i) != s.end()) {\n      return false;\n    }\n    s.insert(i);\n  }\n  return std::is_sorted(lst.begin(), lst.end());", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_set<long> s;\n  for (long i : lst) {\n    if (s.count(i)) {\n      return false;\n    }\n    s.insert(i);\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::set<long> s(lst.begin(), lst.end());\n  return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::set<long> s(lst.begin(), lst.end());\n    return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::unordered_set<long> seen;\n    for (long num : lst) {\n        if (seen.find(num) != seen.end()) {\n            return false;\n        }\n        seen.insert(num);\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::unordered_set<long> s;\n    for (long i : lst) {\n        if (s.find(i) != s.end()) {\n            return false;\n        }\n        s.insert(i);\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::set<long> s(lst.begin(), lst.end());\n    return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_set<long> s;\n  for (long i : lst) {\n    if (s.find(i) != s.end()) {\n      return false;\n    }\n    s.insert(i);\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::unordered_set<long> s;\n    for (long i : lst) {\n        if (s.find(i) != s.end()) {\n            return false;\n        }\n        s.insert(i);\n    }\n    return std::is_sorted(lst.begin(), lst.end());", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_set<long> s;\n  for (long i : lst) {\n    if (s.find(i) != s.end()) {\n      return false;\n    }\n    s.insert(i);\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::set<long> s(lst.begin(), lst.end());\n  return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::set<long> s(lst.begin(), lst.end());\n  return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::set<long> s(lst.begin(), lst.end());\n  return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::unordered_set<long> seen;\n    for (long num : lst) {\n        if (seen.find(num) != seen.end()) {\n            return false;\n        }\n        seen.insert(num);\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::set<long> s(lst.begin(), lst.end());\n  return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::set<long> s(lst.begin(), lst.end());\n  return lst.size() == s.size();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n  std::unordered_set<long> seen;\n  for (long x : lst) {\n    if (seen.count(x)) {\n      return false;\n    }\n    seen.insert(x);\n  }\n  return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::unordered_set<long> s;\n    for (long i : lst) {\n        if (s.find(i) != s.end()) {\n            return false;\n        }\n        s.insert(i);\n    }\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return whether or not they are sorted\n// in ascending order. If vector has more than 1 duplicate of the same\n// number, return false. Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted((std::vector<long>({(long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)6, (long)7})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)3, (long)2, (long)4, (long)5, (long)6, (long)7})))\n// (false)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)3, (long)3, (long)4})))\n// (true)\n// >>> is_sorted((std::vector<long>({(long)1, (long)2, (long)2, (long)2, (long)3, (long)4})))\n// (false)\nbool is_sorted(std::vector<long> lst) {\n    std::unordered_set<long> seen;\n    for (long num : lst) {\n        if (seen.find(num) != seen.end()) {\n            return false;\n        }\n        seen.insert(num);\n    }\n    return true;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i <= sqrt(length); i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i <= std::sqrt(length); i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end) {\n        return \"NO\";\n    }\n\n    long length = end - start + 1;\n\n    if (length == 1) {\n        return \"NO\";\n    }\n\n    bool is_prime = true;\n    for (long i = 2; i * i <= length; i++) {\n        if (length % i == 0) {\n            is_prime = false;\n            break;\n        }\n    }\n\n    return is_prime ? \"YES\" : \"NO\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; ++i)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length <= 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; ++i)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; ++i)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; ++i)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 2)\n        return \"YES\";\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; ++i)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; ++i) {\n        if (length % i == 0)\n            return \"NO\";\n    }\n\n    return \"YES\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given two intervals,\n// where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n// The given intervals are closed which means that the interval (start, end)\n// includes both start and end.\n// For each given interval, it is assumed that its start is less or equal its end.\n// Your task is to determine whether the length of intersection of these two \n// intervals is a prime number.\n// Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n// If the length of the intersection is a prime number, return \"YES\",\n// otherwise, return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output] samples:\n// >>> intersection((std::make_tuple(1, 2)), (std::make_tuple(2, 3)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-1, 1)), (std::make_tuple(0, 4)))\n// (\"NO\")\n// >>> intersection((std::make_tuple(-3, -1)), (std::make_tuple(-5, 5)))\n// (\"YES\")\nstd::string intersection(std::tuple<long, long> interval1, std::tuple<long, long> interval2) {\n    long start1 = std::get<0>(interval1);\n    long end1 = std::get<1>(interval1);\n    long start2 = std::get<0>(interval2);\n    long end2 = std::get<1>(interval2);\n\n    long start = std::max(start1, start2);\n    long end = std::min(end1, end2);\n\n    if (start > end)\n        return \"NO\";\n\n    long length = end - start + 1;\n\n    if (length == 1)\n        return \"NO\";\n\n    for (long i = 2; i * i <= length; i++)\n        if (length % i == 0)\n            return \"NO\";\n\n    return \"YES\";"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long product_signs = 1;\n  long sum_magnitudes = 0;\n  for (long num : arr) {\n    if (num > 0) {\n      product_signs *= 1;\n      sum_magnitudes += num;\n    } else if (num < 0) {\n      product_signs *= -1;\n      sum_magnitudes += -num;\n    } else {\n      product_signs *= 0;\n      sum_magnitudes += 0;\n    }\n  }\n  return product_signs * sum_magnitudes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n    return std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for (long num : arr) {\n    if (num == 0)\n      return 0;\n    prod *= (num > 0) ? 1 : -1;\n    sum += abs(num);\n  }\n  return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n        return std::nullopt;\n\n    long product_of_signs = 1;\n    long sum_of_magnitudes = 0;\n\n    for (long num : arr) {\n        if (num == 0)\n            return 0;\n        else if (num > 0)\n            product_of_signs *= 1;\n        else\n            product_of_signs *= -1;\n\n        sum_of_magnitudes += abs(num);\n    }\n\n    return product_of_signs * sum_of_magnitudes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n        return std::nullopt;\n\n    long product_of_signs = 1;\n    long sum_of_magnitudes = 0;\n\n    for (long num : arr) {\n        if (num == 0)\n            return 0;\n        product_of_signs *= (num > 0) ? 1 : -1;\n        sum_of_magnitudes += abs(num);\n    }\n\n    return product_of_signs * sum_of_magnitudes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return std::nullopt;\n    }\n\n    long product_signs = 1;\n    long sum_magnitudes = 0;\n\n    for (long num : arr) {\n        if (num > 0) {\n            product_signs *= 1;\n            sum_magnitudes += num;\n        } else if (num < 0) {\n            product_signs *= -1;\n            sum_magnitudes += -num;\n        } else {\n            product_signs = 0;\n            sum_magnitudes = 0;\n            break;\n        }\n    }\n\n    return product_signs * sum_magnitudes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n        return std::nullopt;\n\n    long prod = 1;\n    long sum = 0;\n\n    for (auto num : arr) {\n        if (num > 0)\n            prod *= 1;\n        else if (num < 0)\n            prod *= -1;\n        else\n            prod = 0;\n\n        sum += abs(num);\n    }\n\n    return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n        return std::nullopt;\n\n    long prod = 1;\n    long sum = 0;\n\n    for (long num : arr) {\n        if (num == 0)\n            return 0;\n        prod *= (num > 0) ? 1 : -1;\n        sum += abs(num);\n    }\n\n    return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n    return std::nullopt;\n  long sign = 1;\n  long sum = 0;\n  for (auto num : arr) {\n    if (num == 0)\n      return 0;\n    else if (num < 0)\n      sign *= -1;\n    sum += abs(num);\n  }\n  return sign * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n        return std::nullopt;\n\n    long product = 1;\n    long sum = 0;\n    for (long i : arr) {\n        product *= (i > 0) - (i < 0);\n        sum += abs(i);\n    }\n\n    return product * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return std::nullopt;\n    }\n\n    long product = 1;\n    long sum = 0;\n    for (auto num : arr) {\n        if (num > 0) {\n            product *= 1;\n            sum += num;\n        } else if (num < 0) {\n            product *= -1;\n            sum += -num;\n        } else {\n            product = 0;\n            break;\n        }\n    }\n\n    return product * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() == 0)\n        return std::nullopt;\n\n    long prod = 1;\n    long sum = 0;\n\n    for (long num : arr) {\n        if (num > 0)\n            prod *= 1;\n        else if (num < 0)\n            prod *= -1;\n        else\n            prod *= 0;\n\n        sum += abs(num);\n    }\n\n    return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n    return std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\n      product *= 1;\n    else if (i < 0)\n      product *= -1;\n    sum += abs(i);\n  }\n  return product * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return std::nullopt;\n    }\n\n    long product_of_signs = 1;\n    long sum_of_magnitudes = 0;\n\n    for (long num : arr) {\n        if (num > 0) {\n            product_of_signs *= 1;\n            sum_of_magnitudes += num;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n            sum_of_magnitudes += -num;\n        } else {\n            product_of_signs = 0;\n            sum_of_magnitudes = 0;\n            break;\n        }\n    }\n\n    return product_of_signs * sum_of_magnitudes;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n        return std::nullopt;\n\n    long prod = 1;\n    long sum = 0;\n\n    for (long num : arr) {\n        if (num > 0)\n            prod *= 1;\n        else if (num < 0)\n            prod *= -1;\n        else\n            prod = 0;\n\n        sum += abs(num);\n    }\n\n    return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n    return std::nullopt;\n  long product = 1;\n  long sum = 0;\n  for (auto num : arr) {\n    if (num == 0)\n      return 0;\n    product *= (num > 0) ? 1 : -1;\n    sum += abs(num);\n  }\n  return product * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n  }\n  long prod = 1;\n  long sum = 0;\n  for (auto num : arr) {\n    if (num > 0) {\n      prod *= 1;\n      sum += num;\n    } else if (num < 0) {\n      prod *= -1;\n      sum += -num;\n    } else {\n      prod = 0;\n      sum = 0;\n      break;\n    }\n  }\n  return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n        return std::nullopt;\n\n    long prod = 1;\n    long sum = 0;\n\n    for (auto num : arr) {\n        if (num == 0)\n            return 0;\n\n        prod *= (num > 0) ? 1 : -1;\n        sum += abs(num);\n    }\n\n    return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n    return std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for (long num : arr) {\n    if (num > 0)\n      prod *= 1;\n    else if (num < 0)\n      prod *= -1;\n    sum += abs(num);\n  }\n  return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n    return std::nullopt;\n\n  long prod = 1;\n  long sum = 0;\n  for (auto num : arr) {\n    if (num == 0)\n      return 0;\n    else if (num > 0)\n      prod *= 1;\n    else\n      prod *= -1;\n\n    sum += abs(num);\n  }\n\n  return prod * sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the vector, represented by 1, -1 or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\n// 9\n// >>> prod_signs((std::vector<long>({(long)0, (long)1})))\n// 0\n// >>> prod_signs((std::vector<long>()))\n// std::nullopt\nstd::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return std::nullopt;\n    }\n\n    long prod = 1;\n    long sum = 0;\n    for (long num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        prod *= (num > 0) ? 1 : -1;\n        sum += abs(num);\n    }\n\n    return prod * sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> res(k);\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n    std::unordered_set<std::pair<long, long>> visited;\n    visited.insert({0, 0});\n    long count = 0;\n    while (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        res[count] = top.first;\n        count++;\n        if (count == k)\n            break;\n        long x = top.second.first;\n        long y = top.second.second;\n        if (x > 0 && visited.find({x - 1, y}) == visited.end()) {\n            visited.insert({x - 1, y});\n            pq.push({grid[x - 1][y], {x - 1, y}});\n        }\n        if (x < n - 1 && visited.find({x + 1", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans(k);\n    std::vector<std::pair<long, long>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, -1));\n    std::priority_queue<std::pair<long, std::pair<long, long>>,\n                        std::vector<std::pair<long, std::pair<long, long>>>,\n                        std::greater<std::pair<long, std::pair<long, long>>>> pq;\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            pq.push({grid[i][j], {i, j}});\n        }\n    }\n\n    while (!pq.empty()) {\n        long val = pq.top().first;\n        long x = pq.top().second.first;\n        long y = pq.top", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> vis(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    auto is_valid = [&](long x, long y) {\n        return x >= 0 && x < n && y >= 0 && y < n;\n    };\n\n    auto dfs = [&](long x, long y, long k) {\n        if (k == 0) {\n            return;\n        }\n        vis[x][y] = 1;\n        ans.push_back(grid[x][y]);\n        for (auto &dir : dirs) {\n            long nx = x + dir[0];\n            long ny = y + dir[1];\n            if (is_valid(nx, ny) && !", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> vis(n, std::vector<long>(n, 0));\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            pq.push({grid[i][j], {i, j}});\n        }\n    }\n\n    while (!pq.empty()) {\n        long val = pq.top().first;\n        long x = pq.top().second.first;\n        long y = pq.top().second.second;\n        pq.pop();\n\n        if (vis[x][y] == 0) {\n            ans.push_back(val);\n            vis[x][y] = 1;\n            k--;\n        }\n\n       ", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> vis(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>,\n                        std::vector<std::pair<long, std::pair<long, long>>>,\n                        std::greater<std::pair<long, std::pair<long, long>>>>\n        pq;\n\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    vis[0][0] = 1;\n\n    while (!pq.empty()) {\n        auto [val, pos] = pq.top();\n        pq.", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path(n, std::vector<long>(n, 0));\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            dp_path[i][j] = grid[i][j];\n        }\n    }\n\n    for (long step = 1; step < k; step++) {\n        for (long i = 0; i < n; i++) {\n            for (long j = 0; j < n; j++) {\n                long min_val = INT_MAX;\n                long min_idx = -1;\n                if (i > 0) {\n                    if (dp[i - 1][j] < min_val) {\n                        min_val = dp[i - ", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>> dp_path(n, std::vector<long>(n, -1));\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>,\n                        std::vector<std::pair<long, std::pair<long, long>>>,\n                        std::greater<std::pair<long, std::pair<long, long>>>>\n        pq;\n\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    dp_path[0][0] = grid[0][0];\n\n    while (!pq.empty()) {\n        auto curr = pq.top();\n        pq.pop();\n\n        long val = curr.first;\n        long x = curr.second.first;\n        long y = curr.second.second;\n", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans(k);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> vis(n, std::vector<long>(n, 0));\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n\n    while (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n\n        long val = top.first;\n        long x = top.second.first;\n        long y = top.second.second;\n\n        if (vis[x][y] == 1)\n            continue;\n\n        vis[x][y] = 1;\n        dp[x][y] = val;\n", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_cnt(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path_cnt(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path_path(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path_path_cnt(n, std::vector<long>(n, 0));\n\n    std::vector<std::vector<long>> dp_path_path_path(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path_path_path_cnt(n, std::vector", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_cnt(n, std::vector<long>(n, 0));\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    dp_cnt[0][0] = 1;\n\n    long dx[4] = {-1, 1, 0, 0};\n    long dy[4] = {0, 0, -1, 1};\n\n    while (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n\n        long val = top.first;\n        long x = top.second.first;\n        long y = top.second.second;\n\n        if (dp_cnt[x][", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> vis(n, std::vector<long>(n, 0));\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>,\n                        std::vector<std::pair<long, std::pair<long, long>>>,\n                        std::greater<std::pair<long, std::pair<long, long>>>>\n        q;\n\n    q.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    vis[0][0] = 1;\n\n    while (!q.empty()) {\n        long val = q.top().first;\n        long x = q.top().second.first;\n        long y = q.top().second.second;\n        q.pop();\n\n        if (vis[x][y] == k) {\n            ans.", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> vis(n, std::vector<long>(n, 0));\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n\n    while (!pq.empty()) {\n        auto curr = pq.top();\n        pq.pop();\n\n        long val = curr.first;\n        long x = curr.second.first;\n        long y = curr.second.second;\n\n        if (vis[x][y] == 1)\n            continue;\n\n        vis[x][y] = 1;\n        ans.push_back(val);\n\n        if (ans.size() == k)\n            break;\n\n        long dx[] = {-1, 0", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans(k);\n    std::vector<std::pair<long, long>> neighbors = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, -1));\n    std::priority_queue<std::pair<long, std::pair<long, long>>,\n                        std::vector<std::pair<long, std::pair<long, long>>>,\n                        std::greater<std::pair<long, std::pair<long, long>>>>\n        pq;\n\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n\n    while (!pq.empty()) {\n        long val = pq.top().first;\n        long x = pq.top().second.first;\n        long y = pq.top().second.second;\n        pq.pop();\n\n        if (dp[", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> vis(n, std::vector<long>(n, 0));\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            pq.push({grid[i][j], {i, j}});\n        }\n    }\n\n    while (k--) {\n        long val = pq.top().first;\n        long x = pq.top().second.first;\n        long y = pq.top().second.second;\n        pq.pop();\n\n        if (vis[x][y]) {\n            continue;\n        }\n\n        ans.push_back(val);\n        vis[x][y] = 1;\n\n        if (x > 0", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(n, 0));\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>,\n                        std::vector<std::pair<long, std::pair<long, long>>>,\n                        std::greater<std::pair<long, std::pair<long, long>>>>\n        q;\n\n    q.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    visited[0][0] = 1;\n\n    long dx[] = {0, 0, 1, -1};\n    long dy[] = {1, -1, 0, 0};\n\n    while (!q.empty()) {\n        long val = q.top().first;\n        long x = q.top().second.first;\n", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_cnt(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_path_cnt(n, std::vector<long>(n, 0));\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            dp_cnt[i][j] = 1;\n            dp_path[i][j] = grid[i][j];\n            dp_path_cnt[i][j] = 1;\n        }\n    }\n\n    for (long step = 1; step < k; step++) {\n        for (", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans(k);\n    std::vector<std::pair<long, long>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::priority_queue<std::pair<long, std::pair<long, long>>,\n                        std::vector<std::pair<long, std::pair<long, long>>>,\n                        std::greater<std::pair<long, std::pair<long, long>>>> pq;\n\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            pq.push({grid[i][j], {i, j}});\n        }\n    }\n\n    while (k--) {\n        auto curr = pq.top();\n        pq.pop();\n        long", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n    std::vector<std::vector<long>> dp_cnt(n, std::vector<long>(n, 0));\n\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long, std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n\n    while (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n\n        long val = top.first;\n        long x = top.second.first;\n        long y = top.second.second;\n\n        if (dp_cnt[x][y] >= k) {\n            ans.push_back(val);\n            break;\n        }\n\n        if (x > 0 &&", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::pair<long, long>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    auto isValid = [&](long x, long y) {\n        return x >= 0 && x < n && y >= 0 && y < n;\n    };\n\n    auto dfs = [&](long x, long y, long k) {\n        if (k == 0) {\n            return;\n        }\n        ans.push_back(grid[x][y]);\n        std::sort(ans.begin(), ans.end());\n        for (auto &dir : directions) {\n            long nx = x + dir.first;\n            long ny = y + dir.second;\n            if (isValid(nx, ny) && std::find(ans.begin(), ans.end(), grid[nx][ny]) == ans.end()) {\n                dfs(nx, ny, k - 1);\n                if (ans.size() == k) {\n                    return;\n", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered vectors of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered vector of the values on the cells that the minimum path go through.\n// Examples:    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n// (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5, (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n// (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n    long n = grid.size();\n    std::vector<long> ans(k);\n    std::priority_queue<std::pair<long, std::pair<long, long>>> pq;\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));\n    pq.push({grid[0][0], {0, 0}});\n    visited[0][0] = true;\n    long count = 0;\n    while (!pq.empty()) {\n        long val = pq.top().first;\n        long x = pq.top().second.first;\n        long y = pq.top().second.second;\n        pq.pop();\n        ans[count] = val;\n        count++;\n        if (count == k)\n            break;\n        long dx[4] = {-1, 1, 0, 0};\n        long dy[4] = {0, 0, -1, 1};\n        for (long i = 0; i < 4; i++) {\n            long nx = x + dx[i];\n            long"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1, 0);\n    result[1] = 3;\n    for (long i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1, 0);\n    res[1] = 3;\n    for (long i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1);\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n    for (long i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1);\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1);\n    res[1] = 3;\n    for (long i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1);\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1);\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1, 0);\n    res[1] = 3;\n    for (long i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1);\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1, 0);\n    result[1] = 3;\n    for (long i = 2; i <= n; i++) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1);\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1);\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n\n    for (long i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1);\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> result(n + 1);\n    result[0] = 1;\n    result[1] = 3;\n    result[2] = 2;\n\n    for (long i = 3; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = 1 + i / 2;\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1, 0);\n    res[1] = 3;\n    for (long i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1, 0);\n    res[1] = 3;\n    for (long i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1);\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1, 0);\n    res[1] = 3;\n    for (long i = 2; i <= n; ++i) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1);\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n\n    return res;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative integer number n, you have to a return a vector of the \n// first n + 1 numbers of the Tribonacci sequence.\n// Examples:\n// >>> tri((3))\n// (std::vector<long>({(long)1, (long)3, (long)2, (long)8}))\nstd::vector<long> tri(long n) {\n    std::vector<long> res(n + 1);\n    res[0] = 1;\n    res[1] = 3;\n    res[2] = 2;\n\n    for (long i = 3; i <= n; i++) {\n        if (i % 2 == 0) {\n            res[i] = 1 + i / 2;\n        } else {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n\n    return res;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n) {\n        int digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool found = false;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            found = true;\n        }\n        n /= 10;\n    }\n    return found ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool found_odd = false;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            found_odd = true;\n        }\n        n /= 10;\n    }\n    return found_odd ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n) {\n        int digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool has_odd = false;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool has_odd = false;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while(n > 0) {\n        long digit = n % 10;\n        if(digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool found = false;\n    while (n) {\n        int digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            found = true;\n        }\n        n /= 10;\n    }\n    return found ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool found = false;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            found = true;\n        }\n        n /= 10;\n    }\n    return found ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool found_odd = false;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            found_odd = true;\n        }\n        n /= 10;\n    }\n    return found_odd ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    bool hasOddDigit = false;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n        n /= 10;\n    }\n    return hasOddDigit ? product : 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\n// For example:\n// >>> digits((1))\n// (1)\n// >>> digits((4))\n// (0)\n// >>> digits((235))\n// (15)\nlong digits(long n) {\n    long product = 1;\n    while (n > 0) {\n        long digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n        }\n        n /= 10;\n    }\n    return product;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for(char c : string) {\n        if(c == '[') {\n            stack.push(c);\n        } else {\n            if(stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"[[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>> is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n// >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n// (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return !stack.empty();"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto i : lst) {\n    sum += ceil(i) * ceil(i);\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    sum += ceil(num) * ceil(num);\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    sum += ceil(num) * ceil(num);\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto i : lst) {\n        sum += ceil(i) * ceil(i);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto x : lst) {\n    sum += ceil(x) * ceil(x);\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    sum += ceil(num) * ceil(num);\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto i : lst) {\n        sum += ceil(i) * ceil(i);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    sum += ceil(num) * ceil(num);\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    sum += ceil(num) * ceil(num);\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        sum += ceil(num) * ceil(num);\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of numbers.\n// You need to return the sum of squared numbers in the given vector,\n// round each element in the vector to the upper int(Ceiling) first.\n// Examples:\n// >>> lst((std::vector<float>({(float)1.0f, (float)2.0f, (float)3.0f})))\n// (14)\n// >>> lst((std::vector<float>({(float)1.0f, (float)4.0f, (float)9.0f})))\n// (98)\n// >>> lst((std::vector<float>({(float)1.0f, (float)3.0f, (float)5.0f, (float)7.0f})))\n// (84)\n// >>> lst((std::vector<float>({(float)1.4f, (float)4.2f, (float)0.0f})))\n// (29)\n// >>> lst((std::vector<float>({(float)-2.4f, (float)1.0f, (float)1.0f})))\n// (6)\nlong sum_squares(std::vector<float> lst) {\n    long sum = 0;\n    for (auto x : lst) {\n        sum += ceil(x) * ceil(x);\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.size() - 1];\n  if (isalpha(last_char)) {\n    if (txt.size() > 1 && isalpha(txt[txt.size() - 2]))\n      return false;\n    else\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.size() - 1];\n  if (isalpha(last_char)) {\n    if (txt.size() > 1 && isalpha(txt[txt.size() - 2]))\n      return false;\n    else\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    char last_char = txt[txt.size() - 1];\n    if (!isalpha(last_char))\n        return false;\n\n    if (txt.size() == 1)\n        return true;\n\n    char second_last_char = txt[txt.size() - 2];\n    if (isspace(second_last_char))\n        return true;\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    char last_char = txt[txt.length() - 1];\n    if (isalpha(last_char)) {\n        if (txt.length() > 1 && txt[txt.length() - 2] != ' ')\n            return false;\n        return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.size() - 1];\n  if (isalpha(last_char)) {\n    if (txt.size() > 1 && isalpha(txt[txt.size() - 2]))\n      return false;\n    else\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    char last_char = txt[txt.size() - 1];\n    if (!isalpha(last_char)) {\n        return false;\n    }\n\n    if (txt.size() > 1 && isalpha(txt[txt.size() - 2])) {\n        return false;\n    }\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    char last_char = txt[txt.length() - 1];\n\n    if (isalpha(last_char)) {\n        if (txt.length() > 1 && txt[txt.length() - 2] != ' ')\n            return false;\n        return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    char last_char = txt[txt.size() - 1];\n\n    if (isalpha(last_char) && txt.size() > 1 && txt[txt.size() - 2] != ' ') {\n        return false;\n    }\n\n    return isalpha(last_char);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.size() - 1];\n  if (isalpha(last_char) && txt[txt.size() - 2] == ' ')\n    return true;\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    // Remove trailing spaces\n    txt.erase(txt.find_last_not_of(' ') + 1);\n\n    // Check if last character is alphabetical\n    if (!isalpha(txt.back()))\n        return false;\n\n    // Check if last character is part of a word\n    if (txt.find_last_of(' ') == txt.length() - 1)\n        return false;\n\n    return true;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.length() - 1];\n  if (isalpha(last_char))\n    return true;\n  else\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    // Remove trailing spaces\n    txt.erase(txt.find_last_not_of(' ') + 1);\n\n    // Check if the last character is an alphabetical character\n    if (std::isalpha(txt.back()))\n        return true;\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.length() - 1];\n  if (isalpha(last_char)) {\n    if (txt.length() > 1 && txt[txt.length() - 2] != ' ')\n      return false;\n    return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.size() - 1];\n  if (isalpha(last_char)) {\n    if (txt.size() == 1)\n      return true;\n    char second_last_char = txt[txt.size() - 2];\n    if (isspace(second_last_char))\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.size() - 1];\n  if (isalpha(last_char) && txt[txt.size() - 2] == ' ')\n    return true;\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    // Remove trailing spaces\n    txt.erase(txt.find_last_not_of(' ') + 1);\n\n    // Check if last character is alphabetical\n    return std::isalpha(txt.back());", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    char last_char = txt[txt.size() - 1];\n    if (isalpha(last_char))\n        return true;\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty())\n        return false;\n\n    char last_char = txt[txt.length() - 1];\n    if (isalpha(last_char)) {\n        if (txt.length() == 1)\n            return true;\n\n        char second_last_char = txt[txt.length() - 2];\n        if (isspace(second_last_char))\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n  if (txt.empty())\n    return false;\n  char last_char = txt[txt.size() - 1];\n  if (isalpha(last_char)) {\n    if (txt.size() > 1 && isalpha(txt[txt.size() - 2]))\n      return false;\n    else\n      return true;\n  }\n  return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns true if the last character\n// of a given string is an alphabetical character and is not\n// a part of a word, and false otherwise.\n// Note: \"word\" is a group of characters separated by space.\n// Examples:\n// >>> check_if_last_char_is_a_letter((\"apple pie\"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"apple pi e\"))\n// (true)\n// >>> check_if_last_char_is_a_letter((\"apple pi e \"))\n// (false)\n// >>> check_if_last_char_is_a_letter((\"\"))\n// (false)\nbool check_if_last_char_is_a_letter(std::string txt) {\n    if (txt.empty()) {\n        return false;\n    }\n\n    char last_char = txt[txt.size() - 1];\n\n    if (isalpha(last_char)) {\n        if (txt.size() == 1) {\n            return true;\n        }\n\n        char second_last_char = txt[txt.size() - 2];\n\n        if (isspace(second_last_char)) {\n            return true;\n        }\n    }\n\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    std::vector<long> stack;\n    for(long i = 0; i < arr.size(); i++) {\n        if(stack.empty() || arr[i] <= arr[stack.back()]) {\n            stack.push_back(i);\n        }\n        else {\n            while(!stack.empty() && arr[i] > arr[stack.back()]) {\n                stack.pop_back();\n            }\n            if(stack.empty()) {\n                stack.push_back(i);\n            }\n            else {\n                stack.back() = i;\n            }\n        }\n    }\n    if(stack.empty()) {\n        return -1;\n    }\n    return stack.back();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long max_index = -1;\n    long max_element = -1;\n\n    for (long i = n - 1; i >= 0; i--) {\n        if (arr[i] >= max_element) {\n            max_element = arr[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long index = -1;\n    long max_index = -1;\n    for (long i = n - 2; i >= 0; i--) {\n        if (arr[i] >= arr[i + 1]) {\n            index = i;\n            break;\n        }\n    }\n    if (index != -1) {\n        max_index = index;\n        for (long i = index + 1; i < n; i++) {\n            if (arr[i] > arr[index]) {\n                max_index = i;\n            }\n        }\n    }\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    std::stack<long> s;\n    long n = arr.size();\n    long ans = -1;\n    for (long i = 0; i < n; i++) {\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\n            s.pop();\n        }\n        if (!s.empty()) {\n            ans = std::max(ans, s.top());\n        }\n        s.push(i);\n    }\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long max_index = -1;\n    for (long i = n - 2; i >= 0; i--) {\n        if (arr[i] < arr[i + 1]) {\n            max_index = i;\n            break;\n        }\n    }\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long max_index = -1;\n    long max_val = -1;\n\n    for (long i = n - 1; i >= 0; i--) {\n        if (arr[i] >= max_val) {\n            max_val = arr[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long index = -1;\n    for(long i = 0; i < n - 1; i++) {\n        if(arr[i] >= arr[i + 1]) {\n            index = i;\n        }\n    }\n    return index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    std::stack<long> st;\n    long n = arr.size();\n    long ans = -1;\n    for(long i = 0; i < n; i++) {\n        while(!st.empty() && arr[i] < arr[st.top()]) {\n            ans = std::max(ans, st.top());\n            st.pop();\n        }\n        st.push(i);\n    }\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long max_index = -1;\n    long max_element = -1;\n\n    for (long i = n - 1; i >= 0; i--) {\n        if (arr[i] >= max_element) {\n            max_element = arr[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    std::vector<long> stack;\n    long n = arr.size();\n    for (long i = 0; i < n; i++) {\n        if (stack.empty() || arr[i] <= arr[stack.back()]) {\n            stack.push_back(i);\n        }\n    }\n    if (stack.size() == 1) {\n        return -1;\n    }\n    return stack[stack.size() - 2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long max_index = -1;\n    long max_val = -1;\n    for (long i = n - 1; i >= 0; i--) {\n        if (arr[i] >= max_val) {\n            max_val = arr[i];\n            max_index = i;\n        }\n    }\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long index = -1;\n    long max_index = -1;\n    for (long i = 0; i < n; i++) {\n        if (arr[i] >= arr[i - 1]) {\n            index = i;\n        }\n        if (index != -1 && arr[i] < arr[index]) {\n            max_index = std::max(max_index, index);\n            index = -1;\n        }\n    }\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long index = -1;\n    for (long i = 0; i < n - 1; i++) {\n        if (arr[i] >= arr[i + 1]) {\n            index = i;\n        }\n    }\n    return index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long max_index = -1;\n    long max_val = -1;\n    for (long i = n - 1; i >= 0; i--) {\n        if (arr[i] < max_val) {\n            max_index = i;\n            break;\n        }\n        max_val = arr[i];\n    }\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long max_index = -1;\n    for (long i = 0; i < n - 1; i++) {\n        if (arr[i] >= arr[i + 1]) {\n            max_index = i;\n        }\n    }\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n  long n = arr.size();\n  long max_index = -1;\n  long max_val = -1;\n  for (long i = n - 1; i >= 0; i--) {\n    if (arr[i] >= max_val) {\n      max_val = arr[i];\n      max_index = i;\n    }\n  }\n  return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long index = -1;\n    long max_index = -1;\n    for (long i = n - 2; i >= 0; i--) {\n        if (arr[i] >= arr[i + 1]) {\n            index = i;\n        }\n        if (index != -1 && arr[i] > arr[index]) {\n            max_index = i;\n        }\n    }\n    return max_index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long index = -1;\n    for (long i = n - 2; i >= 0; i--) {\n        if (arr[i] < arr[i + 1]) {\n            index = i;\n            break;\n        }\n    }\n    return index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    std::stack<long> s;\n    long n = arr.size();\n    long index = -1;\n\n    for (long i = 0; i < n; i++) {\n        while (!s.empty() && arr[s.top()] > arr[i]) {\n            index = std::max(index, s.top());\n            s.pop();\n        }\n        s.push(i);\n    }\n\n    return index;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given vector will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)4, (long)3, (long)5})))\n// (3)\n// >>> can_arrange((std::vector<long>({(long)1, (long)2, (long)3})))\n// (-1)\nlong can_arrange(std::vector<long> arr) {\n    long n = arr.size();\n    long index = -1;\n    long max_index = -1;\n    for (long i = n - 1; i >= 0; i--) {\n        if (arr[i] >= arr[i + 1]) {\n            index = i;\n        }\n        if (index != -1 && arr[i] < arr[index]) {\n            max_index = i;\n        }\n    }\n    return max_index;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0 && (largest_negative == std::nullopt || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == std::nullopt || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        }\n        else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative) {\n                largest_negative = num;\n            }\n        }\n        else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (auto num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0 && (largest_negative == std::nullopt || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == std::nullopt || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0 && (largest_negative == std::nullopt || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == std::nullopt || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n  for (long num : lst) {\n    if (num < 0) {\n      if (!largest_negative || num > largest_negative.value()) {\n        largest_negative = num;\n      }\n    } else if (num > 0) {\n      if (!smallest_positive || num < smallest_positive.value()) {\n        smallest_positive = num;\n      }\n    }\n  }\n  return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (auto num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0 && (largest_negative == std::nullopt || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == std::nullopt || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n  std::optional<long> largest_negative = std::nullopt;\n  std::optional<long> smallest_positive = std::nullopt;\n  for (long i : lst) {\n    if (i < 0) {\n      if (!largest_negative || i > largest_negative.value()) {\n        largest_negative = i;\n      }\n    } else if (i > 0) {\n      if (!smallest_positive || i < smallest_positive.value()) {\n        smallest_positive = i;\n      }\n    }\n  }\n  return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        }\n        else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (auto num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative.value()) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive.value()) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0 && (largest_negative == std::nullopt || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == std::nullopt || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a vector.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// >>> largest_smallest_integers((std::vector<long>({(long)2, (long)4, (long)1, (long)3, (long)5, (long)7})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(1))\n// >>> largest_smallest_integers((std::vector<long>()))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\n// >>> largest_smallest_integers((std::vector<long>({(long)0})))\n// std::make_tuple(std::optional<long>(std::nullopt), std::optional<long>(std::nullopt))\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n    std::optional<long> largest_negative = std::nullopt;\n    std::optional<long> smallest_positive = std::nullopt;\n\n    for (long num : lst) {\n        if (num < 0) {\n            if (!largest_negative || num > largest_negative) {\n                largest_negative = num;\n            }\n        }\n        else if (num > 0) {\n            if (!smallest_positive || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return std::make_tuple(largest_negative, smallest_positive);"], ["#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0 && b.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0 && b.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\" && b.f2 != \"\") {\n        std::replace(a.f2.begin(), a.f2.end(), ',', '.');\n        std::replace(b.f2.begin(), b.f2.end(), ',', '.');\n        return std::stof(a.f2) > std::stof(b.f2) ? a : b;\n    }\n    if (a.f", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return a.f0 > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f1 > b", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return a.f0 > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f1 > b", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 > b.f0) {\n        return a.f0;\n    }\n    if (a.f1 > b.f1) {\n        return a.f1;\n    }\n    if (a.f2 > b.f2) {\n        return a.f2;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 > b.f0) {\n        return a.f0;\n    }\n    if (a.f1 > b.f1) {\n        return a.f1;\n    }\n    if (a.f2 > b.f2) {\n        return a.f2;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 > b.f0) {\n        return a.f0;\n    }\n    if (a.f1 > b.f1) {\n        return a.f1;\n    }\n    if (a.f2 > b.f2) {\n        return a.f2;\n    }\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\") {\n        std::replace(a.f2.begin(), a.f2.end(), ',', '.');\n        std::stringstream ss(a.f2);\n        float f;\n        ss >> f;\n        return f > b.f1 ? a : b;\n    }\n    return std::nullopt;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return a.f0 > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f1 > b", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\") {\n        std::replace(a.f2.begin(), a.f2.end(), ',', '.');\n        std::stringstream ss(a.f2);\n        float f;\n        ss >> f;\n        return f > b.f1 ? a : b;\n    }\n    return std::nullopt;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\") {\n        std::replace(a.f2.begin(), a.f2.end(), ',', '.');\n        std::stringstream ss(a.f2);\n        float f;\n        ss >> f;\n        return f > b.f1 ? a : b;\n    }\n    return std::nullopt;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\") {\n        std::replace(a.f2.begin(), a.f2.end(), ',', '.');\n        std::stringstream ss(a.f2);\n        float f;\n        ss >> f;\n        return f > b.f1 ? a : b;\n    }\n    return std::nullopt;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return a.f0 > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f1 > b", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b)\n        return std::nullopt;\n    if (a.f0 > b.f0)\n        return a.f0;\n    if (a.f1 > b.f1)\n        return a.f1;\n    if (a.f2 > b.f2)\n        return a.f2;\n    return b;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\") {\n        std::replace(a.f2.begin(), a.f2.end(), ',', '.');\n        std::stringstream ss(a.f2);\n        float f;\n        ss >> f;\n        return f > b.f1 ? a : b;\n    }\n    return std::nullopt;", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return a.f0 > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f1 > b", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return a.f0 > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f1 > b", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return a.f0 > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f1 > b", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0 && b.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0 && b.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\" && b.f2 != \"\") {\n        std::string a_str = a.f2;\n        std::string b_str = b.f2;\n        std::replace(a_str.begin(), a_str.end(), ',', '.');\n        std::replace(b_str.begin(), b_str.end(), ',', '.');\n        float a_float = std::stof(a_str", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        if (b.f0 != 0) {\n            return a.f0 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return a.f0 > b.f1 ? a : b;\n        }\n        if (b.f2 != \"\") {\n            return std::stof(a.f2) > std::stof(b.f2) ? a : b;\n        }\n    }\n    if (a.f1 != 0) {\n        if (b.f0 != 0) {\n            return a.f1 > b.f0 ? a : b;\n        }\n        if (b.f1 != 0) {\n            return", "#include<assert.h>\n#include<bits/stdc++.h>\nunion Union_long_float_std_string{\n    long f0;\n    float f1;\n    std::string f2;    Union_long_float_std_string(long _f0) : f0(_f0) {}\n    Union_long_float_std_string(float _f1) : f1(_f1) {}\n    Union_long_float_std_string(std::string _f2) : f2(_f2) {}\n    ~Union_long_float_std_string() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }\n};\nunion Union_long_float_std_string_std_nullopt{\n    long f0;\n    float f1;\n    std::string f2;\n    std::nullopt f3;    Union_long_float_std_string_std_nullopt(long _f0) : f0(_f0) {}\n    Union_long_float_std_string_std_nullopt(float _f1) : f1(_f1) {}\n    Union_long_float_std_string_std_nullopt(std::string _f2) : f2(_f2) {}\n    Union_long_float_std_string_std_nullopt(std::nullopt _f3) : f3(_f3) {}\n    ~Union_long_float_std_string_std_nullopt() {}\n    bool operator==(long f) {\n        return f0 == f ;\n    }    bool operator==(float f) {\n        return f1 == f ;\n    }    bool operator==(std::string f) {\n        return f2 == f ;\n    }    bool operator==(std::nullopt f) {\n        return f3 == f ;\n    }\n};\n// Create a function that takes integers, floats, or strings representing\n// real numbers, and returns the larger variable in its given variable type.\n// Return None if the values are equal.\n// Note: If a real number is represented as a string, the floating point might be . or ,\n// >>> compare_one(1, 2.5f)\n// 2.5f\n// >>> compare_one(1, \"2,3\")\n// \"2,3\"\n// >>> compare_one(\"5,1\", \"6\")\n// \"6\"\n// >>> compare_one(\"1\", 1)\n// std::nullopt\nUnion_long_float_std_string_std_nullopt compare_one(Union_long_float_std_string a, Union_long_float_std_string b) {\n    if (a == b) {\n        return std::nullopt;\n    }\n    if (a.f0 != 0) {\n        return a.f0 > b.f0 ? a : b;\n    }\n    if (a.f1 != 0) {\n        return a.f1 > b.f1 ? a : b;\n    }\n    if (a.f2 != \"\") {\n        std::replace(a.f2.begin(), a.f2.end(), ',', '.');\n        std::stringstream ss(a.f2);\n        float f;\n        ss >> f;\n        return f > b.f1 ? a : b;\n    }\n    return std::nullopt;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n <= 0) {\n        return false;\n    }\n    long sum = 0;\n    long count = 0;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count += 1;\n        }\n        n -= 1;\n    }\n    return (count == 4 && sum % 2 == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n    return (count == 4 && sum % 2 == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n <= 0)\n        return false;\n\n    // Check if n is even\n    if (n % 2 != 0)\n        return false;\n\n    // Check if n can be written as the sum of 4 even numbers\n    long sum = 0;\n    for (long i = 2; i <= n / 4; i += 2) {\n        sum += i;\n        if (sum == n)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n <= 0)\n        return false;\n\n    long count = 0;\n    long sum = 0;\n\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n\n    if (count == 4 && sum % 2 == 0)\n        return true;\n    else\n        return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while(n > 0) {\n        if(n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if(n%2 != 0)\n        return false;\n\n    long sum = 0;\n    long i = 2;\n\n    while(sum <= n){\n        sum += i;\n        i += 2;\n    }\n\n    if(sum == n)\n        return true;\n    else\n        return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n <= 0)\n        return false;\n\n    long sum = 0;\n    long count = 0;\n\n    for (long i = 2; i <= n; i += 2) {\n        sum += i;\n        count++;\n\n        if (sum > n)\n            break;\n\n        if (sum == n && count == 4)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if(n%2 != 0)\n        return false;\n\n    long sum = 0;\n    long count = 0;\n    while(n > 0){\n        if(n%2 == 0){\n            sum += n;\n            count++;\n        }\n        n -= 1;\n    }\n\n    if(count == 4 && sum%2 == 0)\n        return true;\n    else\n        return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while(n > 0) {\n        if(n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n -= 1;\n    }\n    if(count == 4 && sum % 2 == 0) {\n        return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n <= 0)\n        return false;\n\n    long count = 0;\n    long sum = 0;\n\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n <= 0)\n        return false;\n\n    long sum = 0;\n    long count = 0;\n\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while(n > 0){\n        if(n % 2 == 0){\n            sum += n;\n            count++;\n        }\n        n -= 1;\n    }\n    if(count == 4 && sum % 2 == 0){\n        return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while(n > 0) {\n        if(n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while(n > 0) {\n        if(n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n % 2 != 0)\n        return false;\n\n    long sum = 0;\n    long count = 0;\n\n    for (long i = 2; i <= n / 2; i += 2) {\n        sum += i;\n        count += 1;\n\n        if (sum > n)\n            return false;\n\n        if (sum == n && count == 4)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n--;\n    }\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    long count = 0;\n    long sum = 0;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n -= 1;\n    }\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n <= 0)\n        return false;\n\n    long sum = 0;\n    long count = 0;\n\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count++;\n        }\n        n -= 1;\n    }\n\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if (n % 2 != 0)\n        return false;\n\n    long sum = 0;\n    long count = 0;\n    while (n > 0) {\n        if (n % 2 == 0) {\n            sum += n;\n            count += 1;\n        }\n        n -= 1;\n    }\n\n    return count == 4 && sum % 2 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n// Example\n// >>> is_equal_to_sum_even((4))\n// (false)\n// >>> is_equal_to_sum_even((6))\n// (false)\n// >>> is_equal_to_sum_even((8))\n// (true)\nbool is_equal_to_sum_even(long n) {\n    if(n%2!=0)\n        return false;\n    long sum=0;\n    for(long i=2;i<=n/4;i+=2){\n        sum+=i;\n    }\n    if(sum==n)\n        return true;\n    else\n        return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long result = 1;\n  for (long i = n; i >= 1; i--) {\n    result *= i;\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; --i) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= std::tgamma(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    while (n > 0) {\n        result *= std::tgamma(n + 1);\n        n--;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= std::tgamma(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    while (n > 0) {\n        result *= std::tgamma(n + 1);\n        n--;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    while (n > 0) {\n        result *= std::tgamma(n + 1);\n        n--;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= std::tgamma(i + 1);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    for (long i = n; i > 0; i--) {\n        result *= i;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n    long result = 1;\n    while (n > 0) {\n        result *= std::tgamma(n + 1);\n        n--;\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// >>> special_factorial((4))\n// (288)\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nlong special_factorial(long n) {\n  long result = 1;\n  for (long i = n; i > 0; i--) {\n    result *= i;\n  }\n  return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces == 1) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                consecutive_spaces = 0;\n            }\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces == 1) {\n                result.push_back('_');\n            } else if (consecutive_spaces > 2) {\n                result.push_back('-');\n            }\n            consecutive_spaces = 0;\n            result.push_back(c);\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count > 2) {\n                result += \"-\";\n            } else {\n                result += '_';\n            }\n            while (count-- > 0) {\n                result += \"_\";\n            }\n            result += c;\n        }\n    }\n    if (count > 2) {\n        result += \"-\";\n    } else {\n        while (count-- > 0) {\n            result += \"_\";\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces == 1) {\n                result.push_back('_');\n            }\n        } else {\n            if (consecutive_spaces > 2) {\n                result.push_back('-');\n            }\n            result.push_back(c);\n            consecutive_spaces = 0;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces == 1) {\n                result += '_';\n            }\n        } else {\n            consecutive_spaces = 0;\n            result += c;\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces > 2) {\n                    result += '-';\n                } else {\n                    result += '_';\n                }\n                consecutive_spaces = 0;\n            }\n            result += c;\n        }\n    }\n    if (consecutive_spaces > 0) {\n        if (consecutive_spaces > 2) {\n            result += '-';\n        } else {\n            result += '_';\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int space_count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            space_count++;\n        } else {\n            if (space_count > 2) {\n                result += \"-\";\n            } else {\n                result += '_';\n            }\n            result += c;\n            space_count = 0;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces == 1) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                consecutive_spaces = 0;\n            }\n            result += c;\n        }\n    }\n    if (consecutive_spaces > 0) {\n        if (consecutive_spaces == 1) {\n            result += '_';\n        } else {\n            result += '-';\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces == 1) {\n                result += '_';\n            }\n        } else {\n            if (consecutive_spaces > 2) {\n                result += '-';\n            }\n            result += c;\n            consecutive_spaces = 0;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 2) {\n                result.append(consecutive_spaces - 2, '-');\n            } else {\n                result.append(consecutive_spaces, '_');\n            }\n            consecutive_spaces = 0;\n            result += c;\n        }\n    }\n    if (consecutive_spaces > 2) {\n        result.append(consecutive_spaces - 2, '-');\n    } else {\n        result.append(consecutive_spaces, '_');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count > 2) {\n                result += \"-\";\n            } else {\n                result += '_';\n            }\n            result += c;\n            count = 0;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n            if (consecutive_spaces <= 2) {\n                result.push_back('_');\n            }\n        } else {\n            consecutive_spaces = 0;\n            result.push_back(c);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count > 2) {\n                result.append(\"-\");\n            } else {\n                result.append(count, '_');\n            }\n            count = 0;\n            result.push_back(c);\n        }\n    }\n    if (count > 2) {\n        result.append(\"-\");\n    } else {\n        result.append(count, '_');\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count > 2) {\n                result += '-';\n            } else {\n                result += '_';\n            }\n            result += c;\n            count = 0;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces == 1) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                consecutive_spaces = 0;\n            }\n            result += c;\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces == 1) {\n                    result += '_';\n                } else {\n                    result += '-';\n                }\n                consecutive_spaces = 0;\n            }\n            result += c;\n        }\n    }\n\n    if (consecutive_spaces > 0) {\n        if (consecutive_spaces == 1) {\n            result += '_';\n        } else {\n            result += '-';\n        }\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces == 1) {\n                result.push_back('_');\n            } else if (consecutive_spaces > 2) {\n                result.push_back('-');\n            }\n            consecutive_spaces = 0;\n            result.push_back(c);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int count = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            count++;\n        } else {\n            if (count == 1) {\n                result.push_back('_');\n            } else if (count > 2) {\n                result.push_back('-');\n            }\n            count = 0;\n            result.push_back(c);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces > 2) {\n                    result += '-';\n                } else {\n                    result += '_';\n                }\n                consecutive_spaces = 0;\n            }\n            result += c;\n        }\n    }\n    if (consecutive_spaces > 0) {\n        if (consecutive_spaces > 2) {\n            result += '-';\n        } else {\n            result += '_';\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string text, replace all spaces in it with underscores, \n// and if a string has more than 2 consecutive spaces, \n// then replace all consecutive spaces with - \n// >>> fix_spaces((\" Example\"))\n// (\"Example\")\n// >>> fix_spaces((\" Example 1\"))\n// (\"Example_1\")\n// >>> fix_spaces((\" Example 2\"))\n// (\"_Example_2\")\n// >>> fix_spaces((\" Example 3\"))\n// (\"_Example-3\")\nstd::string fix_spaces(std::string text) {\n    std::string result;\n    int consecutive_spaces = 0;\n    for (char c : text) {\n        if (c == ' ') {\n            consecutive_spaces++;\n        } else {\n            if (consecutive_spaces > 0) {\n                if (consecutive_spaces == 1) {\n                    result.push_back('_');\n                } else {\n                    result.push_back('-');\n                }\n                consecutive_spaces = 0;\n            }\n            result.push_back(c);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    if (dot_pos == 0 || dot_pos == std::string::npos) {\n        return \"No\";\n    }\n\n    std::string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    std::string prefix = file_name.substr(0, dot_pos);\n    if (prefix.empty() || !isalpha(prefix[0])) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    // Initialize counters\n    int digit_count = 0;\n    int dot_count = 0;\n\n    // Check for digits and dots\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    // Check for more than three digits\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // Check for exactly one dot\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    // Check for the correct format\n    std::string::size_type dot_pos = file_name.find('.');\n    std::string before_dot = file_name.substr(0, dot_pos);\n    std::string after_dot = file_name.substr(dot_pos + 1);\n\n    if (before_dot.empty() || !isalpha(before_dot[0]) || (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")) {\n        return \"No\";\n    }\n\n    // If all checks passed, return 'Yes'\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n  int digit_count = 0;\n  int dot_count = 0;\n  int alpha_count = 0;\n  std::string ext;\n  for (char c : file_name) {\n    if (c >= '0' && c <= '9') {\n      digit_count++;\n    }\n    if (c == '.') {\n      dot_count++;\n    }\n    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n      alpha_count++;\n    }\n  }\n  if (dot_count != 1 || digit_count > 3 || alpha_count == 0) {\n    return \"No\";\n  }\n  std::stringstream ss(file_name);\n  std::string token;\n  std::getline(ss, token, '.');\n  ext = token;\n  std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);\n  if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\") {\n    return \"No\";\n  }\n  return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    std::string::size_type pos = file_name.find('.');\n    if (pos == std::string::npos) {\n        return \"No\";\n    }\n\n    std::string::size_type pos_dot = file_name.find('.');\n    std::string::size_type pos_last_dot = file_name.rfind('.');\n\n    if (pos_dot != pos_last_dot) {\n        return \"No\";\n    }\n\n    std::string::size_type pos_last_digit = file_name.find_last_of(\"0123456789\");\n    if (pos_last_digit != std::string::npos && pos_last_digit > pos) {\n        return \"No\";\n    }\n\n    std::string::size_type pos_first_digit = file_name.find_first_of(\"0123456789\");\n    if (pos_first_digit != std::string::npos && pos_first_digit < pos) {\n        std::string::size_type pos_second_digit = file_name.find_first_of(\"0123456789\", pos_first_digit + 1);\n        if (pos_second_digit != std::string::npos && pos_second_digit < pos) {\n            std::string::size_type pos_third_digit = file_name.find_first_of(\"0123456789\", pos_second_digit + 1);\n            if (pos_third_digit != std::string::npos && pos_third_digit < pos) {\n                return \"No\";\n            }\n        }\n    }\n\n    std::string::size_type pos_first_letter = file_name.find_first_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    if (pos_first_letter == std::string::npos || pos_first_letter >= pos) {\n        return \"No\";\n    }\n\n    std::string extension = file_name.substr(pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    assert(dot_pos != std::string::npos);\n\n    std::string before_dot = file_name.substr(0, dot_pos);\n    std::string after_dot = file_name.substr(dot_pos + 1);\n\n    if (before_dot.empty() || !isalpha(before_dot[0]) ||\n        (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    if (dot_pos == 0 || dot_pos == std::string::npos) {\n        return \"No\";\n    }\n\n    std::string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    std::string prefix = file_name.substr(0, dot_pos);\n    if (prefix.empty() || !isalpha(prefix[0])) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    assert(dot_pos != std::string::npos);\n\n    std::string before_dot = file_name.substr(0, dot_pos);\n    std::string after_dot = file_name.substr(dot_pos + 1);\n\n    if (before_dot.empty() || !isalpha(before_dot[0]) ||\n        (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    bool is_letter = false;\n    std::vector<std::string> valid_extensions = {\"txt\", \"exe\", \"dll\"};\n\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        }\n        else if (isdigit(c)) {\n            digit_count++;\n        }\n        else if (isalpha(c)) {\n            is_letter = true;\n        }\n    }\n\n    if (dot_count != 1 || digit_count > 3 || !is_letter) {\n        return \"No\";\n    }\n\n    std::string extension = file_name.substr(file_name.find('.') + 1);\n\n    for (std::string valid_extension : valid_extensions) {\n        if (extension == valid_extension) {\n            return \"Yes\";\n        }\n    }\n\n    return \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    std::regex pattern(\"^[a-zA-Z][^0-9]*\\\\.[^0-9]*(txt|exe|dll)$\");\n    std::smatch match;\n    if (std::regex_match(file_name, match, pattern)) {\n        return \"Yes\";\n    }\n    return \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int dot_count = 0;\n    int digit_count = 0;\n    bool has_letter = false;\n    std::string ext;\n\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        }\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (isalpha(c)) {\n            has_letter = true;\n        }\n        if (c == '.') {\n            ext = \"\";\n        }\n        if (dot_count == 1) {\n            ext += c;\n        }\n    }\n\n    if (dot_count != 1 || digit_count > 3 || !has_letter || (ext != \".txt\" && ext != \".exe\" && ext != \".dll\")) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    std::string::size_type dot_pos = file_name.find('.');\n    if (dot_pos == std::string::npos || dot_pos == 0) {\n        return \"No\";\n    }\n\n    std::string::size_type digits_count = std::count_if(file_name.begin(), file_name.begin() + dot_pos, ::isdigit);\n    if (digits_count > 3) {\n        return \"No\";\n    }\n\n    std::string::size_type ext_pos = file_name.find_first_not_of(\"txtexe\", dot_pos + 1);\n    if (ext_pos != std::string::npos) {\n        return \"No\";\n    }\n\n    std::string::size_type alpha_pos = std::find_if(file_name.begin(), file_name.begin() + dot_pos, ::isalpha) - file_name.begin();\n    if (alpha_pos == std::string::npos || alpha_pos == 0) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    assert(dot_pos != std::string::npos);\n\n    std::string before_dot = file_name.substr(0, dot_pos);\n    std::string after_dot = file_name.substr(dot_pos + 1);\n\n    if (before_dot.empty() || !isalpha(before_dot[0])) {\n        return \"No\";\n    }\n\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    assert(dot_pos != std::string::npos);\n\n    if (dot_pos == 0 || dot_pos == file_name.size() - 1) {\n        return \"No\";\n    }\n\n    std::string prefix = file_name.substr(0, dot_pos);\n    if (!isalpha(prefix[0])) {\n        return \"No\";\n    }\n\n    std::string suffix = file_name.substr(dot_pos + 1);\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    bool dot_found = false;\n    bool letter_found = false;\n    std::string ext;\n\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_found = true;\n        }\n        if (isalpha(c)) {\n            letter_found = true;\n        }\n        if (dot_found && !isdigit(c)) {\n            ext += c;\n        }\n    }\n\n    if (digit_count > 3 || !dot_found || !letter_found ||\n        (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    std::string::size_type pos = file_name.find('.');\n    if (pos == std::string::npos || pos == 0 || pos == file_name.size() - 1)\n        return \"No\";\n\n    std::string::size_type count = 0;\n    for (char c : file_name)\n        if (isdigit(c))\n            count++;\n\n    if (count > 3)\n        return \"No\";\n\n    std::string ext = file_name.substr(pos + 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n\n    char first = file_name[0];\n    if (!isalpha(first))\n        return \"No\";\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    // Check if there are more than three digits in the file's name\n    int digit_count = 0;\n    for (char c : file_name) {\n        if (c >= '0' && c <= '9') {\n            digit_count++;\n        }\n    }\n    if (digit_count > 3) {\n        return \"No\";\n    }\n\n    // Check if there is exactly one dot '.'\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n    if (dot_count != 1) {\n        return \"No\";\n    }\n\n    // Check if the substring before the dot starts with a letter from the latin alphapet\n    int dot_index = file_name.find('.');\n    std::string before_dot = file_name.substr(0, dot_index);\n    if (before_dot.empty()) {\n        return \"No\";\n    }\n    char first_char = before_dot[0];\n    if (!(first_char >= 'a' && first_char <= 'z') && !(first_char >= 'A' && first_char <= 'Z')) {\n        return \"No\";\n    }\n\n    // Check if the substring after the dot is one of these: ['txt', 'exe', 'dll']\n    std::string after_dot = file_name.substr(dot_index + 1);\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    std::string::size_type pos = file_name.find('.');\n    if (pos == std::string::npos)\n        return \"No\";\n\n    std::string before_dot = file_name.substr(0, pos);\n    std::string after_dot = file_name.substr(pos + 1);\n\n    if (before_dot.empty() || after_dot.empty())\n        return \"No\";\n\n    int digit_count = 0;\n    for (char c : before_dot) {\n        if (!isalpha(c)) {\n            if (isdigit(c)) {\n                digit_count++;\n                if (digit_count > 3)\n                    return \"No\";\n            } else {\n                return \"No\";\n            }\n        }\n    }\n\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    assert(dot_pos != std::string::npos);\n\n    std::string before_dot = file_name.substr(0, dot_pos);\n    std::string after_dot = file_name.substr(dot_pos + 1);\n\n    if (before_dot.empty() || !isalpha(before_dot[0]) ||\n        (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")) {\n        return \"No\";\n    }\n\n    return \"Yes\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    std::regex pattern(\"^[a-zA-Z]+\\\\w*\\\\.(?:txt|exe|dll)$\");\n    std::smatch match;\n    if (std::regex_match(file_name, match, pattern)) {\n        int digit_count = std::count_if(file_name.begin(), file_name.end(), ::isdigit);\n        if (digit_count <= 3)\n            return \"Yes\";\n    }\n    return \"No\";", "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function which takes a string representing a file's name, and returns\n// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's name is considered to be valid if and only if all the following conditions \n// are met:\n// - There should not be more than three digits ('0'-'9') in the file's name.\n// - The file's name contains exactly one dot '.'\n// - The substring before the dot should not be empty, and it starts with a letter from \n// the latin alphapet ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check((\"example.txt\"))\n// (\"Yes\")\n// >>> file_name_check((\"1example.dll\"))\n// (\"No\")\nstd::string file_name_check(std::string file_name) {\n    int digit_count = 0;\n    int dot_count = 0;\n    for (char c : file_name) {\n        if (isdigit(c)) {\n            digit_count++;\n        }\n        if (c == '.') {\n            dot_count++;\n        }\n    }\n\n    if (digit_count > 3 || dot_count != 1) {\n        return \"No\";\n    }\n\n    std::string::size_type dot_pos = file_name.find('.');\n    if (dot_pos == 0 || dot_pos == std::string::npos) {\n        return \"No\";\n    }\n\n    std::string extension = file_name.substr(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\") {\n        return \"No\";\n    }\n\n    std::string main_part = file_name.substr(0, dot_pos);\n    if (main_part.empty() || !isalpha(main_part[0])) {\n        return \"No\";\n    }\n\n    return \"Yes\";"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for(int i = 0; i < lst.size(); i++) {\n        if(i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if(i % 4 == 0 && i % 3 != 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for(int i = 0; i < lst.size(); i++) {\n        if(i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if(i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] *= lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] *= lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// \"\n// This function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n// change the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n// Examples:\n// >>> lst\n// (long({(long)1, (long)2, (long)3}))\n// >>> lst\n// (long())\n// >>> lst\n// (long({(long)-1, (long)-5, (long)2, (long)-1, (long)-5}))\nlong sum_squares(std::vector<long> lst) {\n    long sum = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            lst[i] = lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            lst[i] = lst[i] * lst[i] * lst[i];\n        }\n        sum += lst[i];\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  std::string result;\n  for (const auto& word : words) {\n    int len = word.size();\n    bool is_prime = true;\n    if (len <= 1) {\n      is_prime = false;\n    }\n    for (int i = 2; i * i <= len; ++i) {\n      if (len % i == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) {\n      result += word + \" \";\n    }\n  }\n  if (!result.empty()) {\n    result.pop_back();\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::string word;\n    std::istringstream iss(sentence);\n    while (iss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> primes(100, false);\n    primes[2] = true;\n    for (int i = 3; i < 100; i += 2) {\n        bool is_prime = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        primes[i] = is_prime;\n    }\n\n    for (const auto &word : words) {\n        if (primes[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i <= 100; i += 2) {\n        is_prime[i] = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                is_prime[i] = false;\n                break;\n            }\n        }\n    }\n\n    for (const auto &word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  std::string result;\n  for (auto &word : words) {\n    bool is_prime = true;\n    if (word.size() == 1) {\n      is_prime = false;\n    }\n    for (int i = 2; i * i <= word.size(); i++) {\n      if (word.size() % i == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime) {\n      result += word + \" \";\n    }\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i <= 100; i += 2) {\n        is_prime[i] = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                is_prime[i] = false;\n                break;\n            }\n        }\n    }\n\n    for (const auto& word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n  std::string word;\n  std::string result;\n  while (ss >> word) {\n    int len = word.length();\n    bool is_prime = true;\n    if (len == 1)\n      is_prime = false;\n    else {\n      for (int i = 2; i <= sqrt(len); i++) {\n        if (len % i == 0) {\n          is_prime = false;\n          break;\n        }\n      }\n    }\n    if (is_prime)\n      result += word + \" \";\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::vector<std::string> prime_words;\n    for (const auto& word : words) {\n        int len = word.size();\n        if (len == 1) {\n            continue;\n        }\n        bool is_prime = true;\n        for (int i = 2; i * i <= len; ++i) {\n            if (len % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            prime_words.push_back(word);\n        }\n    }\n\n    std::string result;\n    for (const auto& word : prime_words) {\n        result += word + \" \";\n    }\n    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i < 100; i += 2) {\n        is_prime[i] = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                is_prime[i] = false;\n                break;\n            }\n        }\n    }\n\n    for (const auto& word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    for (const auto& word : words) {\n        bool is_prime = true;\n        if (word.size() == 1) {\n            is_prime = false;\n        }\n        for (int i = 2; i <= sqrt(word.size()); ++i) {\n            if (word.size() % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i <= 100; i += 2) {\n        bool prime = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                prime = false;\n                break;\n            }\n        }\n        is_prime[i] = prime;\n    }\n\n    for (const auto &word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  std::string result;\n  std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  for (auto &word : words) {\n    if (std::find(primes.begin(), primes.end(), word.length()) != primes.end()) {\n      result += word + \" \";\n    }\n  }\n  if (!result.empty()) {\n    result.pop_back();\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i < 100; i += 2) {\n        bool prime = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                prime = false;\n                break;\n            }\n        }\n        is_prime[i] = prime;\n    }\n\n    for (const auto& word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n  std::stringstream ss(sentence);\n  std::string word;\n  std::string result;\n  while (ss >> word) {\n    bool is_prime = true;\n    int n = word.size();\n    if (n == 1)\n      continue;\n    for (int i = 2; i * i <= n; i++) {\n      if (n % i == 0) {\n        is_prime = false;\n        break;\n      }\n    }\n    if (is_prime)\n      result += word + \" \";\n  }\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i <= 100; i += 2) {\n        is_prime[i] = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                is_prime[i] = false;\n                break;\n            }\n        }\n    }\n\n    for (const auto& word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::vector<std::string> prime_words;\n    std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    for (auto &word : words) {\n        if (std::find(primes.begin(), primes.end(), word.size()) != primes.end()) {\n            prime_words.push_back(word);\n        }\n    }\n\n    std::string result;\n    for (auto &word : prime_words) {\n        result += word + \" \";\n    }\n    result.pop_back();\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n  std::vector<std::string> words;\n  std::stringstream ss(sentence);\n  std::string word;\n  while (ss >> word) {\n    words.push_back(word);\n  }\n  std::string result;\n  std::vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n  for (auto &word : words) {\n    bool is_prime = false;\n    for (auto prime : primes) {\n      if (word.size() == prime) {\n        is_prime = true;\n        break;\n      }\n    }\n    if (is_prime) {\n      result += word + \" \";\n    }\n  }\n  return result.substr(0, result.size() - 1);", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i <= 100; i += 2) {\n        is_prime[i] = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                is_prime[i] = false;\n                break;\n            }\n        }\n    }\n\n    for (const auto &word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::stringstream ss(sentence);\n    std::string word;\n    std::vector<std::string> words;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::vector<std::string> prime_words;\n    for (const auto& word : words) {\n        bool is_prime = true;\n        int n = word.size();\n        if (n <= 1) {\n            continue;\n        }\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            prime_words.push_back(word);\n        }\n    }\n\n    std::string result;\n    for (const auto& word : prime_words) {\n        result += word + \" \";\n    }\n    if (!result.empty()) {\n        result.pop_back();\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> prime(100, false);\n    prime[2] = true;\n    prime[3] = true;\n    for (int i = 5; i * i <= 100; i += 6) {\n        prime[i] = true;\n        prime[i + 2] = true;\n    }\n\n    for (const auto &word : words) {\n        if (prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string sentence) {\n    std::vector<std::string> words;\n    std::stringstream ss(sentence);\n    std::string word;\n    while (ss >> word) {\n        words.push_back(word);\n    }\n\n    std::string result;\n    std::vector<bool> is_prime(100, false);\n    is_prime[2] = true;\n    for (int i = 3; i <= 100; i += 2) {\n        is_prime[i] = true;\n        for (int j = 3; j * j <= i; j += 2) {\n            if (i % j == 0) {\n                is_prime[i] = false;\n                break;\n            }\n        }\n    }\n\n    for (const auto& word : words) {\n        if (is_prime[word.size()]) {\n            result += word + \" \";\n        }\n    }\n\n    if (!result.empty()) {\n        result.pop_back();\n    }\n\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int num1 = std::stoi(x.substr(0, x.find('/')));\n    int den1 = std::stoi(x.substr(x.find('/') + 1));\n    int num2 = std::stoi(n.substr(0, n.find('/')));\n    int den2 = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = num1 * num2;\n    int denominator = den1 * den2;\n\n    return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    // Split the strings into numerator and denominator\n    std::string x_num = x.substr(0, x.find('/'));\n    std::string x_den = x.substr(x.find('/') + 1);\n\n    std::string n_num = n.substr(0, n.find('/'));\n    std::string n_den = n.substr(n.find('/') + 1);\n\n    // Convert the strings to integers\n    int x_num_int = std::stoi(x_num);\n    int x_den_int = std::stoi(x_den);\n\n    int n_num_int = std::stoi(n_num);\n    int n_den_int = std::stoi(n_den);\n\n    // Calculate the product of numerator and denominator\n    int num = x_num_int * n_num_int;\n    int den = x_den_int * n_den_int;\n\n    // Check if the product of numerator and denominator is a whole number\n    return (num % den == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int numerator_x, denominator_x, numerator_n, denominator_n;\n    std::stringstream ss_x(x), ss_n(n);\n    char c;\n    ss_x >> numerator_x;\n    ss_x >> c;\n    ss_x >> denominator_x;\n    ss_n >> numerator_n;\n    ss_n >> c;\n    ss_n >> denominator_n;\n\n    int lcm = denominator_x * denominator_n / std::__gcd(denominator_x, denominator_n);\n    numerator_x *= denominator_n;\n    numerator_n *= denominator_x;\n\n    int result = numerator_x + numerator_n;\n\n    return result % lcm == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    std::stringstream ss1(x), ss2(n);\n    int a, b, c, d;\n    char ch;\n    ss1 >> a >> ch >> b;\n    ss2 >> c >> ch >> d;\n    assert(ch == '/');\n    int numerator = a * c;\n    int denominator = b * d;\n    return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = x_num * n_num;\n    int denominator = x_den * n_den;\n\n    return numerator % denominator == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  int x_num = std::stoi(x.substr(0, x.find('/')));\n  int x_den = std::stoi(x.substr(x.find('/') + 1));\n  int n_num = std::stoi(n.substr(0, n.find('/')));\n  int n_den = std::stoi(n.substr(n.find('/') + 1));\n\n  int numerator = x_num * n_num;\n  int denominator = x_den * n_den;\n\n  return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    std::string x_numerator = x.substr(0, x.find('/'));\n    std::string x_denominator = x.substr(x.find('/') + 1);\n    std::string n_numerator = n.substr(0, n.find('/'));\n    std::string n_denominator = n.substr(n.find('/') + 1);\n\n    int x_num = std::stoi(x_numerator);\n    int x_den = std::stoi(x_denominator);\n    int n_num = std::stoi(n_numerator);\n    int n_den = std::stoi(n_denominator);\n\n    int lcm = (x_den * n_den) / std::gcd(x_den, n_den);\n    int numerator = x_num * n_num;\n    int denominator = lcm;\n\n    return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int numerator_x, denominator_x, numerator_n, denominator_n;\n    std::stringstream ss_x(x), ss_n(n);\n    ss_x >> numerator_x;\n    ss_x >> denominator_x;\n    ss_n >> numerator_n;\n    ss_n >> denominator_n;\n\n    int numerator = numerator_x * numerator_n;\n    int denominator = denominator_x * denominator_n;\n\n    return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int numerator_x, denominator_x, numerator_n, denominator_n;\n\n    std::stringstream(x.substr(0, x.find('/'))) >> numerator_x;\n    std::stringstream(x.substr(x.find('/') + 1)) >> denominator_x;\n\n    std::stringstream(n.substr(0, n.find('/'))) >> numerator_n;\n    std::stringstream(n.substr(n.find('/') + 1)) >> denominator_n;\n\n    int numerator = numerator_x * numerator_n;\n    int denominator = denominator_x * denominator_n;\n\n    return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = x_num * n_num;\n    int denominator = x_den * n_den;\n\n    return numerator % denominator == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = x_num * n_num;\n    int denominator = x_den * n_den;\n\n    return numerator % denominator == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int numerator_x, denominator_x, numerator_n, denominator_n;\n    std::stringstream ss;\n\n    ss << x;\n    ss >> numerator_x;\n    ss.ignore();\n    ss >> denominator_x;\n\n    ss.clear();\n    ss << n;\n    ss >> numerator_n;\n    ss.ignore();\n    ss >> denominator_n;\n\n    int lcm = denominator_x * denominator_n;\n    numerator_x *= denominator_n;\n    numerator_n *= denominator_x;\n\n    return (numerator_x == numerator_n) && (lcm % (numerator_x) == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n  int numerator_x, denominator_x, numerator_n, denominator_n;\n  std::stringstream ss_x(x), ss_n(n);\n  char c;\n  ss_x >> numerator_x;\n  ss_x >> c;\n  ss_x >> denominator_x;\n  ss_n >> numerator_n;\n  ss_n >> c;\n  ss_n >> denominator_n;\n  int numerator = numerator_x * numerator_n;\n  int denominator = denominator_x * denominator_n;\n  return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = x_num * n_num;\n    int denominator = x_den * n_den;\n\n    return (numerator % denominator == 0);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    // Split the strings into numerator and denominator\n    std::string x_numerator = x.substr(0, x.find('/'));\n    std::string x_denominator = x.substr(x.find('/') + 1);\n\n    std::string n_numerator = n.substr(0, n.find('/'));\n    std::string n_denominator = n.substr(n.find('/') + 1);\n\n    // Convert the strings to integers\n    int x_numerator_int = std::stoi(x_numerator);\n    int x_denominator_int = std::stoi(x_denominator);\n\n    int n_numerator_int = std::stoi(n_numerator);\n    int n_denominator_int = std::stoi(n_denominator);\n\n    // Calculate the result of the multiplication\n    int result_numerator = x_numerator_int * n_numerator_int;\n    int result_denominator = x_denominator_int * n_denominator_int;\n\n    // Check if the result is a whole number\n    return result_numerator % result_denominator == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = x_num * n_num;\n    int denominator = x_den * n_den;\n\n    return numerator % denominator == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    // Convert strings to integers\n    int x_numerator = std::stoi(x.substr(0, x.find('/')));\n    int x_denominator = std::stoi(x.substr(x.find('/') + 1));\n    int n_numerator = std::stoi(n.substr(0, n.find('/')));\n    int n_denominator = std::stoi(n.substr(n.find('/') + 1));\n\n    // Simplify the expression\n    int numerator = x_numerator * n_numerator;\n    int denominator = x_denominator * n_denominator;\n\n    // Check if the expression evaluates to a whole number\n    return numerator % denominator == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    std::string::size_type pos = x.find('/');\n    int numerator = std::stoi(x.substr(0, pos));\n    int denominator = std::stoi(x.substr(pos + 1));\n\n    pos = n.find('/');\n    int numerator2 = std::stoi(n.substr(0, pos));\n    int denominator2 = std::stoi(n.substr(pos + 1));\n\n    int lcm = denominator * denominator2 / std::gcd(denominator, denominator2);\n    int new_numerator = numerator * numerator2 * lcm / (denominator * denominator2);\n\n    return new_numerator % 1 == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_num = std::stoi(x.substr(0, x.find('/')));\n    int x_den = std::stoi(x.substr(x.find('/') + 1));\n    int n_num = std::stoi(n.substr(0, n.find('/')));\n    int n_den = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = x_num * n_num;\n    int denominator = x_den * n_den;\n\n    return numerator % denominator == 0;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns true if x * n evaluates to a whole number and false\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\n// >>> simplify((\"1/5\"), (\"5/1\"))\n// (true)\n// >>> simplify((\"1/6\"), (\"2/1\"))\n// (false)\n// >>> simplify((\"7/10\"), (\"10/2\"))\n// (false)\nbool simplify(std::string x, std::string n) {\n    int x_numerator = std::stoi(x.substr(0, x.find('/')));\n    int x_denominator = std::stoi(x.substr(x.find('/') + 1));\n\n    int n_numerator = std::stoi(n.substr(0, n.find('/')));\n    int n_denominator = std::stoi(n.substr(n.find('/') + 1));\n\n    int numerator = x_numerator * n_numerator;\n    int denominator = x_denominator * n_denominator;\n\n    return (numerator % denominator == 0);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long points = 0;\n        long num = nums[i];\n        while (num != 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> sorted_nums;\n    for (long i = 0; i < nums_with_points.size(); i++) {\n        sorted_nums.push_back(nums[nums_with_points[i].second]);\n    }\n    return sorted_nums;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); ++i) {\n        long points = 0;\n        long num = nums[i];\n        while (num) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back({points, i});\n    }\n\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); ++i) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long sum = 0;\n        long num = nums[i];\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(sum, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); i++) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); ++i) {\n        long points = 0;\n        long num = nums[i];\n        while (num != 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> sorted_nums;\n    for (long i = 0; i < nums_with_points.size(); ++i) {\n        sorted_nums.push_back(nums[nums_with_points[i].second]);\n    }\n    return sorted_nums;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long points = 0;\n        long num = nums[i];\n        while (num != 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); i++) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); ++i) {\n        long points = 0;\n        long num = nums[i];\n        while (num != 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n\n    std::sort(nums_with_points.begin(), nums_with_points.end(),\n              [](const std::pair<long, long>& a, const std::pair<long, long>& b) {\n                  if (a.first == b.first) {\n                      return a.second < b.second;\n                  }\n                  return a.first < b.first;\n              });\n\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); ++i) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); ++i) {\n        long points = 0;\n        long num = nums[i];\n        while (num) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); ++i) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long points = 0;\n        long num = nums[i];\n        while (num != 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); i++) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); ++i) {\n        long points = 0;\n        long num = nums[i];\n        while (num != 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); ++i) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n  std::vector<std::pair<long, long>> nums_with_points;\n  for (long i = 0; i < nums.size(); i++) {\n    long points = 0;\n    long num = nums[i];\n    while (num != 0) {\n      points += num % 10;\n      num /= 10;\n    }\n    nums_with_points.push_back(std::make_pair(points, i));\n  }\n  std::sort(nums_with_points.begin(), nums_with_points.end());\n  std::vector<long> sorted_nums;\n  for (long i = 0; i < nums_with_points.size(); i++) {\n    sorted_nums.push_back(nums[nums_with_points[i].second]);\n  }\n  return sorted_nums;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_sum;\n    for (long i = 0; i < nums.size(); i++) {\n        long sum = 0;\n        long num = nums[i];\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        nums_with_sum.push_back(std::make_pair(sum, i));\n    }\n    std::sort(nums_with_sum.begin(), nums_with_sum.end());\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_sum.size(); i++) {\n        result.push_back(nums[nums_with_sum[i].second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long points = 0;\n        long num = nums[i];\n        while (num > 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n\n    std::vector<long> sorted_nums;\n    for (long i = 0; i < nums_with_points.size(); i++) {\n        sorted_nums.push_back(nums[nums_with_points[i].second]);\n    }\n\n    return sorted_nums;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long sum = 0;\n        long num = nums[i];\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(sum, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); i++) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long points = 0;\n        long num = nums[i];\n        while (num) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n\n    std::vector<long> result;\n    for (auto pair : nums_with_points) {\n        result.push_back(nums[pair.second]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_sum;\n    for (long i = 0; i < nums.size(); ++i) {\n        long sum = 0;\n        long num = nums[i];\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        nums_with_sum.push_back(std::make_pair(sum, i));\n    }\n\n    std::sort(nums_with_sum.begin(), nums_with_sum.end());\n\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_sum.size(); ++i) {\n        result.push_back(nums[nums_with_sum[i].second]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); ++i) {\n        long points = 0;\n        long num = nums[i];\n        while (num) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n    std::vector<long> result;\n    for (auto pair : nums_with_points) {\n        result.push_back(nums[pair.second]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_sum;\n    for (long i = 0; i < nums.size(); ++i) {\n        long sum = 0;\n        long num = nums[i];\n        while (num) {\n            sum += num % 10;\n            num /= 10;\n        }\n        nums_with_sum.push_back(std::make_pair(sum, i));\n    }\n\n    std::sort(nums_with_sum.begin(), nums_with_sum.end());\n\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_sum.size(); ++i) {\n        result.push_back(nums[nums_with_sum[i].second]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); ++i) {\n        long points = 0;\n        long num = nums[i];\n        while (num) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); ++i) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_points;\n    for (long i = 0; i < nums.size(); i++) {\n        long points = 0;\n        long num = nums[i];\n        while (num != 0) {\n            points += num % 10;\n            num /= 10;\n        }\n        nums_with_points.push_back(std::make_pair(points, i));\n    }\n\n    std::sort(nums_with_points.begin(), nums_with_points.end());\n\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_points.size(); i++) {\n        result.push_back(nums[nums_with_points[i].second]);\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function which sorts the given vector of integers\n// in ascending order according to the sum of their digits.\n// Note: if there are several items with similar sum of their digits,\n// order them based on their index in original vector.\n// For example:\n// >>> order_by_points((std::vector<long>({(long)1, (long)11, (long)-1, (long)-11, (long)-12})))\n// (std::vector<long>({(long)-1, (long)-11, (long)1, (long)-12, (long)11}))\n// >>> order_by_points((std::vector<long>()))\n// (std::vector<long>())\nstd::vector<long> order_by_points(std::vector<long> nums) {\n    std::vector<std::pair<long, long>> nums_with_sum;\n    for (long i = 0; i < nums.size(); i++) {\n        long sum = 0;\n        long num = nums[i];\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        nums_with_sum.push_back(std::make_pair(sum, i));\n    }\n    std::sort(nums_with_sum.begin(), nums_with_sum.end());\n    std::vector<long> result;\n    for (long i = 0; i < nums_with_sum.size(); i++) {\n        result.push_back(nums[nums_with_sum[i].second]);\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10 && (num % 10) % 2 == 1 && (num / 10) % 10 == 1) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10 && (num % 10) % 2 == 1 && (num / 10) % 10 == 1) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10 &&\n            ((num / 10) % 10) % 2 == 1 &&\n            (num % 10) % 2 == 1) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10 && (num % 10) % 2 == 1 && (num / 10) % 10 == 1) {\n            count++;\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that takes a vector of numbers as input and returns \n// the number of elements in the vector that are greater than 10 and both \n// first and last digits of a number are odd (1, 3, 5, 7, 9).\n// For example:\n// >>> specialFilter((std::vector<long>({(long)15, (long)-73, (long)14, (long)-15})))\n// (1)\n// >>> specialFilter((std::vector<long>({(long)33, (long)-2, (long)-3, (long)45, (long)21, (long)109})))\n// (2)\nlong specialFilter(std::vector<long> nums) {\n    long count = 0;\n    for (long num : nums) {\n        if (num > 10) {\n            long first_digit = num / 10;\n            long last_digit = num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long ans = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ans++;\n                }\n            }\n        }\n    }\n\n    return ans;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long count = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long result = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    result++;\n                }\n            }\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long mod = 3;\n    long count = 0;\n    vector<long> a(n);\n    for(long i = 1; i <= n; i++) {\n        a[i-1] = i*i - i + 1;\n    }\n    for(long i = 0; i < n; i++) {\n        for(long j = i+1; j < n; j++) {\n            for(long k = j+1; k < n; k++) {\n                if((a[i] + a[j] + a[k]) % mod == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long count = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    for (long i = 0; i < n - 2; i++) {\n        for (long j = i + 1; j < n - 1; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long count = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long a[n];\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n - 2; i++) {\n        for (long j = i + 1; j < n - 1; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long count = 0;\n    vector<long> a(n);\n    for(long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    for(long i = 0; i < n; i++) {\n        for(long j = i + 1; j < n; j++) {\n            for(long k = j + 1; k < n; k++) {\n                if((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long count = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long mod = 3;\n    vector<long> a(n);\n    for(long i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    long count = 0;\n    for(long i = 0; i < n - 2; i++) {\n        for(long j = i + 1; j < n - 1; j++) {\n            for(long k = j + 1; k < n; k++) {\n                if((a[i] + a[j] + a[k]) % mod == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long count = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    std::vector<long> a(n);\n    for (long i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    long count = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = i + 1; j < n; ++j) {\n            for (long k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a positive integer n. You have to create an integer vector a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n// and a[i] + a[j] + a[k] is a multiple of 3.\n// Example :\n// >>> get_max_triples((5))\n// (1)\n// Explanation: \n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nlong get_max_triples(long n) {\n    long ans = 0;\n    vector<long> a(n);\n    for (long i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    for (long i = 0; i < n; i++) {\n        for (long j = i + 1; j < n; j++) {\n            for (long k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ans++;\n                }\n            }\n        }\n    }\n    return ans;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    }\n    else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    } else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    } else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for(int i = 0; i < planets.size(); i++) {\n        if(planets[i] == planet1)\n            p1 = i;\n        if(planets[i] == planet2)\n            p2 = i;\n    }\n    if(p1 == -1 || p2 == -1)\n        return result;\n    if(p1 > p2)\n        std::swap(p1, p2);\n    for(int i = p1 + 1; i < p2; i++)\n        result.push_back(planets[i]);\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    }\n    else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    }\n    else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2)\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    else\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2)\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    else\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for(int i = 0; i < planets.size(); i++) {\n        if(planets[i] == planet1)\n            p1 = i;\n        if(planets[i] == planet2)\n            p2 = i;\n    }\n    if(p1 == -1 || p2 == -1)\n        return result;\n    if(p1 > p2)\n        std::swap(p1, p2);\n    for(int i = p1 + 1; i < p2; i++)\n        result.push_back(planets[i]);\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2)\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    else\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    }\n    else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    } else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2)\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    else\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    }\n    else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2)\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    else\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for (int i = 0; i < planets.size(); i++) {\n        if (planets[i] == planet1) {\n            p1 = i;\n        }\n        if (planets[i] == planet2) {\n            p2 = i;\n        }\n    }\n    if (p1 == -1 || p2 == -1) {\n        return result;\n    }\n    if (p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for (int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    } else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end()) {\n        return result;\n    }\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    }\n    else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n    }\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n    int p1 = -1, p2 = -1;\n    for(int i = 0; i < planets.size(); i++) {\n        if(planets[i] == planet1) {\n            p1 = i;\n        }\n        if(planets[i] == planet2) {\n            p2 = i;\n        }\n    }\n    if(p1 == -1 || p2 == -1) {\n        return result;\n    }\n    if(p1 > p2) {\n        std::swap(p1, p2);\n    }\n    for(int i = p1 + 1; i < p2; i++) {\n        result.push_back(planets[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a tuple containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf((\"Jupiter\"), (\"Neptune\"))\n// (std::vector<std::string>({(std::string)\"Saturn\", (std::string)\"Uranus\"}))\n// >>> bf((\"Earth\"), (\"Mercury\"))\n// (std::vector<std::string>(\"Venus\"))\n// >>> bf((\"Mercury\"), (\"Uranus\"))\n// (std::vector<std::string>({(std::string)\"Venus\", (std::string)\"Earth\", (std::string)\"Mars\", (std::string)\"Jupiter\", (std::string)\"Saturn\"}))\nstd::vector<std::string> bf(std::string planet1, std::string planet2) {\n    std::vector<std::string> planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    std::vector<std::string> result;\n\n    auto it1 = std::find(planets.begin(), planets.end(), planet1);\n    auto it2 = std::find(planets.begin(), planets.end(), planet2);\n\n    if (it1 == planets.end() || it2 == planets.end())\n        return result;\n\n    if (it1 < it2) {\n        std::copy(it1 + 1, it2, std::back_inserter(result));\n    }\n    else {\n        std::copy(it2 + 1, it1, std::back_inserter(result));\n        result.push_back(planet2);\n    }\n\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        return a.length() < b.length() || (a.length() == b.length() && a < b);\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.size() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.size() != b.size()) {\n            return a.size() < b.size();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (std::string str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string& a, const std::string& b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() != b.length()) {\n      return a.length() < b.length();\n    }\n    return a < b;\n  });\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() != b.length()) {\n      return a.length() < b.length();\n    }\n    return a < b;\n  });\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() == b.length()) {\n            return a < b;\n        }\n        return a.length() < b.length();\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n    std::vector<std::string> result;\n    for (auto &str : lst) {\n        if (str.length() % 2 == 0) {\n            result.push_back(str);\n        }\n    }\n    std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n        if (a.length() != b.length()) {\n            return a.length() < b.length();\n        }\n        return a < b;\n    });\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.size() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  std::sort(result.begin(), result.end(),\n            [](const std::string &a, const std::string &b) {\n              if (a.size() == b.size()) {\n                return a < b;\n              }\n              return a.size() < b.size();\n            });\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted vector with a sorted order,\n// The vector is always a vector of strings and never a vector of numbers,\n// and it may contain duplicates.\n// The order of the vector should be ascending by length of each word, and you\n// should return the vector sorted by that rule.\n// If two words have the same length, sort the vector alphabetically.\n// The function should return a vector of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// >>> list_sort((std::vector<std::string>({(std::string)\"aa\", (std::string)\"a\", (std::string)\"aaa\"})))\n// (std::vector<std::string>({(std::string)\"aa\"}))\n// >>> list_sort((std::vector<std::string>({(std::string)\"ab\", (std::string)\"a\", (std::string)\"aaa\", (std::string)\"cd\"})))\n// (std::vector<std::string>({(std::string)\"ab\", (std::string)\"cd\"}))\nstd::vector<std::string> sorted_list_sum(std::vector<std::string> lst) {\n  std::vector<std::string> result;\n  for (auto &str : lst) {\n    if (str.length() % 2 == 0) {\n      result.push_back(str);\n    }\n  }\n  std::sort(result.begin(), result.end(), [](const std::string &a, const std::string &b) {\n    if (a.length() == b.length()) {\n      return a < b;\n    }\n    return a.length() < b.length();\n  });\n  return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n == 2 || n == 3)\n        return x;\n    if(n % 2 == 0 || n % 3 == 0)\n        return y;\n    for(long i = 5; i * i <= n; i += 6)\n        if(n % i == 0 || n % (i + 2) == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n == 1 || n == 0)\n        return y;\n\n    for (long i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n            return y;\n\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n == 2 || n == 3)\n        return x;\n    if(n%2 == 0 || n%3 == 0)\n        return y;\n    for(long i = 5; i*i <= n; i += 6)\n        if(n%i == 0 || n%(i+2) == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    // Your code goes here\n    if(n==2)\n        return x;\n    if(n%2==0)\n        return y;\n    for(long i=3;i*i<=n;i+=2)\n    {\n        if(n%i==0)\n            return y;\n    }\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n > 1) {\n        for (long i = 2; i <= sqrt(n); i++) {\n            if (n % i == 0) {\n                return y;\n            }\n        }\n        return x;\n    }\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    // Your code here\n    if(n==1)\n        return y;\n    for(long i=2;i<=sqrt(n);i++)\n    {\n        if(n%i==0)\n            return y;\n    }\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n == 2 || n == 3)\n        return x;\n    if(n%2 == 0 || n%3 == 0)\n        return y;\n    for(long i = 5; i*i <= n; i += 6)\n        if(n%i == 0 || n%(i+2) == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n > 1) {\n        for (long i = 2; i < n; i++) {\n            if (n % i == 0) {\n                return y;\n            }\n        }\n    }\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n <= 1)\n        return y;\n    for (long i = 2; i * i <= n; i++)\n        if (n % i == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n <= 1)\n        return y;\n    for (long i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n==2 || n==3){\n        return x;\n    }\n    if(n%2==0 || n%3==0){\n        return y;\n    }\n    for(long i=5; i*i<=n; i+=6){\n        if(n%i==0 || n%(i+2)==0){\n            return y;\n        }\n    }\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n == 2 || n == 3)\n        return x;\n    if(n % 2 == 0 || n % 3 == 0)\n        return y;\n    for(long i = 5; i * i <= n; i += 6)\n        if(n % i == 0 || n % (i + 2) == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n <= 1)\n        return y;\n    for(long i = 2; i*i <= n; i++)\n        if(n%i == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n <= 1)\n        return y;\n    for (long i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n <= 1)\n        return y;\n    for (long i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n <= 1)\n        return y;\n    for(long i = 2; i <= sqrt(n); i++)\n        if(n % i == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if (n > 1) {\n        for (long i = 2; i <= sqrt(n); i++) {\n            if (n % i == 0) {\n                return y;\n            }\n        }\n        return x;\n    }\n    return y;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n==2 || n==3){\n        return x;\n    }\n    if(n%2==0 || n%3==0){\n        return y;\n    }\n    for(long i=5;i*i<=n;i+=6){\n        if(n%i==0 || n%(i+2)==0){\n            return y;\n        }\n    }\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n <= 1)\n        return y;\n    for(long i = 2; i * i <= n; i++)\n        if(n % i == 0)\n            return y;\n    return x;", "#include<assert.h>\n#include<bits/stdc++.h>\n// A simple program which should return the value of x if n is \n// a prime number and should return the value of y otherwise.\n// Examples:\n// >>> x_or_y((7), (34), (12))\n// (34)\n// >>> x_or_y((15), (8), (5))\n// (5)\nlong x_or_y(long n, long x, long y) {\n    if(n == 1)\n        return y;\n    for(long i = 2; i <= sqrt(n); i++)\n        if(n % i == 0)\n            return y;\n    return x;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    if (num >= 0 && num == (long)num && num % 2 == 1) {\n      sum += num * num;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto i : lst) {\n    if (i >= 0 && i == (long)i && i % 2 == 1) {\n      sum += i * i;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    if (num >= 0 && (long)num == num) {\n      if (num % 2 == 1) {\n        sum += num * num;\n      }\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && num == (long)num && num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && (long)num == num && num % 2 != 0) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && (long)num == num && num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == (long)num && num % 2 == 1) {\n            sum += (long)num * (long)num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && std::round(num) == num && num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto x : lst) {\n        if (x >= 0 && x == (long)x) {\n            if (x % 2 == 1) {\n                sum += x * x;\n            }\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto i : lst) {\n        if (i >= 0 && i == (long)i && i % 2 == 1) {\n            sum += i * i;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && (long)num == num && (long)num % 2 == 1) {\n            sum += (long)num * (long)num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto x : lst) {\n    if (x >= 0 && std::round(x) == x && x % 2 != 0) {\n      sum += x * x;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n  long sum = 0;\n  for (auto num : lst) {\n    if (num >= 0 && num == (long)num && num % 2 == 1) {\n      sum += num * num;\n    }\n  }\n  return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && num == (long)num && num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto x : lst) {\n        if (x >= 0 && x == (long)x) {\n            if (x % 2 == 1) {\n                sum += x * x;\n            }\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && num == (long)num && num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && std::fmod(num, 1) == 0 && num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto i : lst) {\n        if (i >= 0 && i == (long)i && i % 2 != 0) {\n            sum += i * i;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (auto num : lst) {\n        if (num >= 0 && std::round(num) == num && num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    return sum;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of numbers, return the sum of squares of the numbers\n// in the vector that are odd. Ignore numbers that are negative or not integers.\n// >>> double_the_difference((std::vector<float>({(long)1, (long)3, (long)2, (long)0})))\n// (10)\n// >>> double_the_difference((std::vector<float>({(long)-1, (long)-2, (long)0})))\n// (0)\n// >>> double_the_difference((std::vector<float>({(long)9, (long)-2})))\n// (81)\n// >>> double_the_difference((std::vector<float>({(long)0})))\n// (0)\n// If the input vector is empty, return 0.\nlong double_the_difference(std::vector<float> lst) {\n    long sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == (long)num && num % 2 == 1) {\n            sum += (long)num * (long)num;\n        }\n    }\n    return sum;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result;\n    for (int i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result;\n    for (int i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result;\n    for (int i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (size_t i = 0; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result;\n    for (int i = 0; i < game.size(); i++) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two vectors of scores and guesses of equal length, where each index shows a match. \n// Return a vector of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\n// example:\n// >>> compare((std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)5, (long)1})), (std::vector<long>({(long)1, (long)2, (long)3, (long)4, (long)2, (long)-2})))\n// (std::vector<long>({(long)0, (long)0, (long)0, (long)0, (long)3, (long)3}))\n// >>> compare((std::vector<long>({(long)0, (long)5, (long)0, (long)0, (long)0, (long)4})), (std::vector<long>({(long)4, (long)1, (long)1, (long)0, (long)0, (long)-2})))\n// (std::vector<long>({(long)4, (long)4, (long)1, (long)0, (long)0, (long)6}))\nstd::vector<long> compare(std::vector<long> game, std::vector<long> guess) {\n    assert(game.size() == guess.size());\n    std::vector<long> result(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = -1000000;\n    std::string strongest_extension;\n    for (std::string extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  std::string strongest_extension = \"\";\n  double strongest_strength = 0;\n  for (auto extension : extensions) {\n    double strength = 0;\n    for (char c : extension) {\n      if (isupper(c)) {\n        strength += 1;\n      } else if (islower(c)) {\n        strength -= 1;\n      }\n    }\n    if (strength > strongest_strength) {\n      strongest_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = 0;\n  std::string strongest_extension;\n  for (std::string extension : extensions) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n      if (isupper(c))\n        cap++;\n      else if (islower(c))\n        sm++;\n    }\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = -1000;\n    std::string strongest_extension;\n    for (auto extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string strongest_extension;\n\n    for (auto extension : extensions) {\n        int strength = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                strength++;\n            } else if (islower(c)) {\n                strength--;\n            }\n        }\n\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = -1000;\n    std::string strongest_extension;\n    for (std::string extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = 0;\n  std::string strongest_extension;\n  for (auto &extension : extensions) {\n    int cap = 0, sm = 0;\n    for (auto &c : extension) {\n      if (isupper(c))\n        cap++;\n      else if (islower(c))\n        sm++;\n    }\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string strongest_extension;\n    for (std::string extension : extensions) {\n        int strength = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                strength++;\n            } else if (islower(c)) {\n                strength--;\n            }\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n\n    for (auto &extension : extensions) {\n        int cap = 0, sm = 0;\n        for (auto &ch : extension) {\n            if (isupper(ch))\n                cap++;\n            else if (islower(ch))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n  int max_strength = -1000;\n  std::string strongest_extension;\n  for (std::string extension : extensions) {\n    int cap = 0, sm = 0;\n    for (char c : extension) {\n      if (isupper(c))\n        cap++;\n      else if (islower(c))\n        sm++;\n    }\n    int strength = cap - sm;\n    if (strength > max_strength) {\n      max_strength = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n\n    for (std::string extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n\n    for (auto extension : extensions) {\n        int cap = 0, sm = 0;\n        for (auto ch : extension) {\n            if (isupper(ch))\n                cap++;\n            else if (islower(ch))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string strongest_extension;\n\n    for (auto extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n\n    for (auto extension : extensions) {\n        int cap = 0, sm = 0;\n        for (auto c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    std::string strongest_extension = \"\";\n    int max_strength = -1000000000;\n    for (auto extension : extensions) {\n        int cap = 0, sm = 0;\n        for (auto c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n    for (const auto& extension : extensions) {\n        int cap = 0, sm = 0;\n        for (const auto& ch : extension) {\n            if (isupper(ch))\n                cap++;\n            else if (islower(ch))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    std::string strongest_extension = \"\";\n    int max_strength = 0;\n\n    for (std::string extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    std::string strongest_extension = \"\";\n    int max_strength = 0;\n\n    for (std::string extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    std::string strongest_extension = \"\";\n    int max_strength = 0;\n\n    for (std::string extension : extensions) {\n        int cap = 0, sm = 0;\n        for (char c : extension) {\n            if (isupper(c)) {\n                cap++;\n            } else if (islower(c)) {\n                sm++;\n            }\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name of a class (a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters \n// in the extension's name, the strength is given by the fraction CAP - SM. \n// You should find the strongest extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the vector.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name, std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n    std::string strongest_extension;\n\n    for (auto extension : extensions) {\n        int cap = 0, sm = 0;\n        for (auto c : extension) {\n            if (isupper(c))\n                cap++;\n            else if (islower(c))\n                sm++;\n        }\n        int strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest_extension = extension;\n        }\n    }\n\n    return class_name + \".\" + strongest_extension;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if b is longer than a, return false\n    if (m > n)\n        return false;\n\n    // if b is empty, return true\n    if (m == 0)\n        return true;\n\n    // if a is empty, return false\n    if (n == 0)\n        return false;\n\n    // if b is a substring of a, return true\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // rotate b\n    std::rotate(b.begin(), b.begin() + 1, b.end());\n\n    // if b is a substring of a, return true\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // rotate b\n    std::rotate(b.begin(), b.begin() + 1, b.end());\n\n    // if b is a substring of a, return true\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // rotate b\n    std::rotate(b.begin(), b.begin() + 1, b.end());\n\n    // if b is a substring of a, return true\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // if none of the rotations of b is a substring of a, return false\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // Check if b is a substring of a\n    if (n >= m && a.find(b) != std::string::npos) {\n        return true;\n    }\n\n    // Check if any rotation of b is a substring of a\n    for (int i = 0; i < m; i++) {\n        std::rotate(b.begin(), b.begin() + i, b.end());\n        if (n >= m && a.find(b) != std::string::npos) {\n            return true;\n        }\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // Check if b is a substring of a\n    if (n >= m && a.find(b) != std::string::npos)\n        return true;\n\n    // Check if any rotation of b is a substring of a\n    for (int i = 0; i < m; i++) {\n        std::rotate(b.begin(), b.begin() + i, b.end());\n        if (n >= m && a.find(b) != std::string::npos)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // Check if b is a substring of a\n    if (n >= m && a.find(b) != std::string::npos)\n        return true;\n\n    // Check if any rotation of b is a substring of a\n    for (int i = 0; i < m; i++) {\n        std::rotate(b.begin(), b.begin() + i, b.end());\n        if (n >= m && a.find(b) != std::string::npos)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if b is longer than a, return false\n    if(m > n)\n        return false;\n\n    // if b is empty, return true\n    if(m == 0)\n        return true;\n\n    // if a is empty, return false\n    if(n == 0)\n        return false;\n\n    // check if b is a substring of a\n    if(a.find(b) != std::string::npos)\n        return true;\n\n    // rotate b\n    std::rotate(b.begin(), b.begin() + 1, b.end());\n\n    // check if rotated b is a substring of a\n    while(b != a.substr(0, m)) {\n        if(a.find(b) != std::string::npos)\n            return true;\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    if (m > n)\n        return false;\n\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[(i + j) % n] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // If pattern length is greater than string length, no rotation of pattern\n    // can be a substring of string\n    if (m > n)\n        return false;\n\n    // Traverse through all rotations of pattern\n    for (int i = 0; i < m; i++) {\n\n        // Check if current rotation is a substring of string\n        if (a.find(b) != std::string::npos)\n            return true;\n\n        // Rotate pattern by 1\n        char t = b[0];\n        for (int j = 0; j < m - 1; j++)\n            b[j] = b[j + 1];\n        b[m - 1] = t;\n    }\n\n    // If no rotation of pattern is substring of string, return false\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if b is longer than a, return false\n    if (m > n)\n        return false;\n\n    // if b is empty, return true\n    if (m == 0)\n        return true;\n\n    // check if b is a substring of a\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // check if any rotation of b is a substring of a\n    for (int i = 0; i < m; i++) {\n        std::rotate(b.begin(), b.begin() + 1, b.end());\n        if (a.find(b) != std::string::npos)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n    if (m > n)\n        return false;\n\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[(i + j) % n] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    if (m > n)\n        return false;\n\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[(i + j) % n] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    if (m > n)\n        return false;\n\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[(i + j) % n] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if b is longer than a, return false\n    if (m > n)\n        return false;\n\n    // if b is empty, return true\n    if (m == 0)\n        return true;\n\n    // if a is empty, return false\n    if (n == 0)\n        return false;\n\n    // check if b is a substring of a\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // rotate b\n    std::rotate(b.begin(), b.begin() + 1, b.end());\n\n    // check if rotated b is a substring of a\n    return cycpattern_check(a, b);", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n    if (n < m)\n        return false;\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[i + j] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if length of b is greater than a\n    // return false\n    if (m > n)\n        return false;\n\n    // concatenate string a with itself\n    a += a;\n\n    // Now check for the pattern\n    for (int i = 0; i <= n - m; i++) {\n        int j;\n\n        // Check for pattern match\n        for (j = 0; j < m; j++)\n            if (a[i + j] != b[j])\n                break;\n\n        // if pattern is found\n        if (j == m)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if length of b is greater than a\n    // return false\n    if (m > n)\n        return false;\n\n    // concatenate string a with itself\n    a += a;\n\n    // check if b or any of its rotation is a substring\n    // of a\n    for (int i = 0; i < m; i++) {\n        int j;\n        for (j = 0; j < n; j++)\n            if (a[j] != b[i])\n                break;\n\n        // if all characters match\n        if (j == n)\n            return true;\n    }\n\n    // if no rotation of b is a substring of a\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    if (n < m)\n        return false;\n\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[i + j] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    if (m > n)\n        return false;\n\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[(i + j) % n] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if b is longer than a, it cannot be a substring of a\n    if (m > n)\n        return false;\n\n    // if b is empty, it is a substring of a\n    if (m == 0)\n        return true;\n\n    // check if b is a substring of a\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // rotate b and check if it is a substring of a\n    for (int i = 1; i < m; i++) {\n        char tmp = b[0];\n        b = b.substr(1) + tmp;\n        if (a.find(b) != std::string::npos)\n            return true;\n    }\n\n    // if none of the rotations of b is a substring of a, return false\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n\n    // if b is longer than a, return false\n    if (m > n)\n        return false;\n\n    // if b is empty, return true\n    if (m == 0)\n        return true;\n\n    // check if b is a substring of a\n    if (a.find(b) != std::string::npos)\n        return true;\n\n    // rotate b and check if it is a substring of a\n    for (int i = 0; i < m - 1; i++) {\n        char temp = b[0];\n        b = b.substr(1);\n        b += temp;\n        if (a.find(b) != std::string::npos)\n            return true;\n    }\n\n    return false;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n// >>> cycpattern_check((\"abcd\"), (\"abd\"))\n// (false)\n// >>> cycpattern_check((\"hello\"), (\"ell\"))\n// (true)\n// >>> cycpattern_check((\"whassup\"), (\"psus\"))\n// (false)\n// >>> cycpattern_check((\"abab\"), (\"baa\"))\n// (true)\n// >>> cycpattern_check((\"efef\"), (\"eeff\"))\n// (false)\n// >>> cycpattern_check((\"himenss\"), (\"simen\"))\n// (true)\nbool cycpattern_check(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n    if (m > n)\n        return false;\n    for (int i = 0; i < m; i++) {\n        bool flag = true;\n        for (int j = 0; j < m; j++) {\n            if (a[(i + j) % n] != b[j]) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag)\n            return true;\n    }\n    return false;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0, odd = 0;\n    num = abs(num);\n    while(num) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num > 0) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even = 0;\n  long odd = 0;\n  num = abs(num);\n  while(num > 0) {\n    if(num % 2 == 0)\n      even++;\n    else\n      odd++;\n    num /= 10;\n  }\n  return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    num = abs(num);\n    while(num != 0){\n        if(num % 2 == 0){\n            even_count++;\n        }\n        else{\n            odd_count++;\n        }\n        num /= 10;\n    }\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even = 0, odd = 0;\n  num = abs(num);\n  while (num > 0) {\n    if ((num % 10) % 2 == 0)\n      even++;\n    else\n      odd++;\n    num /= 10;\n  }\n  return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0, odd = 0;\n    num = abs(num);\n    while(num) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even = 0;\n  long odd = 0;\n  num = abs(num);\n  while (num > 0) {\n    if (num % 2 == 0)\n      even++;\n    else\n      odd++;\n    num /= 10;\n  }\n  return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num > 0){\n        if(num % 2 == 0){\n            even++;\n        }\n        else{\n            odd++;\n        }\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0, odd = 0;\n    num = abs(num);\n    while(num) {\n        if((num % 10) % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num > 0) {\n        if((num % 10) % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num > 0) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num > 0) {\n        if((num % 10) % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0, odd = 0;\n    num = abs(num);\n    while(num) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n\n    num = abs(num);\n\n    while(num > 0) {\n        if(num % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    }\n\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even_count = 0;\n    long odd_count = 0;\n    num = abs(num);\n    while(num > 0){\n        if((num % 10) % 2 == 0){\n            even_count++;\n        }\n        else{\n            odd_count++;\n        }\n        num /= 10;\n    }\n    return std::make_tuple(even_count, odd_count);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num > 0) {\n        if((num % 10) % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n  long even = 0, odd = 0;\n  num = abs(num);\n  while (num) {\n    if (num % 2 == 0)\n      even++;\n    else\n      odd++;\n    num /= 10;\n  }\n  return std::make_tuple(even, odd);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given an integer. return a tuple that has the number of even and odd digits respectively.\n// Example:\n// >>> even_odd_count((-12))\n// (std::make_tuple(1, 1))\n// >>> even_odd_count((123))\n// (std::make_tuple(1, 2))\nstd::tuple<long, long> even_odd_count(long num) {\n    long even = 0;\n    long odd = 0;\n    num = abs(num);\n    while(num > 0) {\n        if(num % 2 == 0)\n            even++;\n        else\n            odd++;\n        num /= 10;\n    }\n    return std::make_tuple(even, odd);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<long, std::string>> roman_map = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    for (auto &pair : roman_map) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            roman += pair.second;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number >= 1 && number <= 1000);\n\n    std::string roman = \"\";\n\n    while (number >= 1000) {\n        roman += \"m\";\n        number -= 1000;\n    }\n\n    if (number >= 900) {\n        roman += \"cm\";\n        number -= 900;\n    }\n\n    while (number >= 500) {\n        roman += \"d\";\n        number -= 500;\n    }\n\n    if (number >= 400) {\n        roman += \"cd\";\n        number -= 400;\n    }\n\n    while (number >= 100) {\n        roman += \"c\";\n        number -= 100;\n    }\n\n    if (number >= 90) {\n        roman += \"xc\";\n        number -= 90;\n    }\n\n    while (number >= 50) {\n        roman += \"l\";\n        number -= 50;\n    }\n\n    if (number >= 40) {\n        roman += \"xl\";\n        number -= 40;\n    }\n\n    while (number >= 10) {\n        roman += \"x\";\n        number -= 10;\n    }\n\n    if (number >= 9) {\n        roman += \"ix\";\n        number -= 9;\n    }\n\n    while (number >= 5) {\n        roman += \"v\";\n        number -= 5;\n    }\n\n    if (number >= 4) {\n        roman += \"iv\";\n        number -= 4;\n    }\n\n    while (number > 0) {\n        roman += \"i\";\n        number -= 1;\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    };\n\n    for (auto &pair : roman_map) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            roman += pair.second;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number >= 1 && number <= 1000);\n\n    std::string roman = \"\";\n\n    while (number >= 1000) {\n        number -= 1000;\n        roman += \"m\";\n    }\n\n    if (number >= 900) {\n        number -= 900;\n        roman += \"cm\";\n    }\n\n    while (number >= 500) {\n        number -= 500;\n        roman += \"d\";\n    }\n\n    if (number >= 400) {\n        number -= 400;\n        roman += \"cd\";\n    }\n\n    while (number >= 100) {\n        number -= 100;\n        roman += \"c\";\n    }\n\n    if (number >= 90) {\n        number -= 90;\n        roman += \"xc\";\n    }\n\n    while (number >= 50) {\n        number -= 50;\n        roman += \"l\";\n    }\n\n    if (number >= 40) {\n        number -= 40;\n        roman += \"xl\";\n    }\n\n    while (number >= 10) {\n        number -= 10;\n        roman += \"x\";\n    }\n\n    if (number >= 9) {\n        number -= 9;\n        roman += \"ix\";\n    }\n\n    while (number >= 5) {\n        number -= 5;\n        roman += \"v\";\n    }\n\n    if (number >= 4) {\n        number -= 4;\n        roman += \"iv\";\n    }\n\n    while (number >= 1) {\n        number -= 1;\n        roman += \"i\";\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  assert(number >= 1 && number <= 1000);\n  std::string roman = \"\";\n  while (number >= 1000) {\n    roman += \"m\";\n    number -= 1000;\n  }\n  while (number >= 900) {\n    roman += \"cm\";\n    number -= 900;\n  }\n  while (number >= 500) {\n    roman += \"d\";\n    number -= 500;\n  }\n  while (number >= 400) {\n    roman += \"cd\";\n    number -= 400;\n  }\n  while (number >= 100) {\n    roman += \"c\";\n    number -= 100;\n  }\n  while (number >= 90) {\n    roman += \"xc\";\n    number -= 90;\n  }\n  while (number >= 50) {\n    roman += \"l\";\n    number -= 50;\n  }\n  while (number >= 40) {\n    roman += \"xl\";\n    number -= 40;\n  }\n  while (number >= 10) {\n    roman += \"x\";\n    number -= 10;\n  }\n  while (number >= 9) {\n    roman += \"ix\";\n    number -= 9;\n  }\n  while (number >= 5) {\n    roman += \"v\";\n    number -= 5;\n  }\n  while (number >= 4) {\n    roman += \"iv\";\n    number -= 4;\n  }\n  while (number >= 1) {\n    roman += \"i\";\n    number -= 1;\n  }\n  return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman;\n    std::vector<std::pair<int, char>> roman_map = {{1000, 'm'}, {900, 'c'}, {500, 'd'}, {400, 'c'},\n                                                  {100, 'c'}, {90, 'x'}, {50, 'l'}, {40, 'x'},\n                                                  {10, 'x'}, {9, 'i'}, {5, 'v'}, {4, 'i'},\n                                                  {1, 'i'}};\n\n    for (auto &pair : roman_map) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            roman += pair.second;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  assert(number >= 1 && number <= 1000);\n  std::string roman;\n  while (number >= 1000) {\n    roman += \"m\";\n    number -= 1000;\n  }\n  while (number >= 900) {\n    roman += \"cm\";\n    number -= 900;\n  }\n  while (number >= 500) {\n    roman += \"d\";\n    number -= 500;\n  }\n  while (number >= 400) {\n    roman += \"cd\";\n    number -= 400;\n  }\n  while (number >= 100) {\n    roman += \"c\";\n    number -= 100;\n  }\n  while (number >= 90) {\n    roman += \"xc\";\n    number -= 90;\n  }\n  while (number >= 50) {\n    roman += \"l\";\n    number -= 50;\n  }\n  while (number >= 40) {\n    roman += \"xl\";\n    number -= 40;\n  }\n  while (number >= 10) {\n    roman += \"x\";\n    number -= 10;\n  }\n  while (number >= 9) {\n    roman += \"ix\";\n    number -= 9;\n  }\n  while (number >= 5) {\n    roman += \"v\";\n    number -= 5;\n  }\n  while (number >= 4) {\n    roman += \"iv\";\n    number -= 4;\n  }\n  while (number >= 1) {\n    roman += \"i\";\n    number -= 1;\n  }\n  return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number >= 1 && number <= 1000);\n\n    std::string roman = \"\";\n\n    while (number >= 1000) {\n        number -= 1000;\n        roman += \"m\";\n    }\n\n    if (number >= 900) {\n        number -= 900;\n        roman += \"cm\";\n    }\n\n    while (number >= 500) {\n        number -= 500;\n        roman += \"d\";\n    }\n\n    if (number >= 400) {\n        number -= 400;\n        roman += \"cd\";\n    }\n\n    while (number >= 100) {\n        number -= 100;\n        roman += \"c\";\n    }\n\n    if (number >= 90) {\n        number -= 90;\n        roman += \"xc\";\n    }\n\n    while (number >= 50) {\n        number -= 50;\n        roman += \"l\";\n    }\n\n    if (number >= 40) {\n        number -= 40;\n        roman += \"xl\";\n    }\n\n    while (number >= 10) {\n        number -= 10;\n        roman += \"x\";\n    }\n\n    if (number >= 9) {\n        number -= 9;\n        roman += \"ix\";\n    }\n\n    while (number >= 5) {\n        number -= 5;\n        roman += \"v\";\n    }\n\n    if (number >= 4) {\n        number -= 4;\n        roman += \"iv\";\n    }\n\n    while (number > 0) {\n        number -= 1;\n        roman += \"i\";\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    for (auto& pair : roman_map) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            roman += pair.second;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman;\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    for (auto &pair : roman_map) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            roman += pair.second;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number >= 1 && number <= 1000);\n\n    std::string roman = \"\";\n\n    while (number >= 1000) {\n        number -= 1000;\n        roman += \"m\";\n    }\n\n    if (number >= 900) {\n        number -= 900;\n        roman += \"cm\";\n    }\n\n    while (number >= 500) {\n        number -= 500;\n        roman += \"d\";\n    }\n\n    if (number >= 400) {\n        number -= 400;\n        roman += \"cd\";\n    }\n\n    while (number >= 100) {\n        number -= 100;\n        roman += \"c\";\n    }\n\n    if (number >= 90) {\n        number -= 90;\n        roman += \"xc\";\n    }\n\n    while (number >= 50) {\n        number -= 50;\n        roman += \"l\";\n    }\n\n    if (number >= 40) {\n        number -= 40;\n        roman += \"xl\";\n    }\n\n    while (number >= 10) {\n        number -= 10;\n        roman += \"x\";\n    }\n\n    if (number >= 9) {\n        number -= 9;\n        roman += \"ix\";\n    }\n\n    while (number >= 5) {\n        number -= 5;\n        roman += \"v\";\n    }\n\n    if (number >= 4) {\n        number -= 4;\n        roman += \"iv\";\n    }\n\n    while (number >= 1) {\n        number -= 1;\n        roman += \"i\";\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number >= 1 && number <= 1000);\n\n    std::string roman = \"\";\n\n    while (number >= 1000) {\n        roman += \"m\";\n        number -= 1000;\n    }\n\n    if (number >= 900) {\n        roman += \"cm\";\n        number -= 900;\n    }\n\n    while (number >= 500) {\n        roman += \"d\";\n        number -= 500;\n    }\n\n    if (number >= 400) {\n        roman += \"cd\";\n        number -= 400;\n    }\n\n    while (number >= 100) {\n        roman += \"c\";\n        number -= 100;\n    }\n\n    if (number >= 90) {\n        roman += \"xc\";\n        number -= 90;\n    }\n\n    while (number >= 50) {\n        roman += \"l\";\n        number -= 50;\n    }\n\n    if (number >= 40) {\n        roman += \"xl\";\n        number -= 40;\n    }\n\n    while (number >= 10) {\n        roman += \"x\";\n        number -= 10;\n    }\n\n    if (number >= 9) {\n        roman += \"ix\";\n        number -= 9;\n    }\n\n    while (number >= 5) {\n        roman += \"v\";\n        number -= 5;\n    }\n\n    if (number >= 4) {\n        roman += \"iv\";\n        number -= 4;\n    }\n\n    while (number > 0) {\n        roman += \"i\";\n        number -= 1;\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    for (auto const &[value, symbol] : roman_map) {\n        while (number >= value) {\n            number -= value;\n            roman += symbol;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman;\n\n    // Roman numerals\n    const std::string roman_numbers[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\n    // Traverse the roman numerals in reverse order\n    for (int i = 0; i < 13; i++) {\n        // While the current roman numeral value is less than or equal to the number\n        while (number >= values[i]) {\n            // Subtract the value of the current roman numeral from the number\n            number -= values[i];\n            // Append the current roman numeral to the result\n            roman += roman_numbers[i];\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  assert(number >= 1 && number <= 1000);\n  std::string roman;\n  while (number >= 1000) {\n    roman += \"m\";\n    number -= 1000;\n  }\n  if (number >= 900) {\n    roman += \"cm\";\n    number -= 900;\n  }\n  while (number >= 500) {\n    roman += \"d\";\n    number -= 500;\n  }\n  if (number >= 400) {\n    roman += \"cd\";\n    number -= 400;\n  }\n  while (number >= 100) {\n    roman += \"c\";\n    number -= 100;\n  }\n  if (number >= 90) {\n    roman += \"xc\";\n    number -= 90;\n  }\n  while (number >= 50) {\n    roman += \"l\";\n    number -= 50;\n  }\n  if (number >= 40) {\n    roman += \"xl\";\n    number -= 40;\n  }\n  while (number >= 10) {\n    roman += \"x\";\n    number -= 10;\n  }\n  if (number >= 9) {\n    roman += \"ix\";\n    number -= 9;\n  }\n  while (number >= 5) {\n    roman += \"v\";\n    number -= 5;\n  }\n  if (number >= 4) {\n    roman += \"iv\";\n    number -= 4;\n  }\n  while (number > 0) {\n    roman += \"i\";\n    number -= 1;\n  }\n  return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number >= 1 && number <= 1000);\n\n    std::string roman = \"\";\n\n    while (number >= 1000) {\n        number -= 1000;\n        roman += \"m\";\n    }\n\n    if (number >= 900) {\n        number -= 900;\n        roman += \"cm\";\n    }\n\n    while (number >= 500) {\n        number -= 500;\n        roman += \"d\";\n    }\n\n    if (number >= 400) {\n        number -= 400;\n        roman += \"cd\";\n    }\n\n    while (number >= 100) {\n        number -= 100;\n        roman += \"c\";\n    }\n\n    if (number >= 90) {\n        number -= 90;\n        roman += \"xc\";\n    }\n\n    while (number >= 50) {\n        number -= 50;\n        roman += \"l\";\n    }\n\n    if (number >= 40) {\n        number -= 40;\n        roman += \"xl\";\n    }\n\n    while (number >= 10) {\n        number -= 10;\n        roman += \"x\";\n    }\n\n    if (number >= 9) {\n        number -= 9;\n        roman += \"ix\";\n    }\n\n    while (number >= 5) {\n        number -= 5;\n        roman += \"v\";\n    }\n\n    if (number >= 4) {\n        number -= 4;\n        roman += \"iv\";\n    }\n\n    while (number >= 1) {\n        number -= 1;\n        roman += \"i\";\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    assert(number >= 1 && number <= 1000);\n\n    std::string roman = \"\";\n\n    while (number >= 1000) {\n        roman += \"m\";\n        number -= 1000;\n    }\n\n    if (number >= 900) {\n        roman += \"cm\";\n        number -= 900;\n    }\n\n    while (number >= 500) {\n        roman += \"d\";\n        number -= 500;\n    }\n\n    if (number >= 400) {\n        roman += \"cd\";\n        number -= 400;\n    }\n\n    while (number >= 100) {\n        roman += \"c\";\n        number -= 100;\n    }\n\n    if (number >= 90) {\n        roman += \"xc\";\n        number -= 90;\n    }\n\n    while (number >= 50) {\n        roman += \"l\";\n        number -= 50;\n    }\n\n    if (number >= 40) {\n        roman += \"xl\";\n        number -= 40;\n    }\n\n    while (number >= 10) {\n        roman += \"x\";\n        number -= 10;\n    }\n\n    if (number >= 9) {\n        roman += \"ix\";\n        number -= 9;\n    }\n\n    while (number >= 5) {\n        roman += \"v\";\n        number -= 5;\n    }\n\n    if (number >= 4) {\n        roman += \"iv\";\n        number -= 4;\n    }\n\n    while (number > 0) {\n        roman += \"i\";\n        number -= 1;\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    for (auto &pair : roman_map) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            roman += pair.second;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n    std::string roman = \"\";\n    std::vector<std::pair<int, std::string>> roman_map = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    };\n\n    for (auto &pair : roman_map) {\n        while (number >= pair.first) {\n            number -= pair.first;\n            roman += pair.second;\n        }\n    }\n\n    return roman;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman((19))\n// (\"xix\")\n// >>> int_to_mini_roman((152))\n// (\"clii\")\n// >>> int_to_mini_roman((426))\n// (\"cdxxvi\")\nstd::string int_to_mini_roman(long number) {\n  std::string roman;\n  std::vector<std::pair<int, std::string>> roman_map = {\n      {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n      {100, \"c\"},  {90, \"xc\"},  {50, \"l\"},  {40, \"xl\"},\n      {10, \"x\"},   {9, \"ix\"},   {5, \"v\"},   {4, \"iv\"},\n      {1, \"i\"},\n  };\n  for (auto &pair : roman_map) {\n    while (number >= pair.first) {\n      number -= pair.first;\n      roman += pair.second;\n    }\n  }\n  return roman;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Your code here\n    long sides[3] = {a, b, c};\n    sort(sides, sides+3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Your code here\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides+3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides+3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    sort(sides, sides+3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides+3);\n    return sides[2]*sides[2] == sides[0]*sides[0] + sides[1]*sides[1];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    sort(sides, sides+3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    sort(sides, sides+3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return sides[2] * sides[2] == sides[0] * sides[0] + sides[1] * sides[1];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    sort(sides, sides + 3);\n    return (sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    std::sort(sides, sides + 3);\n    return sides[2] * sides[2] == sides[0] * sides[0] + sides[1] * sides[1];", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given the lengths of the three sides of a triangle. Return true if the three\n// sides form a right-angled triangle, false otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or \n// 90 degree.\n// Example:\n// >>> right_angle_triangle((3), (4), (5))\n// (true)\n// >>> right_angle_triangle((1), (2), (3))\n// (false)\nbool right_angle_triangle(long a, long b, long c) {\n    // Write your code here\n    long sides[3] = {a, b, c};\n    sort(sides, sides+3);\n    return (sides[0]*sides[0] + sides[1]*sides[1] == sides[2]*sides[2]);"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word;\n  int max_unique_chars = 0;\n  for (const auto& word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (std::string word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        int unique_chars_count = unique_chars.size();\n\n        if (unique_chars_count > max_unique_chars) {\n            max_unique_chars = unique_chars_count;\n            max_word = word;\n        } else if (unique_chars_count == max_unique_chars) {\n            if (word < max_word) {\n                max_word = word;\n            }\n        }\n    }\n\n    return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (std::string word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        int unique_chars_count = unique_chars.size();\n\n        if (unique_chars_count > max_unique_chars) {\n            max_unique_chars = unique_chars_count;\n            max_word = word;\n        } else if (unique_chars_count == max_unique_chars) {\n            max_word = std::min(max_word, word);\n        }\n    }\n\n    return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (std::string word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        int unique_chars_count = unique_chars.size();\n\n        if (unique_chars_count > max_unique_chars) {\n            max_unique_chars = unique_chars_count;\n            max_word = word;\n        } else if (unique_chars_count == max_unique_chars) {\n            max_word = std::min(max_word, word, std::less<std::string>());\n        }\n    }\n\n    return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    int unique_chars_count = unique_chars.size();\n    if (unique_chars_count > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars_count;\n    } else if (unique_chars_count == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word;\n  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word;\n  int max_unique_chars = 0;\n  for (auto word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    } else if (unique_chars.size() == max_unique_chars) {\n      if (word < max_word) {\n        max_word = word;\n      }\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word;\n  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word = \"\";\n    int max_unique_chars = 0;\n    for (std::string word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        int unique_chars_count = unique_chars.size();\n        if (unique_chars_count > max_unique_chars) {\n            max_word = word;\n            max_unique_chars = unique_chars_count;\n        } else if (unique_chars_count == max_unique_chars) {\n            if (word < max_word) {\n                max_word = word;\n            }\n        }\n    }\n    return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word = \"\";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        int unique_chars_count = unique_chars.size();\n\n        if (unique_chars_count > max_unique_chars) {\n            max_word = word;\n            max_unique_chars = unique_chars_count;\n        } else if (unique_chars_count == max_unique_chars) {\n            if (word < max_word) {\n                max_word = word;\n            }\n        }\n    }\n\n    return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    int unique_chars_count = unique_chars.size();\n    if (unique_chars_count > max_unique_chars) {\n      max_unique_chars = unique_chars_count;\n      max_word = word;\n    } else if (unique_chars_count == max_unique_chars) {\n      if (word < max_word) {\n        max_word = word;\n      }\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n    std::string max_word;\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        std::set<char> unique_chars(word.begin(), word.end());\n        if (unique_chars.size() > max_unique_chars) {\n            max_unique_chars = unique_chars.size();\n            max_word = word;\n        } else if (unique_chars.size() == max_unique_chars) {\n            max_word = std::min(max_word, word, std::less<std::string>());\n        }\n    }\n\n    return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word;\n  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    } else if (unique_chars.size() == max_unique_chars) {\n      if (word < max_word) {\n        max_word = word;\n      }\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (const auto& word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (std::string word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (const std::string& word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars) {\n      if (word < max_word) {\n        max_word = word;\n      }\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (auto word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars) {\n      if (word < max_word) {\n        max_word = word;\n      }\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word = \"\";\n  int max_unique_chars = 0;\n  for (const std::string& word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_word = word;\n      max_unique_chars = unique_chars.size();\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word, std::less<std::string>());\n    }\n  }\n  return max_word;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts a vector of strings.\n// The vector contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"of\", (std::string)\"string\"})))\n// (\"string\")\n// >>> find_max((std::vector<std::string>({(std::string)\"name\", (std::string)\"enam\", (std::string)\"game\"})))\n// (\"enam\")\n// >>> find_max((std::vector<std::string>({(std::string)\"aaaaaaa\", (std::string)\"bb\", (std::string)\"cc\"})))\n// (\"aaaaaaa\")\nstd::string find_max(std::vector<std::string> words) {\n  std::string max_word;\n  int max_unique_chars = 0;\n  for (const std::string& word : words) {\n    std::set<char> unique_chars(word.begin(), word.end());\n    if (unique_chars.size() > max_unique_chars) {\n      max_unique_chars = unique_chars.size();\n      max_word = word;\n    } else if (unique_chars.size() == max_unique_chars) {\n      max_word = std::min(max_word, word);\n    }\n  }\n  return max_word;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = std::min(need, remaining);\n    long left = remaining - eaten;\n    return {number + eaten, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    long left = 0;\n    if (total <= remaining) {\n        left = remaining - total;\n    }\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = std::min(need, remaining);\n    long left = remaining - eaten;\n    return {number + eaten, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    return {total, remaining - total};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = std::min(need, remaining);\n    long left = remaining - eaten;\n    return {number + eaten, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = std::min(need, remaining);\n    return {number + eaten, remaining - eaten};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = std::min(need, remaining);\n    return {number + eaten, remaining - eaten};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    return {total, remaining - total};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    return {total, remaining - total};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    long left = remaining - need;\n    if (left < 0) {\n        total += left;\n        left = 0;\n    }\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = std::min(need, remaining);\n    return {number + eaten, remaining - eaten};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long total = number + need;\n    if (total > remaining) {\n        total = remaining;\n    }\n    long left = remaining - (total - number);\n    return {total, left};", "#include<assert.h>\n#include<bits/stdc++.h>\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a vector of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat((5), (6), (10))\n// (std::vector<long>({(long)11, (long)4}))\n// >>> eat((4), (8), (9))\n// (std::vector<long>({(long)12, (long)1}))\n// >>> eat((1), (10), (10))\n// (std::vector<long>({(long)11, (long)0}))\n// >>> eat((2), (11), (5))\n// (std::vector<long>({(long)7, (long)0}))\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nstd::vector<long> eat(long number, long need, long remaining) {\n    long eaten = std::min(need, remaining);\n    return {number + eaten, remaining - eaten};"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); ++i) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = std::pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); i++) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); i++) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::stack<long> st;\n    for (int i = 0; i < op.size(); i++) {\n        long b = operand[i];\n        long a = st.top();\n        st.pop();\n        if (op[i] == \"+\") {\n            st.push(a + b);\n        } else if (op[i] == \"-\") {\n            st.push(a - b);\n        } else if (op[i] == \"*\") {\n            st.push(a * b);\n        } else if (op[i] == \"//\") {\n            st.push(a / b);\n        } else if (op[i] == \"**\") {\n            st.push(std::pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); i++) {\n        if (op[i] == \"+\") {\n            result += operand[i+1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i+1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i+1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i+1];\n        } else if (op[i] == \"**\") {\n            result = std::pow(result, operand[i+1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    std::stack<long> st;\n    st.push(operand[0]);\n    for(int i = 0; i < op.size(); i++) {\n        long b = operand[i+1];\n        long a = st.top();\n        st.pop();\n        if(op[i] == \"+\") {\n            st.push(a + b);\n        } else if(op[i] == \"-\") {\n            st.push(a - b);\n        } else if(op[i] == \"*\") {\n            st.push(a * b);\n        } else if(op[i] == \"//\") {\n            st.push(a / b);\n        } else if(op[i] == \"**\") {\n            st.push(std::pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    std::stack<long> st;\n    st.push(operand[0]);\n    for (int i = 0; i < op.size(); i++) {\n        long a = st.top();\n        st.pop();\n        long b = operand[i + 1];\n        if (op[i] == \"+\") {\n            st.push(a + b);\n        } else if (op[i] == \"-\") {\n            st.push(a - b);\n        } else if (op[i] == \"*\") {\n            st.push(a * b);\n        } else if (op[i] == \"//\") {\n            st.push(a / b);\n        } else if (op[i] == \"**\") {\n            st.push(std::pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); ++i) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = std::pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); ++i) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = std::pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    std::stack<long> st;\n    for (int i = 0; i < operand.size(); ++i) {\n        st.push(operand[i]);\n        if (i < operand.size() - 1) {\n            long b = st.top(); st.pop();\n            long a = st.top(); st.pop();\n            if (op[i] == \"+\") st.push(a + b);\n            else if (op[i] == \"-\") st.push(a - b);\n            else if (op[i] == \"*\") st.push(a * b);\n            else if (op[i] == \"//\") st.push(a / b);\n            else if (op[i] == \"**\") st.push(std::pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); i++) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    std::stack<long> st;\n    st.push(operand[0]);\n    for (int i = 0; i < op.size(); i++) {\n        long a = st.top();\n        st.pop();\n        long b = operand[i + 1];\n        if (op[i] == \"+\") {\n            st.push(a + b);\n        } else if (op[i] == \"-\") {\n            st.push(a - b);\n        } else if (op[i] == \"*\") {\n            st.push(a * b);\n        } else if (op[i] == \"//\") {\n            st.push(a / b);\n        } else if (op[i] == \"**\") {\n            st.push(std::pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (size_t i = 0; i < op.size(); ++i) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = std::pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::stack<long> st;\n    for(int i = 0; i < op.size(); i++) {\n        if(op[i] == \"+\") {\n            st.push(st.top() + operand[i+1]);\n        } else if(op[i] == \"-\") {\n            st.push(st.top() - operand[i+1]);\n        } else if(op[i] == \"*\") {\n            st.push(st.top() * operand[i+1]);\n        } else if(op[i] == \"//\") {\n            st.push(st.top() / operand[i+1]);\n        } else if(op[i] == \"**\") {\n            st.push(st.top() ^ operand[i+1]);\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::stack<long> st;\n    for(int i = 0; i < op.size(); i++) {\n        long a = st.top();\n        st.pop();\n        long b = operand[i + 1];\n        if(op[i] == \"+\") {\n            st.push(a + b);\n        }\n        else if(op[i] == \"-\") {\n            st.push(a - b);\n        }\n        else if(op[i] == \"*\") {\n            st.push(a * b);\n        }\n        else if(op[i] == \"//\") {\n            st.push(a / b);\n        }\n        else if(op[i] == \"**\") {\n            st.push(pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    std::stack<long> s;\n    for (int i = 0; i < op.size(); ++i) {\n        long b = operand[i + 1];\n        long a = s.top();\n        s.pop();\n        if (op[i] == \"+\") {\n            s.push(a + b);\n        }\n        else if (op[i] == \"-\") {\n            s.push(a - b);\n        }\n        else if (op[i] == \"*\") {\n            s.push(a * b);\n        }\n        else if (op[i] == \"//\") {\n            s.push(a / b);\n        }\n        else if (op[i] == \"**\") {\n            s.push(std::pow(a, b));\n        }\n    }\n    return s.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); i++) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    std::stack<long> st;\n    for (int i = 0; i < operand.size(); i++) {\n        st.push(operand[i]);\n        if (i < operand.size() - 1) {\n            long b = st.top(); st.pop();\n            long a = st.top(); st.pop();\n            if (op[i] == \"+\") st.push(a + b);\n            else if (op[i] == \"-\") st.push(a - b);\n            else if (op[i] == \"*\") st.push(a * b);\n            else if (op[i] == \"//\") st.push(a / b);\n            else if (op[i] == \"**\") st.push(pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    std::stack<long> st;\n    st.push(operand[0]);\n    for (int i = 0; i < op.size(); i++) {\n        long a = st.top();\n        st.pop();\n        long b = operand[i + 1];\n        if (op[i] == \"+\") {\n            st.push(a + b);\n        } else if (op[i] == \"-\") {\n            st.push(a - b);\n        } else if (op[i] == \"*\") {\n            st.push(a * b);\n        } else if (op[i] == \"//\") {\n            st.push(a / b);\n        } else if (op[i] == \"**\") {\n            st.push(std::pow(a, b));\n        }\n    }\n    return st.top();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two vectors operator, and operand. The first vector has basic algebra operations, and \n// the second vector is a vector of integers. Use the two given vectors to build the algebric \n// expression and return the evaluation of this expression.\n// The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n// operator['+', '*', '-']\n// vector = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n// => result = 9\n// Note:\n// The length of operator vector is equal to the length of operand vector minus one.\n// Operand is a vector of of non-negative integers.\n// Operator vector has at least one operator, and operand vector has at least two operands.\nlong do_algebra(std::vector<std::string> op, std::vector<long> operand) {\n    assert(op.size() == operand.size() - 1);\n    long result = operand[0];\n    for (int i = 0; i < op.size(); i++) {\n        if (op[i] == \"+\") {\n            result += operand[i + 1];\n        } else if (op[i] == \"-\") {\n            result -= operand[i + 1];\n        } else if (op[i] == \"*\") {\n            result *= operand[i + 1];\n        } else if (op[i] == \"//\") {\n            result /= operand[i + 1];\n        } else if (op[i] == \"**\") {\n            result = pow(result, operand[i + 1]);\n        }\n    }\n    return result;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n    if (!has_letter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (has_letter) {\n        for (char& c : s) {\n            if (std::isalpha(c)) {\n                c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            }\n        }\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n    if (!has_letter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n    if (!has_letter) {\n        reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char c : s)\n        if (std::isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n\n    if (has_letter) {\n        for (char& c : s)\n            if (std::isalpha(c))\n                c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n    } else {\n        std::reverse(s.begin(), s.end());\n    }\n\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;", "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// >>> solve((\"1234\"))\n// (\"4321\")\n// >>> solve((\"ab\"))\n// (\"AB\")\n// >>> solve((\"#a@C\"))\n// (\"#A@c\")\nstd::string solve(std::string s) {\n    bool has_letter = false;\n    for (char& c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    if (!has_letter) {\n        std::reverse(s.begin(), s.end());\n    }\n    return s;"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);\n\n    char mdString[33];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++)\n        sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\n    return mdString;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);\n\n    char mdString[33];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++)\n        sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);\n\n    char mdString[33];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++)\n        sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty())\n        return std::nullopt;\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i)\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty())\n        return std::nullopt;\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    char mdString[33];\n    for (int i = 0; i < 16; i++)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);\n\n    char mdString[33];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++)\n        sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty()) {\n        return std::nullopt;\n    }\n\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);\n\n    char mdString[33];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++)\n        sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty()) {\n    return std::nullopt;\n  }\n  unsigned char digest[16];\n  MD5_CTX context;\n  MD5_Init(&context);\n  MD5_Update(&context, text.c_str(), text.size());\n  MD5_Final(digest, &context);\n  char mdString[33];\n  for (int i = 0; i < 16; i++) {\n    sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n  }\n  return std::string(mdString);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty())\n        return {};\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    std::stringstream ss;\n    for (int i = 0; i < 16; ++i)\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n\n    return ss.str();", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n  if (text.empty())\n    return std::nullopt;\n  unsigned char digest[MD5_DIGEST_LENGTH];\n  MD5((unsigned char*)text.c_str(), text.length(), (unsigned char*)&digest);\n  char mdString[33];\n  for (int i = 0; i < MD5_DIGEST_LENGTH; i++)\n    sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n  return std::string(mdString);", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string 'text', return its md5 hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>> string_to_md5((\"Hello world\"))\n// \"3e25960a79dbc69b674cd4ec67a72c62\"\nstd::optional<std::string> string_to_md5(std::string text) {\n    if (text.empty())\n        return std::nullopt;\n\n    unsigned char digest[16];\n    MD5_CTX context;\n    MD5_Init(&context);\n    MD5_Update(&context, text.c_str(), text.size());\n    MD5_Final(digest, &context);\n\n    char mdString[33];\n    for (int i = 0; i < 16; i++)\n        sprintf(&mdString[i * 2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::make_optional(std::string(mdString));"], ["#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; ++i) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(&c, 1)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; ++i) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(c - '0');\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(&c, 1)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; ++i) {\n        std::string str_i = std::to_string(i);\n        for (char c : str_i) {\n            if (c % 2 == 0) {\n                result.push_back(std::stol(std::string(1, c)));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; ++i) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n\n    for (long i = start; i <= end; ++i) {\n        std::string str = std::to_string(i);\n        for (char c : str) {\n            if (c % 2 == 0) {\n                result.push_back(std::stol(std::string(1, c)));\n            }\n        }\n    }\n\n    std::sort(result.begin(), result.end());\n    result.erase(std::unique(result.begin(), result.end()), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(&c, 1)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  result.erase(std::unique(result.begin(), result.end()), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; ++i) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c - '0' % 2 == 0) {\n        result.push_back(i);\n        break;\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n    for (long i = start; i <= end; i++) {\n        std::string str = std::to_string(i);\n        for (char c : str) {\n            if (c % 2 == 0) {\n                result.push_back(std::stol(std::string(1, c)));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n\n    for (long i = start; i <= end; i++) {\n        std::string str = std::to_string(i);\n        for (char c : str) {\n            if (c % 2 == 0) {\n                result.push_back(c - '0');\n            }\n        }\n    }\n\n    std::sort(result.begin(), result.end());\n    result.erase(std::unique(result.begin(), result.end()), result.end());\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n    std::vector<long> result;\n    long start = std::min(a, b);\n    long end = std::max(a, b);\n\n    for (long i = start; i <= end; i++) {\n        std::string str = std::to_string(i);\n        for (char c : str) {\n            if (c % 2 == 0) {\n                result.push_back(std::stol(std::string(1, c)));\n            }\n        }\n    }\n\n    std::sort(result.begin(), result.end());\n    result.erase(std::unique(result.begin(), result.end()), result.end());\n\n    return result;", "#include<assert.h>\n#include<bits/stdc++.h>\n// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\n// For example:\n// >>> generate_integers((2), (8))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((8), (2))\n// (std::vector<long>({(long)2, (long)4, (long)6, (long)8}))\n// >>> generate_integers((10), (14))\n// (std::vector<long>())\nstd::vector<long> generate_integers(long a, long b) {\n  std::vector<long> result;\n  long start = std::min(a, b);\n  long end = std::max(a, b);\n  for (long i = start; i <= end; i++) {\n    std::string str = std::to_string(i);\n    for (char c : str) {\n      if (c % 2 == 0) {\n        result.push_back(std::stol(std::string(1, c)));\n      }\n    }\n  }\n  std::sort(result.begin(), result.end());\n  return result;"]]